/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/dotenv/package.json
var require_package = __commonJS({
  "node_modules/dotenv/package.json"(exports, module2) {
    module2.exports = {
      name: "dotenv",
      version: "16.4.5",
      description: "Loads environment variables from .env file",
      main: "lib/main.js",
      types: "lib/main.d.ts",
      exports: {
        ".": {
          types: "./lib/main.d.ts",
          require: "./lib/main.js",
          default: "./lib/main.js"
        },
        "./config": "./config.js",
        "./config.js": "./config.js",
        "./lib/env-options": "./lib/env-options.js",
        "./lib/env-options.js": "./lib/env-options.js",
        "./lib/cli-options": "./lib/cli-options.js",
        "./lib/cli-options.js": "./lib/cli-options.js",
        "./package.json": "./package.json"
      },
      scripts: {
        "dts-check": "tsc --project tests/types/tsconfig.json",
        lint: "standard",
        "lint-readme": "standard-markdown",
        pretest: "npm run lint && npm run dts-check",
        test: "tap tests/*.js --100 -Rspec",
        "test:coverage": "tap --coverage-report=lcov",
        prerelease: "npm test",
        release: "standard-version"
      },
      repository: {
        type: "git",
        url: "git://github.com/motdotla/dotenv.git"
      },
      funding: "https://dotenvx.com",
      keywords: [
        "dotenv",
        "env",
        ".env",
        "environment",
        "variables",
        "config",
        "settings"
      ],
      readmeFilename: "README.md",
      license: "BSD-2-Clause",
      devDependencies: {
        "@definitelytyped/dtslint": "^0.0.133",
        "@types/node": "^18.11.3",
        decache: "^4.6.1",
        sinon: "^14.0.1",
        standard: "^17.0.0",
        "standard-markdown": "^7.1.0",
        "standard-version": "^9.5.0",
        tap: "^16.3.0",
        tar: "^6.1.11",
        typescript: "^4.8.4"
      },
      engines: {
        node: ">=12"
      },
      browser: {
        fs: false
      }
    };
  }
});

// node_modules/dotenv/lib/main.js
var require_main = __commonJS({
  "node_modules/dotenv/lib/main.js"(exports, module2) {
    var fs = require("fs");
    var path = require("path");
    var os = require("os");
    var crypto = require("crypto");
    var packageJson = require_package();
    var version = packageJson.version;
    var LINE = /(?:^|^)\s*(?:export\s+)?([\w.-]+)(?:\s*=\s*?|:\s+?)(\s*'(?:\\'|[^'])*'|\s*"(?:\\"|[^"])*"|\s*`(?:\\`|[^`])*`|[^#\r\n]+)?\s*(?:#.*)?(?:$|$)/mg;
    function parse(src) {
      const obj = {};
      let lines = src.toString();
      lines = lines.replace(/\r\n?/mg, "\n");
      let match;
      while ((match = LINE.exec(lines)) != null) {
        const key = match[1];
        let value = match[2] || "";
        value = value.trim();
        const maybeQuote = value[0];
        value = value.replace(/^(['"`])([\s\S]*)\1$/mg, "$2");
        if (maybeQuote === '"') {
          value = value.replace(/\\n/g, "\n");
          value = value.replace(/\\r/g, "\r");
        }
        obj[key] = value;
      }
      return obj;
    }
    function _parseVault(options) {
      const vaultPath = _vaultPath(options);
      const result = DotenvModule.configDotenv({ path: vaultPath });
      if (!result.parsed) {
        const err = new Error(`MISSING_DATA: Cannot parse ${vaultPath} for an unknown reason`);
        err.code = "MISSING_DATA";
        throw err;
      }
      const keys = _dotenvKey(options).split(",");
      const length = keys.length;
      let decrypted;
      for (let i = 0; i < length; i++) {
        try {
          const key = keys[i].trim();
          const attrs = _instructions(result, key);
          decrypted = DotenvModule.decrypt(attrs.ciphertext, attrs.key);
          break;
        } catch (error) {
          if (i + 1 >= length) {
            throw error;
          }
        }
      }
      return DotenvModule.parse(decrypted);
    }
    function _log(message) {
      console.log(`[dotenv@${version}][INFO] ${message}`);
    }
    function _warn(message) {
      console.log(`[dotenv@${version}][WARN] ${message}`);
    }
    function _debug(message) {
      console.log(`[dotenv@${version}][DEBUG] ${message}`);
    }
    function _dotenvKey(options) {
      if (options && options.DOTENV_KEY && options.DOTENV_KEY.length > 0) {
        return options.DOTENV_KEY;
      }
      if (process.env.DOTENV_KEY && process.env.DOTENV_KEY.length > 0) {
        return process.env.DOTENV_KEY;
      }
      return "";
    }
    function _instructions(result, dotenvKey) {
      let uri;
      try {
        uri = new URL(dotenvKey);
      } catch (error) {
        if (error.code === "ERR_INVALID_URL") {
          const err = new Error("INVALID_DOTENV_KEY: Wrong format. Must be in valid uri format like dotenv://:key_1234@dotenvx.com/vault/.env.vault?environment=development");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        }
        throw error;
      }
      const key = uri.password;
      if (!key) {
        const err = new Error("INVALID_DOTENV_KEY: Missing key part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environment = uri.searchParams.get("environment");
      if (!environment) {
        const err = new Error("INVALID_DOTENV_KEY: Missing environment part");
        err.code = "INVALID_DOTENV_KEY";
        throw err;
      }
      const environmentKey = `DOTENV_VAULT_${environment.toUpperCase()}`;
      const ciphertext = result.parsed[environmentKey];
      if (!ciphertext) {
        const err = new Error(`NOT_FOUND_DOTENV_ENVIRONMENT: Cannot locate environment ${environmentKey} in your .env.vault file.`);
        err.code = "NOT_FOUND_DOTENV_ENVIRONMENT";
        throw err;
      }
      return { ciphertext, key };
    }
    function _vaultPath(options) {
      let possibleVaultPath = null;
      if (options && options.path && options.path.length > 0) {
        if (Array.isArray(options.path)) {
          for (const filepath of options.path) {
            if (fs.existsSync(filepath)) {
              possibleVaultPath = filepath.endsWith(".vault") ? filepath : `${filepath}.vault`;
            }
          }
        } else {
          possibleVaultPath = options.path.endsWith(".vault") ? options.path : `${options.path}.vault`;
        }
      } else {
        possibleVaultPath = path.resolve(process.cwd(), ".env.vault");
      }
      if (fs.existsSync(possibleVaultPath)) {
        return possibleVaultPath;
      }
      return null;
    }
    function _resolveHome(envPath) {
      return envPath[0] === "~" ? path.join(os.homedir(), envPath.slice(1)) : envPath;
    }
    function _configVault(options) {
      _log("Loading env from encrypted .env.vault");
      const parsed = DotenvModule._parseVault(options);
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsed, options);
      return { parsed };
    }
    function configDotenv(options) {
      const dotenvPath = path.resolve(process.cwd(), ".env");
      let encoding = "utf8";
      const debug2 = Boolean(options && options.debug);
      if (options && options.encoding) {
        encoding = options.encoding;
      } else {
        if (debug2) {
          _debug("No encoding is specified. UTF-8 is used by default");
        }
      }
      let optionPaths = [dotenvPath];
      if (options && options.path) {
        if (!Array.isArray(options.path)) {
          optionPaths = [_resolveHome(options.path)];
        } else {
          optionPaths = [];
          for (const filepath of options.path) {
            optionPaths.push(_resolveHome(filepath));
          }
        }
      }
      let lastError;
      const parsedAll = {};
      for (const path2 of optionPaths) {
        try {
          const parsed = DotenvModule.parse(fs.readFileSync(path2, { encoding }));
          DotenvModule.populate(parsedAll, parsed, options);
        } catch (e) {
          if (debug2) {
            _debug(`Failed to load ${path2} ${e.message}`);
          }
          lastError = e;
        }
      }
      let processEnv = process.env;
      if (options && options.processEnv != null) {
        processEnv = options.processEnv;
      }
      DotenvModule.populate(processEnv, parsedAll, options);
      if (lastError) {
        return { parsed: parsedAll, error: lastError };
      } else {
        return { parsed: parsedAll };
      }
    }
    function config2(options) {
      if (_dotenvKey(options).length === 0) {
        return DotenvModule.configDotenv(options);
      }
      const vaultPath = _vaultPath(options);
      if (!vaultPath) {
        _warn(`You set DOTENV_KEY but you are missing a .env.vault file at ${vaultPath}. Did you forget to build it?`);
        return DotenvModule.configDotenv(options);
      }
      return DotenvModule._configVault(options);
    }
    function decrypt(encrypted, keyStr) {
      const key = Buffer.from(keyStr.slice(-64), "hex");
      let ciphertext = Buffer.from(encrypted, "base64");
      const nonce = ciphertext.subarray(0, 12);
      const authTag = ciphertext.subarray(-16);
      ciphertext = ciphertext.subarray(12, -16);
      try {
        const aesgcm = crypto.createDecipheriv("aes-256-gcm", key, nonce);
        aesgcm.setAuthTag(authTag);
        return `${aesgcm.update(ciphertext)}${aesgcm.final()}`;
      } catch (error) {
        const isRange = error instanceof RangeError;
        const invalidKeyLength = error.message === "Invalid key length";
        const decryptionFailed = error.message === "Unsupported state or unable to authenticate data";
        if (isRange || invalidKeyLength) {
          const err = new Error("INVALID_DOTENV_KEY: It must be 64 characters long (or more)");
          err.code = "INVALID_DOTENV_KEY";
          throw err;
        } else if (decryptionFailed) {
          const err = new Error("DECRYPTION_FAILED: Please check your DOTENV_KEY");
          err.code = "DECRYPTION_FAILED";
          throw err;
        } else {
          throw error;
        }
      }
    }
    function populate(processEnv, parsed, options = {}) {
      const debug2 = Boolean(options && options.debug);
      const override = Boolean(options && options.override);
      if (typeof parsed !== "object") {
        const err = new Error("OBJECT_REQUIRED: Please check the processEnv argument being passed to populate");
        err.code = "OBJECT_REQUIRED";
        throw err;
      }
      for (const key of Object.keys(parsed)) {
        if (Object.prototype.hasOwnProperty.call(processEnv, key)) {
          if (override === true) {
            processEnv[key] = parsed[key];
          }
          if (debug2) {
            if (override === true) {
              _debug(`"${key}" is already defined and WAS overwritten`);
            } else {
              _debug(`"${key}" is already defined and was NOT overwritten`);
            }
          }
        } else {
          processEnv[key] = parsed[key];
        }
      }
    }
    var DotenvModule = {
      configDotenv,
      _configVault,
      _parseVault,
      config: config2,
      decrypt,
      parse,
      populate
    };
    module2.exports.configDotenv = DotenvModule.configDotenv;
    module2.exports._configVault = DotenvModule._configVault;
    module2.exports._parseVault = DotenvModule._parseVault;
    module2.exports.config = DotenvModule.config;
    module2.exports.decrypt = DotenvModule.decrypt;
    module2.exports.parse = DotenvModule.parse;
    module2.exports.populate = DotenvModule.populate;
    module2.exports = DotenvModule;
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  CMDJModal: () => CMDJModal,
  VIEW_NAME_MAIN_CHAT: () => VIEW_NAME_MAIN_CHAT,
  VIEW_NAME_SIDEBAR_CHAT: () => VIEW_NAME_SIDEBAR_CHAT,
  default: () => MyPlugin,
  redBackgroundField: () => redBackgroundField
});
module.exports = __toCommonJS(main_exports);

// node_modules/groq-sdk/version.mjs
var VERSION = "0.3.3";

// node_modules/groq-sdk/_shims/registry.mjs
var auto = false;
var kind = void 0;
var fetch2 = void 0;
var Request2 = void 0;
var Response2 = void 0;
var Headers2 = void 0;
var FormData2 = void 0;
var Blob2 = void 0;
var File2 = void 0;
var ReadableStream2 = void 0;
var getMultipartRequestOptions = void 0;
var getDefaultAgent = void 0;
var fileFromPath = void 0;
var isFsReadStream = void 0;
function setShims(shims, options = { auto: false }) {
  if (auto) {
    throw new Error(`you must \`import 'groq-sdk/shims/${shims.kind}'\` before importing anything else from groq-sdk`);
  }
  if (kind) {
    throw new Error(`can't \`import 'groq-sdk/shims/${shims.kind}'\` after \`import 'groq-sdk/shims/${kind}'\``);
  }
  auto = options.auto;
  kind = shims.kind;
  fetch2 = shims.fetch;
  Request2 = shims.Request;
  Response2 = shims.Response;
  Headers2 = shims.Headers;
  FormData2 = shims.FormData;
  Blob2 = shims.Blob;
  File2 = shims.File;
  ReadableStream2 = shims.ReadableStream;
  getMultipartRequestOptions = shims.getMultipartRequestOptions;
  getDefaultAgent = shims.getDefaultAgent;
  fileFromPath = shims.fileFromPath;
  isFsReadStream = shims.isFsReadStream;
}

// node_modules/groq-sdk/_shims/MultipartBody.mjs
var MultipartBody = class {
  constructor(body) {
    this.body = body;
  }
  get [Symbol.toStringTag]() {
    return "MultipartBody";
  }
};

// node_modules/groq-sdk/_shims/web-runtime.mjs
function getRuntime({ manuallyImported } = {}) {
  const recommendation = manuallyImported ? `You may need to use polyfills` : `Add one of these imports before your first \`import \u2026 from 'groq-sdk'\`:
- \`import 'groq-sdk/shims/node'\` (if you're running on Node)
- \`import 'groq-sdk/shims/web'\` (otherwise)
`;
  let _fetch, _Request, _Response, _Headers;
  try {
    _fetch = fetch;
    _Request = Request;
    _Response = Response;
    _Headers = Headers;
  } catch (error) {
    throw new Error(`this environment is missing the following Web Fetch API type: ${error.message}. ${recommendation}`);
  }
  return {
    kind: "web",
    fetch: _fetch,
    Request: _Request,
    Response: _Response,
    Headers: _Headers,
    FormData: (
      // @ts-ignore
      typeof FormData !== "undefined" ? FormData : class FormData {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'FormData' is undefined. ${recommendation}`);
        }
      }
    ),
    Blob: typeof Blob !== "undefined" ? Blob : class Blob {
      constructor() {
        throw new Error(`file uploads aren't supported in this environment yet as 'Blob' is undefined. ${recommendation}`);
      }
    },
    File: (
      // @ts-ignore
      typeof File !== "undefined" ? File : class File {
        // @ts-ignore
        constructor() {
          throw new Error(`file uploads aren't supported in this environment yet as 'File' is undefined. ${recommendation}`);
        }
      }
    ),
    ReadableStream: (
      // @ts-ignore
      typeof ReadableStream !== "undefined" ? ReadableStream : class ReadableStream {
        // @ts-ignore
        constructor() {
          throw new Error(`streaming isn't supported in this environment yet as 'ReadableStream' is undefined. ${recommendation}`);
        }
      }
    ),
    getMultipartRequestOptions: async (form, opts) => ({
      ...opts,
      body: new MultipartBody(form)
    }),
    getDefaultAgent: (url) => void 0,
    fileFromPath: () => {
      throw new Error("The `fileFromPath` function is only supported in Node. See the README for more details: https://www.github.com/groq/groq-typescript#file-uploads");
    },
    isFsReadStream: (value) => false
  };
}

// node_modules/groq-sdk/_shims/index.mjs
if (!kind)
  setShims(getRuntime(), { auto: true });

// node_modules/groq-sdk/error.mjs
var error_exports = {};
__export(error_exports, {
  APIConnectionError: () => APIConnectionError,
  APIConnectionTimeoutError: () => APIConnectionTimeoutError,
  APIError: () => APIError,
  APIUserAbortError: () => APIUserAbortError,
  AuthenticationError: () => AuthenticationError,
  BadRequestError: () => BadRequestError,
  ConflictError: () => ConflictError,
  GroqError: () => GroqError,
  InternalServerError: () => InternalServerError,
  NotFoundError: () => NotFoundError,
  PermissionDeniedError: () => PermissionDeniedError,
  RateLimitError: () => RateLimitError,
  UnprocessableEntityError: () => UnprocessableEntityError
});
var GroqError = class extends Error {
};
var APIError = class extends GroqError {
  constructor(status, error, message, headers) {
    super(`${APIError.makeMessage(status, error, message)}`);
    this.status = status;
    this.headers = headers;
    this.error = error;
  }
  static makeMessage(status, error, message) {
    const msg = (error == null ? void 0 : error.message) ? typeof error.message === "string" ? error.message : JSON.stringify(error.message) : error ? JSON.stringify(error) : message;
    if (status && msg) {
      return `${status} ${msg}`;
    }
    if (status) {
      return `${status} status code (no body)`;
    }
    if (msg) {
      return msg;
    }
    return "(no status code or body)";
  }
  static generate(status, errorResponse, message, headers) {
    if (!status) {
      return new APIConnectionError({ cause: castToError(errorResponse) });
    }
    const error = errorResponse;
    if (status === 400) {
      return new BadRequestError(status, error, message, headers);
    }
    if (status === 401) {
      return new AuthenticationError(status, error, message, headers);
    }
    if (status === 403) {
      return new PermissionDeniedError(status, error, message, headers);
    }
    if (status === 404) {
      return new NotFoundError(status, error, message, headers);
    }
    if (status === 409) {
      return new ConflictError(status, error, message, headers);
    }
    if (status === 422) {
      return new UnprocessableEntityError(status, error, message, headers);
    }
    if (status === 429) {
      return new RateLimitError(status, error, message, headers);
    }
    if (status >= 500) {
      return new InternalServerError(status, error, message, headers);
    }
    return new APIError(status, error, message, headers);
  }
};
var APIUserAbortError = class extends APIError {
  constructor({ message } = {}) {
    super(void 0, void 0, message || "Request was aborted.", void 0);
    this.status = void 0;
  }
};
var APIConnectionError = class extends APIError {
  constructor({ message, cause }) {
    super(void 0, void 0, message || "Connection error.", void 0);
    this.status = void 0;
    if (cause)
      this.cause = cause;
  }
};
var APIConnectionTimeoutError = class extends APIConnectionError {
  constructor({ message } = {}) {
    super({ message: message != null ? message : "Request timed out." });
  }
};
var BadRequestError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 400;
  }
};
var AuthenticationError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 401;
  }
};
var PermissionDeniedError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 403;
  }
};
var NotFoundError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 404;
  }
};
var ConflictError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 409;
  }
};
var UnprocessableEntityError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 422;
  }
};
var RateLimitError = class extends APIError {
  constructor() {
    super(...arguments);
    this.status = 429;
  }
};
var InternalServerError = class extends APIError {
};

// node_modules/groq-sdk/lib/streaming.mjs
var Stream = class {
  constructor(iterator, controller) {
    this.iterator = iterator;
    this.controller = controller;
  }
  static fromSSEResponse(response, controller) {
    let consumed = false;
    const decoder = new SSEDecoder();
    async function* iterMessages() {
      if (!response.body) {
        controller.abort();
        throw new GroqError(`Attempted to iterate over a response with no body`);
      }
      const lineDecoder = new LineDecoder();
      const iter = readableStreamAsyncIterable(response.body);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          const sse = decoder.decode(line);
          if (sse)
            yield sse;
        }
      }
      for (const line of lineDecoder.flush()) {
        const sse = decoder.decode(line);
        if (sse)
          yield sse;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const sse of iterMessages()) {
          if (done)
            continue;
          if (sse.data.startsWith("[DONE]")) {
            done = true;
            continue;
          }
          if (sse.event === null) {
            let data;
            try {
              data = JSON.parse(sse.data);
            } catch (e) {
              console.error(`Could not parse message into JSON:`, sse.data);
              console.error(`From chunk:`, sse.raw);
              throw e;
            }
            if (data && data.error) {
              throw new APIError(void 0, data.error, void 0, void 0);
            }
            yield data;
          }
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  /**
   * Generates a Stream from a newline-separated ReadableStream
   * where each item is a JSON value.
   */
  static fromReadableStream(readableStream, controller) {
    let consumed = false;
    async function* iterLines() {
      const lineDecoder = new LineDecoder();
      const iter = readableStreamAsyncIterable(readableStream);
      for await (const chunk of iter) {
        for (const line of lineDecoder.decode(chunk)) {
          yield line;
        }
      }
      for (const line of lineDecoder.flush()) {
        yield line;
      }
    }
    async function* iterator() {
      if (consumed) {
        throw new Error("Cannot iterate over a consumed stream, use `.tee()` to split the stream.");
      }
      consumed = true;
      let done = false;
      try {
        for await (const line of iterLines()) {
          if (done)
            continue;
          if (line)
            yield JSON.parse(line);
        }
        done = true;
      } catch (e) {
        if (e instanceof Error && e.name === "AbortError")
          return;
        throw e;
      } finally {
        if (!done)
          controller.abort();
      }
    }
    return new Stream(iterator, controller);
  }
  [Symbol.asyncIterator]() {
    return this.iterator();
  }
  /**
   * Splits the stream into two streams which can be
   * independently read from at different speeds.
   */
  tee() {
    const left = [];
    const right = [];
    const iterator = this.iterator();
    const teeIterator = (queue) => {
      return {
        next: () => {
          if (queue.length === 0) {
            const result = iterator.next();
            left.push(result);
            right.push(result);
          }
          return queue.shift();
        }
      };
    };
    return [
      new Stream(() => teeIterator(left), this.controller),
      new Stream(() => teeIterator(right), this.controller)
    ];
  }
  /**
   * Converts this stream to a newline-separated ReadableStream of
   * JSON stringified values in the stream
   * which can be turned back into a Stream with `Stream.fromReadableStream()`.
   */
  toReadableStream() {
    const self = this;
    let iter;
    const encoder = new TextEncoder();
    return new ReadableStream2({
      async start() {
        iter = self[Symbol.asyncIterator]();
      },
      async pull(ctrl) {
        try {
          const { value, done } = await iter.next();
          if (done)
            return ctrl.close();
          const bytes = encoder.encode(JSON.stringify(value) + "\n");
          ctrl.enqueue(bytes);
        } catch (err) {
          ctrl.error(err);
        }
      },
      async cancel() {
        var _a2;
        await ((_a2 = iter.return) == null ? void 0 : _a2.call(iter));
      }
    });
  }
};
var SSEDecoder = class {
  constructor() {
    this.event = null;
    this.data = [];
    this.chunks = [];
  }
  decode(line) {
    if (line.endsWith("\r")) {
      line = line.substring(0, line.length - 1);
    }
    if (!line) {
      if (!this.event && !this.data.length)
        return null;
      const sse = {
        event: this.event,
        data: this.data.join("\n"),
        raw: this.chunks
      };
      this.event = null;
      this.data = [];
      this.chunks = [];
      return sse;
    }
    this.chunks.push(line);
    if (line.startsWith(":")) {
      return null;
    }
    let [fieldname, _, value] = partition(line, ":");
    if (value.startsWith(" ")) {
      value = value.substring(1);
    }
    if (fieldname === "event") {
      this.event = value;
    } else if (fieldname === "data") {
      this.data.push(value);
    }
    return null;
  }
};
var LineDecoder = class {
  constructor() {
    this.buffer = [];
    this.trailingCR = false;
  }
  decode(chunk) {
    let text = this.decodeText(chunk);
    if (this.trailingCR) {
      text = "\r" + text;
      this.trailingCR = false;
    }
    if (text.endsWith("\r")) {
      this.trailingCR = true;
      text = text.slice(0, -1);
    }
    if (!text) {
      return [];
    }
    const trailingNewline = LineDecoder.NEWLINE_CHARS.has(text[text.length - 1] || "");
    let lines = text.split(LineDecoder.NEWLINE_REGEXP);
    if (lines.length === 1 && !trailingNewline) {
      this.buffer.push(lines[0]);
      return [];
    }
    if (this.buffer.length > 0) {
      lines = [this.buffer.join("") + lines[0], ...lines.slice(1)];
      this.buffer = [];
    }
    if (!trailingNewline) {
      this.buffer = [lines.pop() || ""];
    }
    return lines;
  }
  decodeText(bytes) {
    var _a2;
    if (bytes == null)
      return "";
    if (typeof bytes === "string")
      return bytes;
    if (typeof Buffer !== "undefined") {
      if (bytes instanceof Buffer) {
        return bytes.toString();
      }
      if (bytes instanceof Uint8Array) {
        return Buffer.from(bytes).toString();
      }
      throw new GroqError(`Unexpected: received non-Uint8Array (${bytes.constructor.name}) stream chunk in an environment with a global "Buffer" defined, which this library assumes to be Node. Please report this error.`);
    }
    if (typeof TextDecoder !== "undefined") {
      if (bytes instanceof Uint8Array || bytes instanceof ArrayBuffer) {
        (_a2 = this.textDecoder) != null ? _a2 : this.textDecoder = new TextDecoder("utf8");
        return this.textDecoder.decode(bytes);
      }
      throw new GroqError(`Unexpected: received non-Uint8Array/ArrayBuffer (${bytes.constructor.name}) in a web platform. Please report this error.`);
    }
    throw new GroqError(`Unexpected: neither Buffer nor TextDecoder are available as globals. Please report this error.`);
  }
  flush() {
    if (!this.buffer.length && !this.trailingCR) {
      return [];
    }
    const lines = [this.buffer.join("")];
    this.buffer = [];
    this.trailingCR = false;
    return lines;
  }
};
LineDecoder.NEWLINE_CHARS = /* @__PURE__ */ new Set(["\n", "\r", "\v", "\f", "", "", "", "\x85", "\u2028", "\u2029"]);
LineDecoder.NEWLINE_REGEXP = /\r\n|[\n\r\x0b\x0c\x1c\x1d\x1e\x85\u2028\u2029]/g;
function partition(str, delimiter) {
  const index = str.indexOf(delimiter);
  if (index !== -1) {
    return [str.substring(0, index), delimiter, str.substring(index + delimiter.length)];
  }
  return [str, "", ""];
}
function readableStreamAsyncIterable(stream) {
  if (stream[Symbol.asyncIterator])
    return stream;
  const reader = stream.getReader();
  return {
    async next() {
      try {
        const result = await reader.read();
        if (result == null ? void 0 : result.done)
          reader.releaseLock();
        return result;
      } catch (e) {
        reader.releaseLock();
        throw e;
      }
    },
    async return() {
      const cancelPromise = reader.cancel();
      reader.releaseLock();
      await cancelPromise;
      return { done: true, value: void 0 };
    },
    [Symbol.asyncIterator]() {
      return this;
    }
  };
}

// node_modules/groq-sdk/uploads.mjs
var isResponseLike = (value) => value != null && typeof value === "object" && typeof value.url === "string" && typeof value.blob === "function";
var isFileLike = (value) => value != null && typeof value === "object" && typeof value.name === "string" && typeof value.lastModified === "number" && isBlobLike(value);
var isBlobLike = (value) => value != null && typeof value === "object" && typeof value.size === "number" && typeof value.type === "string" && typeof value.text === "function" && typeof value.slice === "function" && typeof value.arrayBuffer === "function";
var isUploadable = (value) => {
  return isFileLike(value) || isResponseLike(value) || isFsReadStream(value);
};
async function toFile(value, name, options = {}) {
  var _a2, _b, _c;
  value = await value;
  if (isResponseLike(value)) {
    const blob = await value.blob();
    name || (name = (_a2 = new URL(value.url).pathname.split(/[\\/]/).pop()) != null ? _a2 : "unknown_file");
    return new File2([blob], name, options);
  }
  const bits = await getBytes(value);
  name || (name = (_b = getName(value)) != null ? _b : "unknown_file");
  if (!options.type) {
    const type = (_c = bits[0]) == null ? void 0 : _c.type;
    if (typeof type === "string") {
      options = { ...options, type };
    }
  }
  return new File2(bits, name, options);
}
async function getBytes(value) {
  var _a2;
  let parts = [];
  if (typeof value === "string" || ArrayBuffer.isView(value) || // includes Uint8Array, Buffer, etc.
  value instanceof ArrayBuffer) {
    parts.push(value);
  } else if (isBlobLike(value)) {
    parts.push(await value.arrayBuffer());
  } else if (isAsyncIterableIterator(value)) {
    for await (const chunk of value) {
      parts.push(chunk);
    }
  } else {
    throw new Error(`Unexpected data type: ${typeof value}; constructor: ${(_a2 = value == null ? void 0 : value.constructor) == null ? void 0 : _a2.name}; props: ${propsForError(value)}`);
  }
  return parts;
}
function propsForError(value) {
  const props = Object.getOwnPropertyNames(value);
  return `[${props.map((p) => `"${p}"`).join(", ")}]`;
}
function getName(value) {
  var _a2;
  return getStringFromMaybeBuffer(value.name) || getStringFromMaybeBuffer(value.filename) || // For fs.ReadStream
  ((_a2 = getStringFromMaybeBuffer(value.path)) == null ? void 0 : _a2.split(/[\\/]/).pop());
}
var getStringFromMaybeBuffer = (x) => {
  if (typeof x === "string")
    return x;
  if (typeof Buffer !== "undefined" && x instanceof Buffer)
    return String(x);
  return void 0;
};
var isAsyncIterableIterator = (value) => value != null && typeof value === "object" && typeof value[Symbol.asyncIterator] === "function";
var isMultipartBody = (body) => body && typeof body === "object" && body.body && body[Symbol.toStringTag] === "MultipartBody";
var multipartFormRequestOptions = async (opts) => {
  const form = await createForm(opts.body);
  return getMultipartRequestOptions(form, opts);
};
var createForm = async (body) => {
  const form = new FormData2();
  await Promise.all(Object.entries(body || {}).map(([key, value]) => addFormValue(form, key, value)));
  return form;
};
var addFormValue = async (form, key, value) => {
  if (value === void 0)
    return;
  if (value == null) {
    throw new TypeError(`Received null for "${key}"; to pass null in FormData, you must use the string 'null'`);
  }
  if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
    form.append(key, String(value));
  } else if (isUploadable(value)) {
    const file = await toFile(value);
    form.append(key, file);
  } else if (Array.isArray(value)) {
    await Promise.all(value.map((entry) => addFormValue(form, key + "[]", entry)));
  } else if (typeof value === "object") {
    await Promise.all(Object.entries(value).map(([name, prop]) => addFormValue(form, `${key}[${name}]`, prop)));
  } else {
    throw new TypeError(`Invalid value given to form, expected a string, number, boolean, object, Array, File or Blob but got ${value} instead`);
  }
};

// node_modules/groq-sdk/core.mjs
var __classPrivateFieldSet = function(receiver, state, value, kind2, f) {
  if (kind2 === "m")
    throw new TypeError("Private method is not writable");
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a setter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot write private member to an object whose class did not declare it");
  return kind2 === "a" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value), value;
};
var __classPrivateFieldGet = function(receiver, state, kind2, f) {
  if (kind2 === "a" && !f)
    throw new TypeError("Private accessor was defined without a getter");
  if (typeof state === "function" ? receiver !== state || !f : !state.has(receiver))
    throw new TypeError("Cannot read private member from an object whose class did not declare it");
  return kind2 === "m" ? f : kind2 === "a" ? f.call(receiver) : f ? f.value : state.get(receiver);
};
var _AbstractPage_client;
async function defaultParseResponse(props) {
  const { response } = props;
  if (props.options.stream) {
    debug("response", response.status, response.url, response.headers, response.body);
    if (props.options.__streamClass) {
      return props.options.__streamClass.fromSSEResponse(response, props.controller);
    }
    return Stream.fromSSEResponse(response, props.controller);
  }
  if (response.status === 204) {
    return null;
  }
  if (props.options.__binaryResponse) {
    return response;
  }
  const contentType = response.headers.get("content-type");
  const isJSON = (contentType == null ? void 0 : contentType.includes("application/json")) || (contentType == null ? void 0 : contentType.includes("application/vnd.api+json"));
  if (isJSON) {
    const json = await response.json();
    debug("response", response.status, response.url, response.headers, json);
    return json;
  }
  const text = await response.text();
  debug("response", response.status, response.url, response.headers, text);
  return text;
}
var APIPromise = class extends Promise {
  constructor(responsePromise, parseResponse = defaultParseResponse) {
    super((resolve) => {
      resolve(null);
    });
    this.responsePromise = responsePromise;
    this.parseResponse = parseResponse;
  }
  _thenUnwrap(transform) {
    return new APIPromise(this.responsePromise, async (props) => transform(await this.parseResponse(props)));
  }
  /**
   * Gets the raw `Response` instance instead of parsing the response
   * data.
   *
   * If you want to parse the response body but still get the `Response`
   * instance, you can use {@link withResponse()}.
   *
   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import â€¦ from 'groq-sdk'`:
   * - `import 'groq-sdk/shims/node'` (if you're running on Node)
   * - `import 'groq-sdk/shims/web'` (otherwise)
   */
  asResponse() {
    return this.responsePromise.then((p) => p.response);
  }
  /**
   * Gets the parsed response data and the raw `Response` instance.
   *
   * If you just want to get the raw `Response` instance without parsing it,
   * you can use {@link asResponse()}.
   *
   *
   * ðŸ‘‹ Getting the wrong TypeScript type for `Response`?
   * Try setting `"moduleResolution": "NodeNext"` if you can,
   * or add one of these imports before your first `import â€¦ from 'groq-sdk'`:
   * - `import 'groq-sdk/shims/node'` (if you're running on Node)
   * - `import 'groq-sdk/shims/web'` (otherwise)
   */
  async withResponse() {
    const [data, response] = await Promise.all([this.parse(), this.asResponse()]);
    return { data, response };
  }
  parse() {
    if (!this.parsedPromise) {
      this.parsedPromise = this.responsePromise.then(this.parseResponse);
    }
    return this.parsedPromise;
  }
  then(onfulfilled, onrejected) {
    return this.parse().then(onfulfilled, onrejected);
  }
  catch(onrejected) {
    return this.parse().catch(onrejected);
  }
  finally(onfinally) {
    return this.parse().finally(onfinally);
  }
};
var APIClient = class {
  constructor({
    baseURL,
    maxRetries = 2,
    timeout = 6e4,
    // 1 minute
    httpAgent,
    fetch: overridenFetch
  }) {
    this.baseURL = baseURL;
    this.maxRetries = validatePositiveInteger("maxRetries", maxRetries);
    this.timeout = validatePositiveInteger("timeout", timeout);
    this.httpAgent = httpAgent;
    this.fetch = overridenFetch != null ? overridenFetch : fetch2;
  }
  authHeaders(opts) {
    return {};
  }
  /**
   * Override this to add your own default headers, for example:
   *
   *  {
   *    ...super.defaultHeaders(),
   *    Authorization: 'Bearer 123',
   *  }
   */
  defaultHeaders(opts) {
    return {
      Accept: "application/json",
      "Content-Type": "application/json",
      "User-Agent": this.getUserAgent(),
      ...getPlatformHeaders(),
      ...this.authHeaders(opts)
    };
  }
  /**
   * Override this to add your own headers validation:
   */
  validateHeaders(headers, customHeaders) {
  }
  defaultIdempotencyKey() {
    return `stainless-node-retry-${uuid4()}`;
  }
  get(path, opts) {
    return this.methodRequest("get", path, opts);
  }
  post(path, opts) {
    return this.methodRequest("post", path, opts);
  }
  patch(path, opts) {
    return this.methodRequest("patch", path, opts);
  }
  put(path, opts) {
    return this.methodRequest("put", path, opts);
  }
  delete(path, opts) {
    return this.methodRequest("delete", path, opts);
  }
  methodRequest(method, path, opts) {
    return this.request(Promise.resolve(opts).then((opts2) => ({ method, path, ...opts2 })));
  }
  getAPIList(path, Page, opts) {
    return this.requestAPIList(Page, { method: "get", path, ...opts });
  }
  calculateContentLength(body) {
    if (typeof body === "string") {
      if (typeof Buffer !== "undefined") {
        return Buffer.byteLength(body, "utf8").toString();
      }
      if (typeof TextEncoder !== "undefined") {
        const encoder = new TextEncoder();
        const encoded = encoder.encode(body);
        return encoded.length.toString();
      }
    }
    return null;
  }
  buildRequest(options) {
    var _a2, _b, _c, _d, _e, _f;
    const { method, path, query, headers = {} } = options;
    const body = isMultipartBody(options.body) ? options.body.body : options.body ? JSON.stringify(options.body, null, 2) : null;
    const contentLength = this.calculateContentLength(body);
    const url = this.buildURL(path, query);
    if ("timeout" in options)
      validatePositiveInteger("timeout", options.timeout);
    const timeout = (_a2 = options.timeout) != null ? _a2 : this.timeout;
    const httpAgent = (_c = (_b = options.httpAgent) != null ? _b : this.httpAgent) != null ? _c : getDefaultAgent(url);
    const minAgentTimeout = timeout + 1e3;
    if (typeof ((_d = httpAgent == null ? void 0 : httpAgent.options) == null ? void 0 : _d.timeout) === "number" && minAgentTimeout > ((_e = httpAgent.options.timeout) != null ? _e : 0)) {
      httpAgent.options.timeout = minAgentTimeout;
    }
    if (this.idempotencyHeader && method !== "get") {
      if (!options.idempotencyKey)
        options.idempotencyKey = this.defaultIdempotencyKey();
      headers[this.idempotencyHeader] = options.idempotencyKey;
    }
    const reqHeaders = this.buildHeaders({ options, headers, contentLength });
    const req = {
      method,
      ...body && { body },
      headers: reqHeaders,
      ...httpAgent && { agent: httpAgent },
      // @ts-ignore node-fetch uses a custom AbortSignal type that is
      // not compatible with standard web types
      signal: (_f = options.signal) != null ? _f : null
    };
    return { req, url, timeout };
  }
  buildHeaders({ options, headers, contentLength }) {
    const reqHeaders = {};
    if (contentLength) {
      reqHeaders["content-length"] = contentLength;
    }
    const defaultHeaders = this.defaultHeaders(options);
    applyHeadersMut(reqHeaders, defaultHeaders);
    applyHeadersMut(reqHeaders, headers);
    if (isMultipartBody(options.body) && kind !== "node") {
      delete reqHeaders["content-type"];
    }
    this.validateHeaders(reqHeaders, headers);
    return reqHeaders;
  }
  /**
   * Used as a callback for mutating the given `FinalRequestOptions` object.
   */
  async prepareOptions(options) {
  }
  /**
   * Used as a callback for mutating the given `RequestInit` object.
   *
   * This is useful for cases where you want to add certain headers based off of
   * the request properties, e.g. `method` or `url`.
   */
  async prepareRequest(request, { url, options }) {
  }
  parseHeaders(headers) {
    return !headers ? {} : Symbol.iterator in headers ? Object.fromEntries(Array.from(headers).map((header) => [...header])) : { ...headers };
  }
  makeStatusError(status, error, message, headers) {
    return APIError.generate(status, error, message, headers);
  }
  request(options, remainingRetries = null) {
    return new APIPromise(this.makeRequest(options, remainingRetries));
  }
  async makeRequest(optionsInput, retriesRemaining) {
    var _a2, _b, _c;
    const options = await optionsInput;
    if (retriesRemaining == null) {
      retriesRemaining = (_a2 = options.maxRetries) != null ? _a2 : this.maxRetries;
    }
    await this.prepareOptions(options);
    const { req, url, timeout } = this.buildRequest(options);
    await this.prepareRequest(req, { url, options });
    debug("request", url, options, req.headers);
    if ((_b = options.signal) == null ? void 0 : _b.aborted) {
      throw new APIUserAbortError();
    }
    const controller = new AbortController();
    const response = await this.fetchWithTimeout(url, req, timeout, controller).catch(castToError);
    if (response instanceof Error) {
      if ((_c = options.signal) == null ? void 0 : _c.aborted) {
        throw new APIUserAbortError();
      }
      if (retriesRemaining) {
        return this.retryRequest(options, retriesRemaining);
      }
      if (response.name === "AbortError") {
        throw new APIConnectionTimeoutError();
      }
      throw new APIConnectionError({ cause: response });
    }
    const responseHeaders = createResponseHeaders(response.headers);
    if (!response.ok) {
      if (retriesRemaining && this.shouldRetry(response)) {
        const retryMessage2 = `retrying, ${retriesRemaining} attempts remaining`;
        debug(`response (error; ${retryMessage2})`, response.status, url, responseHeaders);
        return this.retryRequest(options, retriesRemaining, responseHeaders);
      }
      const errText = await response.text().catch((e) => castToError(e).message);
      const errJSON = safeJSON(errText);
      const errMessage = errJSON ? void 0 : errText;
      const retryMessage = retriesRemaining ? `(error; no more retries left)` : `(error; not retryable)`;
      debug(`response (error; ${retryMessage})`, response.status, url, responseHeaders, errMessage);
      const err = this.makeStatusError(response.status, errJSON, errMessage, responseHeaders);
      throw err;
    }
    return { response, options, controller };
  }
  requestAPIList(Page, options) {
    const request = this.makeRequest(options, null);
    return new PagePromise(this, request, Page);
  }
  buildURL(path, query) {
    const url = isAbsoluteURL(path) ? new URL(path) : new URL(this.baseURL + (this.baseURL.endsWith("/") && path.startsWith("/") ? path.slice(1) : path));
    const defaultQuery = this.defaultQuery();
    if (!isEmptyObj(defaultQuery)) {
      query = { ...defaultQuery, ...query };
    }
    if (typeof query === "object" && query && !Array.isArray(query)) {
      url.search = this.stringifyQuery(query);
    }
    return url.toString();
  }
  stringifyQuery(query) {
    return Object.entries(query).filter(([_, value]) => typeof value !== "undefined").map(([key, value]) => {
      if (typeof value === "string" || typeof value === "number" || typeof value === "boolean") {
        return `${encodeURIComponent(key)}=${encodeURIComponent(value)}`;
      }
      if (value === null) {
        return `${encodeURIComponent(key)}=`;
      }
      throw new GroqError(`Cannot stringify type ${typeof value}; Expected string, number, boolean, or null. If you need to pass nested query parameters, you can manually encode them, e.g. { query: { 'foo[key1]': value1, 'foo[key2]': value2 } }, and please open a GitHub issue requesting better support for your use case.`);
    }).join("&");
  }
  async fetchWithTimeout(url, init, ms, controller) {
    const { signal, ...options } = init || {};
    if (signal)
      signal.addEventListener("abort", () => controller.abort());
    const timeout = setTimeout(() => controller.abort(), ms);
    return this.getRequestClient().fetch.call(void 0, url, { signal: controller.signal, ...options }).finally(() => {
      clearTimeout(timeout);
    });
  }
  getRequestClient() {
    return { fetch: this.fetch };
  }
  shouldRetry(response) {
    const shouldRetryHeader = response.headers.get("x-should-retry");
    if (shouldRetryHeader === "true")
      return true;
    if (shouldRetryHeader === "false")
      return false;
    if (response.status === 408)
      return true;
    if (response.status === 409)
      return true;
    if (response.status === 429)
      return true;
    if (response.status >= 500)
      return true;
    return false;
  }
  async retryRequest(options, retriesRemaining, responseHeaders) {
    var _a2;
    let timeoutMillis;
    const retryAfterMillisHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after-ms"];
    if (retryAfterMillisHeader) {
      const timeoutMs = parseFloat(retryAfterMillisHeader);
      if (!Number.isNaN(timeoutMs)) {
        timeoutMillis = timeoutMs;
      }
    }
    const retryAfterHeader = responseHeaders == null ? void 0 : responseHeaders["retry-after"];
    if (retryAfterHeader && !timeoutMillis) {
      const timeoutSeconds = parseFloat(retryAfterHeader);
      if (!Number.isNaN(timeoutSeconds)) {
        timeoutMillis = timeoutSeconds * 1e3;
      } else {
        timeoutMillis = Date.parse(retryAfterHeader) - Date.now();
      }
    }
    if (!(timeoutMillis && 0 <= timeoutMillis && timeoutMillis < 60 * 1e3)) {
      const maxRetries = (_a2 = options.maxRetries) != null ? _a2 : this.maxRetries;
      timeoutMillis = this.calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries);
    }
    await sleep(timeoutMillis);
    return this.makeRequest(options, retriesRemaining - 1);
  }
  calculateDefaultRetryTimeoutMillis(retriesRemaining, maxRetries) {
    const initialRetryDelay = 0.5;
    const maxRetryDelay = 8;
    const numRetries = maxRetries - retriesRemaining;
    const sleepSeconds = Math.min(initialRetryDelay * Math.pow(2, numRetries), maxRetryDelay);
    const jitter = 1 - Math.random() * 0.25;
    return sleepSeconds * jitter * 1e3;
  }
  getUserAgent() {
    return `${this.constructor.name}/JS ${VERSION}`;
  }
};
var AbstractPage = class {
  constructor(client, response, body, options) {
    _AbstractPage_client.set(this, void 0);
    __classPrivateFieldSet(this, _AbstractPage_client, client, "f");
    this.options = options;
    this.response = response;
    this.body = body;
  }
  hasNextPage() {
    const items = this.getPaginatedItems();
    if (!items.length)
      return false;
    return this.nextPageInfo() != null;
  }
  async getNextPage() {
    const nextInfo = this.nextPageInfo();
    if (!nextInfo) {
      throw new GroqError("No next page expected; please check `.hasNextPage()` before calling `.getNextPage()`.");
    }
    const nextOptions = { ...this.options };
    if ("params" in nextInfo && typeof nextOptions.query === "object") {
      nextOptions.query = { ...nextOptions.query, ...nextInfo.params };
    } else if ("url" in nextInfo) {
      const params = [...Object.entries(nextOptions.query || {}), ...nextInfo.url.searchParams.entries()];
      for (const [key, value] of params) {
        nextInfo.url.searchParams.set(key, value);
      }
      nextOptions.query = void 0;
      nextOptions.path = nextInfo.url.toString();
    }
    return await __classPrivateFieldGet(this, _AbstractPage_client, "f").requestAPIList(this.constructor, nextOptions);
  }
  async *iterPages() {
    let page = this;
    yield page;
    while (page.hasNextPage()) {
      page = await page.getNextPage();
      yield page;
    }
  }
  async *[(_AbstractPage_client = /* @__PURE__ */ new WeakMap(), Symbol.asyncIterator)]() {
    for await (const page of this.iterPages()) {
      for (const item of page.getPaginatedItems()) {
        yield item;
      }
    }
  }
};
var PagePromise = class extends APIPromise {
  constructor(client, request, Page) {
    super(request, async (props) => new Page(client, props.response, await defaultParseResponse(props), props.options));
  }
  /**
   * Allow auto-paginating iteration on an unawaited list call, eg:
   *
   *    for await (const item of client.items.list()) {
   *      console.log(item)
   *    }
   */
  async *[Symbol.asyncIterator]() {
    const page = await this;
    for await (const item of page) {
      yield item;
    }
  }
};
var createResponseHeaders = (headers) => {
  return new Proxy(Object.fromEntries(
    // @ts-ignore
    headers.entries()
  ), {
    get(target, name) {
      const key = name.toString();
      return target[key.toLowerCase()] || target[key];
    }
  });
};
var getPlatformProperties = () => {
  if (typeof Deno !== "undefined" && Deno.build != null) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(Deno.build.os),
      "X-Stainless-Arch": normalizeArch(Deno.build.arch),
      "X-Stainless-Runtime": "deno",
      "X-Stainless-Runtime-Version": Deno.version
    };
  }
  if (typeof EdgeRuntime !== "undefined") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": `other:${EdgeRuntime}`,
      "X-Stainless-Runtime": "edge",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  if (Object.prototype.toString.call(typeof process !== "undefined" ? process : 0) === "[object process]") {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": normalizePlatform(process.platform),
      "X-Stainless-Arch": normalizeArch(process.arch),
      "X-Stainless-Runtime": "node",
      "X-Stainless-Runtime-Version": process.version
    };
  }
  const browserInfo = getBrowserInfo();
  if (browserInfo) {
    return {
      "X-Stainless-Lang": "js",
      "X-Stainless-Package-Version": VERSION,
      "X-Stainless-OS": "Unknown",
      "X-Stainless-Arch": "unknown",
      "X-Stainless-Runtime": `browser:${browserInfo.browser}`,
      "X-Stainless-Runtime-Version": browserInfo.version
    };
  }
  return {
    "X-Stainless-Lang": "js",
    "X-Stainless-Package-Version": VERSION,
    "X-Stainless-OS": "Unknown",
    "X-Stainless-Arch": "unknown",
    "X-Stainless-Runtime": "unknown",
    "X-Stainless-Runtime-Version": "unknown"
  };
};
function getBrowserInfo() {
  if (typeof navigator === "undefined" || !navigator) {
    return null;
  }
  const browserPatterns = [
    { key: "edge", pattern: /Edge(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /MSIE(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "ie", pattern: /Trident(?:.*rv\:(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "chrome", pattern: /Chrome(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "firefox", pattern: /Firefox(?:\W+(\d+)\.(\d+)(?:\.(\d+))?)?/ },
    { key: "safari", pattern: /(?:Version\W+(\d+)\.(\d+)(?:\.(\d+))?)?(?:\W+Mobile\S*)?\W+Safari/ }
  ];
  for (const { key, pattern } of browserPatterns) {
    const match = pattern.exec(navigator.userAgent);
    if (match) {
      const major = match[1] || 0;
      const minor = match[2] || 0;
      const patch = match[3] || 0;
      return { browser: key, version: `${major}.${minor}.${patch}` };
    }
  }
  return null;
}
var normalizeArch = (arch) => {
  if (arch === "x32")
    return "x32";
  if (arch === "x86_64" || arch === "x64")
    return "x64";
  if (arch === "arm")
    return "arm";
  if (arch === "aarch64" || arch === "arm64")
    return "arm64";
  if (arch)
    return `other:${arch}`;
  return "unknown";
};
var normalizePlatform = (platform) => {
  platform = platform.toLowerCase();
  if (platform.includes("ios"))
    return "iOS";
  if (platform === "android")
    return "Android";
  if (platform === "darwin")
    return "MacOS";
  if (platform === "win32")
    return "Windows";
  if (platform === "freebsd")
    return "FreeBSD";
  if (platform === "openbsd")
    return "OpenBSD";
  if (platform === "linux")
    return "Linux";
  if (platform)
    return `Other:${platform}`;
  return "Unknown";
};
var _platformHeaders;
var getPlatformHeaders = () => {
  return _platformHeaders != null ? _platformHeaders : _platformHeaders = getPlatformProperties();
};
var safeJSON = (text) => {
  try {
    return JSON.parse(text);
  } catch (err) {
    return void 0;
  }
};
var startsWithSchemeRegexp = new RegExp("^(?:[a-z]+:)?//", "i");
var isAbsoluteURL = (url) => {
  return startsWithSchemeRegexp.test(url);
};
var sleep = (ms) => new Promise((resolve) => setTimeout(resolve, ms));
var validatePositiveInteger = (name, n) => {
  if (typeof n !== "number" || !Number.isInteger(n)) {
    throw new GroqError(`${name} must be an integer`);
  }
  if (n < 0) {
    throw new GroqError(`${name} must be a positive integer`);
  }
  return n;
};
var castToError = (err) => {
  if (err instanceof Error)
    return err;
  return new Error(err);
};
var readEnv = (env) => {
  var _a2, _b, _c, _d, _e, _f;
  if (typeof process !== "undefined") {
    return (_c = (_b = (_a2 = process.env) == null ? void 0 : _a2[env]) == null ? void 0 : _b.trim()) != null ? _c : void 0;
  }
  if (typeof Deno !== "undefined") {
    return (_f = (_e = (_d = Deno.env) == null ? void 0 : _d.get) == null ? void 0 : _e.call(_d, env)) == null ? void 0 : _f.trim();
  }
  return void 0;
};
function isEmptyObj(obj) {
  if (!obj)
    return true;
  for (const _k in obj)
    return false;
  return true;
}
function hasOwn(obj, key) {
  return Object.prototype.hasOwnProperty.call(obj, key);
}
function applyHeadersMut(targetHeaders, newHeaders) {
  for (const k in newHeaders) {
    if (!hasOwn(newHeaders, k))
      continue;
    const lowerKey = k.toLowerCase();
    if (!lowerKey)
      continue;
    const val = newHeaders[k];
    if (val === null) {
      delete targetHeaders[lowerKey];
    } else if (val !== void 0) {
      targetHeaders[lowerKey] = val;
    }
  }
}
function debug(action, ...args) {
  if (typeof process !== "undefined" && process.env["DEBUG"] === "true") {
    console.log(`Groq:DEBUG:${action}`, ...args);
  }
}
var uuid4 = () => {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0;
    const v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
};
var isRunningInBrowser = () => {
  return (
    // @ts-ignore
    typeof window !== "undefined" && // @ts-ignore
    typeof window.document !== "undefined" && // @ts-ignore
    typeof navigator !== "undefined"
  );
};

// node_modules/groq-sdk/resource.mjs
var APIResource = class {
  constructor(client) {
    this._client = client;
  }
};

// node_modules/groq-sdk/resources/chat/completions.mjs
var Completions = class extends APIResource {
  create(body, options) {
    var _a2;
    return this._client.post("/openai/v1/chat/completions", { body, ...options, stream: (_a2 = body.stream) != null ? _a2 : false });
  }
};
(function(Completions2) {
})(Completions || (Completions = {}));

// node_modules/groq-sdk/resources/chat/chat.mjs
var Chat = class extends APIResource {
  constructor() {
    super(...arguments);
    this.completions = new Completions(this._client);
  }
};
(function(Chat2) {
  Chat2.Completions = Completions;
})(Chat || (Chat = {}));

// node_modules/groq-sdk/resources/models.mjs
var Models = class extends APIResource {
  /**
   * Get a specific model
   */
  retrieve(model, options) {
    return this._client.get(`/openai/v1/models/${model}`, options);
  }
  /**
   * get all available models
   */
  list(options) {
    return this._client.get("/openai/v1/models", options);
  }
  /**
   * Delete a model
   */
  delete(model, options) {
    return this._client.delete(`/openai/v1/models/${model}`, {
      ...options,
      headers: { Accept: "*/*", ...options == null ? void 0 : options.headers }
    });
  }
};
(function(Models2) {
})(Models || (Models = {}));

// node_modules/groq-sdk/resources/audio/transcriptions.mjs
var Transcriptions = class extends APIResource {
  /**
   * Transcribes audio into the input language.
   */
  create(body, options) {
    return this._client.post("/openai/v1/audio/transcriptions", multipartFormRequestOptions({ body, ...options }));
  }
};
(function(Transcriptions2) {
})(Transcriptions || (Transcriptions = {}));

// node_modules/groq-sdk/resources/audio/translations.mjs
var Translations = class extends APIResource {
  /**
   * Translates audio into English.
   */
  create(body, options) {
    return this._client.post("/openai/v1/audio/translations", multipartFormRequestOptions({ body, ...options }));
  }
};
(function(Translations2) {
})(Translations || (Translations = {}));

// node_modules/groq-sdk/resources/audio/audio.mjs
var Audio = class extends APIResource {
  constructor() {
    super(...arguments);
    this.transcriptions = new Transcriptions(this._client);
    this.translations = new Translations(this._client);
  }
};
(function(Audio2) {
  Audio2.Transcriptions = Transcriptions;
  Audio2.Translations = Translations;
})(Audio || (Audio = {}));

// node_modules/groq-sdk/index.mjs
var _a;
var Groq = class extends APIClient {
  /**
   * API Client for interfacing with the Groq API.
   *
   * @param {string | undefined} [opts.apiKey=process.env['GROQ_API_KEY'] ?? undefined]
   * @param {string} [opts.baseURL=process.env['GROQ_BASE_URL'] ?? https://api.groq.com] - Override the default base URL for the API.
   * @param {number} [opts.timeout=1 minute] - The maximum amount of time (in milliseconds) the client will wait for a response before timing out.
   * @param {number} [opts.httpAgent] - An HTTP agent used to manage HTTP(s) connections.
   * @param {Core.Fetch} [opts.fetch] - Specify a custom `fetch` function implementation.
   * @param {number} [opts.maxRetries=2] - The maximum number of times the client will retry a request.
   * @param {Core.Headers} opts.defaultHeaders - Default headers to include with every request to the API.
   * @param {Core.DefaultQuery} opts.defaultQuery - Default query parameters to include with every request to the API.
   * @param {boolean} [opts.dangerouslyAllowBrowser=false] - By default, client-side use of this library is not allowed, as it risks exposing your secret API credentials to attackers.
   */
  constructor({ baseURL = readEnv("GROQ_BASE_URL"), apiKey = readEnv("GROQ_API_KEY"), ...opts } = {}) {
    var _a2;
    if (apiKey === void 0) {
      throw new GroqError("The GROQ_API_KEY environment variable is missing or empty; either provide it, or instantiate the Groq client with an apiKey option, like new Groq({ apiKey: 'My API Key' }).");
    }
    const options = {
      apiKey,
      ...opts,
      baseURL: baseURL || `https://api.groq.com`
    };
    if (!options.dangerouslyAllowBrowser && isRunningInBrowser()) {
      throw new GroqError("This is disabled by default, as it risks exposing your secret API credentials to attackers.\nIf you understand the risks and have appropriate mitigations in place,\nyou can set the `dangerouslyAllowBrowser` option to `true`, e.g.,\n\nnew Groq({ dangerouslyAllowBrowser: true })");
    }
    super({
      baseURL: options.baseURL,
      timeout: (_a2 = options.timeout) != null ? _a2 : 6e4,
      httpAgent: options.httpAgent,
      maxRetries: options.maxRetries,
      fetch: options.fetch
    });
    this.chat = new Chat(this);
    this.audio = new Audio(this);
    this.models = new Models(this);
    this._options = options;
    this.apiKey = apiKey;
  }
  defaultQuery() {
    return this._options.defaultQuery;
  }
  defaultHeaders(opts) {
    return {
      ...super.defaultHeaders(opts),
      ...this._options.defaultHeaders
    };
  }
  authHeaders(opts) {
    return { Authorization: `Bearer ${this.apiKey}` };
  }
};
_a = Groq;
Groq.Groq = _a;
Groq.GroqError = GroqError;
Groq.APIError = APIError;
Groq.APIConnectionError = APIConnectionError;
Groq.APIConnectionTimeoutError = APIConnectionTimeoutError;
Groq.APIUserAbortError = APIUserAbortError;
Groq.NotFoundError = NotFoundError;
Groq.ConflictError = ConflictError;
Groq.RateLimitError = RateLimitError;
Groq.BadRequestError = BadRequestError;
Groq.AuthenticationError = AuthenticationError;
Groq.InternalServerError = InternalServerError;
Groq.PermissionDeniedError = PermissionDeniedError;
Groq.UnprocessableEntityError = UnprocessableEntityError;
var { GroqError: GroqError2, APIError: APIError2, APIConnectionError: APIConnectionError2, APIConnectionTimeoutError: APIConnectionTimeoutError2, APIUserAbortError: APIUserAbortError2, NotFoundError: NotFoundError2, ConflictError: ConflictError2, RateLimitError: RateLimitError2, BadRequestError: BadRequestError2, AuthenticationError: AuthenticationError2, InternalServerError: InternalServerError2, PermissionDeniedError: PermissionDeniedError2, UnprocessableEntityError: UnprocessableEntityError2 } = error_exports;
(function(Groq2) {
  Groq2.toFile = toFile;
  Groq2.fileFromPath = fileFromPath;
  Groq2.Chat = Chat;
  Groq2.Audio = Audio;
  Groq2.Models = Models;
})(Groq || (Groq = {}));
var groq_sdk_default = Groq;

// node_modules/monkey-around/dist/index.mjs
function around(obj, factories) {
  const removers = Object.keys(factories).map((key) => around1(obj, key, factories[key]));
  return removers.length === 1 ? removers[0] : function() {
    removers.forEach((r) => r());
  };
}
function around1(obj, method, createWrapper) {
  const inherited = obj[method], hadOwn = obj.hasOwnProperty(method), original = hadOwn ? inherited : function() {
    return Object.getPrototypeOf(obj)[method].apply(this, arguments);
  };
  let current = createWrapper(original);
  if (inherited)
    Object.setPrototypeOf(current, inherited);
  Object.setPrototypeOf(wrapper, current);
  obj[method] = wrapper;
  return remove;
  function wrapper(...args) {
    if (current === original && obj[method] === wrapper)
      remove();
    return current.apply(this, args);
  }
  function remove() {
    if (obj[method] === wrapper) {
      if (hadOwn)
        obj[method] = original;
      else
        delete obj[method];
    }
    if (current === original)
      return;
    current = original;
    Object.setPrototypeOf(wrapper, inherited || Function);
  }
}

// main.ts
var import_obsidian = require("obsidian");
var import_state = require("@codemirror/state");
var import_view = require("@codemirror/view");
var dotenv = __toESM(require_main());
var basePath = "/Users/jacobcolling/Documents/accelerate/accelerate/";
dotenv.config({
  path: `${basePath}/.obsidian/plugins/caret/.env`,
  debug: true
});
var groq_api_key = process.env.GROQ_API_KEY;
var groq = new groq_sdk_default({ apiKey: groq_api_key, dangerouslyAllowBrowser: true });
var CMDJModal = class extends import_obsidian.Modal {
  constructor(app, selectedText, startIndex, endIndex) {
    super(app);
    this.selectedText = selectedText;
    this.startIndex = startIndex;
    this.endIndex = endIndex;
  }
  onOpen() {
    const { contentEl } = this;
    const textDisplay = contentEl.createEl("div", {
      text: this.selectedText
    });
    textDisplay.style.height = "60px";
    textDisplay.style.overflow = "scroll";
    contentEl.createEl("br");
    const textArea = contentEl.createEl("textarea", {
      placeholder: "Type here..."
    });
    textArea.style.width = "100%";
    textArea.style.minHeight = "100px";
    textArea.style.resize = "none";
    textArea.oninput = () => {
      textArea.style.height = "";
      textArea.style.height = `${textArea.scrollHeight}px`;
    };
    const buttonContainer = contentEl.createEl("div", { cls: "button-container" });
    new import_obsidian.Setting(buttonContainer).addButton(
      (btn) => btn.setButtonText("Append Output").onClick(async () => {
        this.result = textArea.value;
        const content = await this.submit_edit(this.result);
        this.insert_response(content);
        this.close();
      })
    ).addButton(
      (btn) => btn.setButtonText("Replace").setCta().onClick(async () => {
        this.result = textArea.value;
        const content = await this.submit_edit(this.result);
        this.apply_delete(this.result);
        this.insert_response(content, true);
        this.close();
      })
    );
  }
  async submit_edit(result) {
    let message = `
Please apply the following instructions to the below content:

Instructions:
${this.result}

Content:
${this.selectedText}

## Rules:
- Just return the reponse that follows the instructions. No need to include a preample or anything

## Markdown Formatting: 
Always apply markdown formatting. For keywords use the following:
	todos - Prepend todo lines with:
	- [ ] 
`.trim();
    const data = { message };
    const resp = await fetch("http://localhost:8000/single-turn", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(data)
    });
    const output = await resp.json();
    return output.content;
  }
  insert_response(response, replace = false) {
    var _a2;
    const editor = (_a2 = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView)) == null ? void 0 : _a2.editor;
    if (editor) {
      let index = this.endIndex;
      if (replace) {
        index = index + 4;
      }
      const pos = editor.offsetToPos(index);
      editor.replaceRange(`
|+${response}+|`, pos);
      editor.setCursor(pos);
      editor.focus();
    }
  }
  apply_delete(text) {
    var _a2;
    const editor = (_a2 = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView)) == null ? void 0 : _a2.editor;
    if (editor) {
      const content = editor.getValue();
      const index = content.indexOf(this.selectedText);
      if (index !== -1) {
        const beforeText = content.substring(0, index);
        const afterText = content.substring(index + this.selectedText.length);
        const newText = beforeText + `|-${this.selectedText}-|` + afterText;
        editor.setValue(newText);
      }
    }
  }
  onClose() {
    let { contentEl } = this;
    contentEl.empty();
  }
};
var redBackgroundField = import_state.StateField.define({
  create(state) {
    return import_view.Decoration.none;
  },
  update(oldState, transaction) {
    const builder = new import_state.RangeSetBuilder();
    const docText = transaction.state.doc.toString();
    const delete_regex = /\|-(.*?)-\|/gs;
    const add_regex = /\|\+(.*?)\+\|/gs;
    let delete_match;
    let add_match;
    let ranges = [];
    while ((delete_match = delete_regex.exec(docText)) !== null) {
      const start = delete_match.index;
      const end = delete_regex.lastIndex;
      ranges.push({ start, end, style: "background-color: #f56c62;" });
    }
    while ((add_match = add_regex.exec(docText)) !== null) {
      const start = add_match.index;
      const end = add_regex.lastIndex;
      ranges.push({ start, end, style: "background-color: #64f562;" });
    }
    ranges.sort((a, b) => a.start - b.start);
    ranges.forEach((range) => {
      builder.add(
        range.start,
        range.end,
        import_view.Decoration.mark({
          attributes: { style: range.style }
        })
      );
    });
    return builder.finish();
  },
  provide(field) {
    return import_view.EditorView.decorations.from(field);
  }
});
var DEFAULT_SETTINGS = {
  mySetting: "default"
};
var VIEW_NAME_SIDEBAR_CHAT = "sidebar-caret";
var SidebarChat = class extends import_obsidian.ItemView {
  constructor(leaf) {
    super(leaf);
  }
  // Container for messages
  getViewType() {
    return VIEW_NAME_SIDEBAR_CHAT;
  }
  getDisplayText() {
    return VIEW_NAME_SIDEBAR_CHAT;
  }
  async onOpen() {
    const metacontainer = this.containerEl.children[1];
    metacontainer.empty();
    const container = metacontainer.createEl("div", {
      cls: "container"
    });
    metacontainer.prepend(container);
    this.messagesContainer = container.createEl("div", {
      cls: "messages-container"
    });
    this.addMessage("MLX Testing", "system");
    this.createChatInputArea(container);
  }
  createChatInputArea(container) {
    const inputContainer = container.createEl("div", {
      cls: "chat-input-container"
    });
    this.textBox = inputContainer.createEl("textarea", {
      cls: "full_width_text_container"
    });
    this.textBox.placeholder = "Type something...";
    const button = inputContainer.createEl("button");
    button.textContent = "Submit";
    button.addEventListener("click", () => {
      this.submitMessage(this.textBox.value);
      this.textBox.value = "";
    });
  }
  addMessage(text, sender) {
    const messageDiv = this.messagesContainer.createEl("div", {
      cls: `message ${sender}`
    });
    messageDiv.textContent = text;
  }
  submitMessage(userMessage) {
    var _a2;
    let current_page_content = "";
    if (userMessage.includes("@current")) {
      const markdownView = (_a2 = this.app.workspace.getLeavesOfType("markdown").find((leaf) => leaf.view instanceof import_obsidian.MarkdownView && leaf.width > 0)) == null ? void 0 : _a2.view;
      if (markdownView && markdownView.editor) {
        current_page_content = markdownView.editor.getValue();
      }
    }
    this.addMessage(userMessage, "user");
    const current_page_message = `
		${userMessage}

		------ Note for Model --- 
		When I am referring to @current, I meant the following:

		${current_page_content}
		`;
    let final_message = userMessage;
    if (current_page_content.length > 0) {
      final_message = current_page_message;
    }
    const data = { message: final_message };
    fetch("http://localhost:8000/conversation", {
      method: "POST",
      headers: {
        "Content-Type": "application/json"
      },
      body: JSON.stringify(data)
    }).then((response) => response.json()).then((data2) => {
      this.addMessage(data2.response, "system");
    }).catch((error) => {
      console.error("Error:", error);
    });
  }
  async onClose() {
  }
};
var VIEW_NAME_MAIN_CHAT = "main-caret";
var MainChat = class extends import_obsidian.ItemView {
  constructor(leaf, chat_id, conversation = []) {
    super(leaf);
    this.chat_id = chat_id || this.generateRandomID(5);
    this.conversation = conversation;
  }
  // List to store conversation messages
  getViewType() {
    return VIEW_NAME_MAIN_CHAT;
  }
  getDisplayText() {
    return `MLX Local Chat: ${this.chat_id}`;
  }
  async onOpen() {
    const metacontainer = this.containerEl.children[1];
    metacontainer.empty();
    const container = metacontainer.createEl("div", {
      cls: "container"
    });
    metacontainer.prepend(container);
    this.messagesContainer = container.createEl("div", {
      cls: "messages-container"
    });
    this.renderConversation();
    this.createChatInputArea(container);
  }
  createChatInputArea(container) {
    const inputContainer = container.createEl("div", {});
    this.textBox = inputContainer.createEl("textarea", {
      cls: "full_width_text_container"
    });
    this.textBox.placeholder = "Type something...";
    const buttonContainer = inputContainer.createEl("div", {
      cls: "button-container"
    });
    const saveButton = buttonContainer.createEl("button");
    saveButton.textContent = "Save Chat";
    saveButton.addEventListener("click", () => {
      this.saveChat();
    });
    const submitButton = buttonContainer.createEl("button");
    submitButton.textContent = "Submit";
    submitButton.addEventListener("click", () => {
      this.submitMessage(this.textBox.value);
      this.textBox.value = "";
    });
  }
  addMessage(text, sender) {
    this.conversation.push({ content: text, role: sender });
    this.renderConversation();
  }
  renderConversation() {
    this.messagesContainer.empty();
    this.conversation.forEach((message) => {
      const messageDiv = this.messagesContainer.createEl("div", {
        cls: `message ${message.role}`
      });
      messageDiv.textContent = message.content;
    });
  }
  async submitMessage(userMessage) {
    this.addMessage(userMessage, "user");
    const data = {
      conversation: this.conversation
    };
    try {
      const response = await fetch("http://localhost:8000/conversation", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(data)
      });
      const output = await response.json();
      this.addMessage(output.response, "system");
    } catch (error) {
      console.error("Error:", error);
    }
  }
  async saveChat() {
    const chat_folder_path = "chats/";
    const file_name = `${this.chat_id}.md`;
    const file_path = chat_folder_path + file_name;
    let file_content = `\`\`\`xml
		<metadata>
<id>${this.chat_id}</id>
</metadata>
		`;
    let messages = ``;
    this.conversation.forEach((message) => {
      const message_xml = `
			<message>
				<role>${message.role}</role>
				<content>${message.content}</content>
			</message>
			`.trim();
      messages += message_xml;
    });
    let conversation = `<conversation>
${messages}</conversation>\`\`\``;
    file_content += conversation;
    const file = await this.app.vault.getFileByPath(file_path);
    try {
      if (file) {
        await this.app.vault.modify(file, file_content);
      } else {
        await this.app.vault.create(file_path, file_content);
      }
    } catch (error) {
      console.error("Failed to save chat:", error);
    }
  }
  generateRandomID(length) {
    const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
    let result = "";
    for (let i = 0; i < length; i++) {
      result += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    return result;
  }
  async onClose() {
  }
};
var MyPlugin = class extends import_obsidian.Plugin {
  constructor() {
    super(...arguments);
    this.childNode = async (canvas, parentNode, x, y, content = "", from_side = "right", to_side = "left", origin = "ignore") => {
      var _a2;
      let tempChildNode = this.addNode(canvas, this.random(16), {
        x,
        y,
        width: parentNode.width,
        height: parentNode.height,
        type: "text",
        content
      });
      await this.createEdge(parentNode, tempChildNode, canvas, from_side, to_side);
      const node = (_a2 = canvas.nodes) == null ? void 0 : _a2.get(tempChildNode == null ? void 0 : tempChildNode.id);
      if (!node)
        return;
      if (origin === "groq") {
        new import_obsidian.Notice("Message back from Groq");
      }
      canvas.requestSave();
      return tempChildNode;
    };
    this.addNode = (canvas, id, {
      x,
      y,
      width,
      height,
      type,
      content,
      subpath
    }) => {
      if (!canvas)
        return;
      const data = canvas.getData();
      if (!data)
        return;
      const node = {
        id,
        x,
        y,
        width,
        height,
        type
      };
      switch (type) {
        case "text":
          node.text = content;
          break;
        case "file":
          node.file = content;
          if (subpath)
            node.subpath = subpath;
          break;
      }
      canvas.importData({
        nodes: [...data.nodes, node],
        edges: data.edges
      });
      canvas.requestFrame();
      return node;
    };
    this.createEdge = async (node1, node2, canvas, from_side = "right", to_side = "left") => {
      this.addEdge(
        canvas,
        this.random(16),
        {
          fromOrTo: "from",
          side: from_side,
          node: node1
        },
        {
          fromOrTo: "to",
          side: to_side,
          node: node2
        }
      );
    };
    // TODO - Change this
    this.random = (e) => {
      let t = [];
      for (let n = 0; n < e; n++) {
        t.push((16 * Math.random() | 0).toString(16));
      }
      return t.join("");
    };
    this.addEdge = (canvas, edgeID, fromEdge, toEdge) => {
      if (!canvas)
        return;
      const data = canvas.getData();
      if (!data)
        return;
      canvas.importData({
        edges: [
          ...data.edges,
          {
            id: edgeID,
            fromNode: fromEdge.node.id,
            fromSide: fromEdge.side,
            toNode: toEdge.node.id,
            toSide: toEdge.side
          }
        ],
        nodes: data.nodes
      });
      canvas.requestFrame();
    };
  }
  async onload() {
    this.addCommand({
      id: "patch-menu",
      name: "Patch Menu",
      callback: async () => {
        this.patchCanvasMenu();
      }
    });
    this.registerEvent(
      this.app.workspace.on("active-leaf-change", () => {
        console.log("Leaf changed");
        const currentLeaf = this.app.workspace.activeLeaf;
        if ((currentLeaf == null ? void 0 : currentLeaf.view.getViewType()) === "canvas") {
          console.log("Leaf is canvas!");
          this.patchCanvasMenu();
        }
      })
    );
    await this.loadSettings();
    this.registerEditorExtension([redBackgroundField]);
    this.addSidebarTab();
    this.addCommand({
      id: "log",
      name: "Log",
      callback: async () => {
        const currentLeaf = this.app.workspace.activeLeaf;
        if ((currentLeaf == null ? void 0 : currentLeaf.view.getViewType()) === "canvas") {
          const canvasView = currentLeaf.view;
          const canvas = canvasView.canvas;
          console.log(canvas);
          console.log(canvas.nodeIndex.data.children);
          const viewportNodes = canvas.getViewportNodes();
          console.log(viewportNodes);
        }
      }
    });
    this.addCommand({
      id: "canvas-prompt",
      name: "Canvas Prompt",
      callback: async () => {
        const currentLeaf = this.app.workspace.activeLeaf;
        if ((currentLeaf == null ? void 0 : currentLeaf.view.getViewType()) === "canvas") {
          const canvasView = currentLeaf.view;
          const canvas = canvasView.canvas;
          const selection = canvas.selection;
          let average_y = 0;
          let average_height = 0;
          let average_width = 0;
          let max_x = 0;
          let total_y = 0;
          let count = 0;
          let total_height = 0;
          let total_width = 0;
          let all_text = "";
          for (const obj of selection) {
            const { x, y, height, width } = obj;
            max_x = Math.max(max_x, x);
            total_y += y;
            total_height += height;
            total_width += width;
            count++;
            if ("text" in obj) {
              const { text } = obj;
              all_text += text + "\n";
            } else if ("filePath" in obj) {
              let { filePath } = obj;
              const file = await this.app.vault.getFileByPath(filePath);
              if (file) {
                const text = await this.app.vault.read(file);
                const file_text = `
                                Title: ${filePath.replace(".md", "")}
                                ${text}
                                `.trim();
                all_text += file_text;
              }
            }
          }
          average_y = count > 0 ? total_y / count : 0;
          average_height = count > 0 ? total_height / count : 0;
          average_width = count > 0 ? total_width / count : 0;
          const modal = new import_obsidian.Modal(this.app);
          modal.contentEl.createEl("h1", { text: "Canvas Prompt" });
          const container = modal.contentEl.createDiv({ cls: "flex-col" });
          const textArea = container.createEl("textarea", {
            placeholder: "",
            cls: "w-full mb-2"
          });
          const submitButton = container.createEl("button", { text: "Submit" });
          submitButton.onclick = async () => {
            modal.close();
            const prompt = `
                        Please do the following:
                        ${textArea.value}

                        Given this content:
                        ${all_text}
                        `;
            const content = await one_shot(prompt);
            const textNodeConfig = {
              pos: { x: max_x + 50, y: average_y },
              // Position on the canvas
              size: { width: average_width, height: average_height },
              // Size of the text box
              position: "center",
              // This might relate to text alignment
              text: content,
              // Text content from input
              save: true,
              // Save this node's state
              focus: true
              // Focus and start editing immediately
            };
            const node = canvas.createTextNode(textNodeConfig);
            const node_id = node.id;
            node.color = "6";
            node.zoomToSelection();
          };
          modal.open();
        }
      }
    });
    this.addCommand({
      id: "create-child",
      name: "Create Child",
      callback: async () => {
        const currentLeaf = this.app.workspace.activeLeaf;
        if ((currentLeaf == null ? void 0 : currentLeaf.view.getViewType()) === "canvas") {
          const canvasView = currentLeaf.view;
          const canvas = canvasView.canvas;
          const selection = canvas.selection;
          const selectionIterator = selection.values();
          const node = selectionIterator.next().value;
          childNode(canvas, node, node.y);
        }
      }
    });
    this.addCommand({
      id: "open-cmdj-modal",
      name: "Open CMD+J Modal",
      hotkeys: [{ modifiers: ["Mod"], key: "j" }],
      callback: () => {
        const activeView = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView);
        if (activeView && activeView.editor) {
          const selectedText = activeView.editor.getSelection();
          const content = activeView.editor.getValue();
          const startIndex = content.indexOf(selectedText);
          const endIndex = startIndex + selectedText.length;
          new CMDJModal(this.app, selectedText, startIndex, endIndex).open();
        } else {
          new import_obsidian.Notice("No active markdown editor or no text selected.");
        }
      }
    });
    this.registerView(VIEW_NAME_SIDEBAR_CHAT, (leaf) => new SidebarChat(leaf));
    this.registerView(VIEW_NAME_MAIN_CHAT, (leaf) => new MainChat(leaf));
    this.addCommand({
      id: "insert-text-into-sidebar",
      name: "Insert Text into Sidebar",
      hotkeys: [{ modifiers: ["Mod"], key: "l" }],
      callback: () => {
        const activeLeaf = this.app.workspace.activeLeaf;
        if (activeLeaf) {
          const editor = activeLeaf.view instanceof import_obsidian.MarkdownView ? activeLeaf.view.editor : null;
          if (editor) {
            const selectedText = editor.getSelection();
            this.insertTextIntoSidebar(selectedText);
          }
        }
      }
    });
    this.addCommand({
      id: "clear-text-in-sidebar",
      name: "Clear Text in Sidebar",
      hotkeys: [{ modifiers: ["Mod"], key: ";" }],
      callback: () => {
        this.clearTextInSidebar();
      }
    });
    async function one_shot(message) {
      const data = { message };
      const resp = await fetch("http://localhost:8000/single-turn", {
        method: "POST",
        headers: {
          "Content-Type": "application/json"
        },
        body: JSON.stringify(data)
      });
      const output = await resp.json();
      return output.content;
    }
    function parseCustomXML(xmlString) {
      function getContent(tag, string) {
        const openTag = `<${tag}>`;
        const closeTag = `</${tag}>`;
        const start = string.indexOf(openTag) + openTag.length;
        const end = string.indexOf(closeTag);
        return string.substring(start, end).trim();
      }
      const conversationId = getContent("id", xmlString);
      const result = {
        metadata: {
          id: conversationId
        },
        conversation: {
          messages: []
        }
      };
      const messagesContent = getContent("conversation", xmlString);
      const messageTags = messagesContent.split("</message>").slice(0, -1);
      for (const messageTag of messageTags) {
        const role = getContent("role", messageTag);
        const content = getContent("content", messageTag);
        result.conversation.messages.push({ role, content });
      }
      return result;
    }
    this.addCommand({
      id: "open-chat",
      name: "Open Chat",
      callback: async () => {
        var _a2;
        const editor = (_a2 = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView)) == null ? void 0 : _a2.editor;
        if (editor) {
          let content = editor.getValue();
          content = content.replace("```xml", "").trim();
          content = content.replace("```", "").trim();
          const xml = parseCustomXML(content);
          const convo_id = xml.metadata.id;
          const messages = xml.conversation.messages;
          if (convo_id && messages) {
            const leaf = this.app.workspace.getLeaf(true);
            const chatView = new MainChat(leaf, convo_id, messages);
            leaf.open(chatView);
            this.app.workspace.revealLeaf(leaf);
          } else {
            new import_obsidian.Notice("No valid chat data found in the current document.");
          }
        } else {
          new import_obsidian.Notice("No active markdown editor found.");
        }
      }
    });
    this.addCommand({
      id: "apply-diffs",
      name: "Apply Diffs",
      hotkeys: [{ modifiers: ["Mod"], key: "d" }],
      callback: () => {
        var _a2;
        const editor = (_a2 = this.app.workspace.getActiveViewOfType(import_obsidian.MarkdownView)) == null ? void 0 : _a2.editor;
        if (editor) {
          let content = editor.getValue();
          const deleteRegex = /\|-(.*?)-\|/gs;
          content = content.replace(deleteRegex, "");
          content = content.replaceAll("|+", "");
          content = content.replaceAll("+|", "");
          editor.setValue(content);
          new import_obsidian.Notice("Dips applied successfully.");
        } else {
          new import_obsidian.Notice("No active markdown editor found.");
        }
      }
    });
  }
  patchCanvasMenu() {
    var _a2, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k, _l;
    const canvasView = (_a2 = this.app.workspace.getLeavesOfType("canvas").first()) == null ? void 0 : _a2.view;
    if (!canvasView) {
      return;
    }
    const canvas = canvasView.canvas;
    const menu = canvasView.canvas.menu;
    if (!menu) {
      console.error("No menu found on the canvas");
      return;
    }
    const that = this;
    const menuUninstaller = around(menu.constructor.prototype, {
      render: (next) => function(...args) {
        const result = next.call(this, ...args);
        that.addGraphButtonIfNeeded(this.menuEl);
        that.addAIButtonIfNeeded(this.menuEl);
        return result;
      }
    });
    console.log("Heree---");
    console.log(canvasView.constructor.prototype);
    (_b = canvasView.scope) == null ? void 0 : _b.register(["Mod", "Shift"], "ArrowUp", () => {
      that.create_directional_node(canvas, "top");
    });
    (_c = canvasView.scope) == null ? void 0 : _c.register(["Mod"], "ArrowUp", () => {
      that.navigate(canvas, "top");
    });
    (_d = canvasView.scope) == null ? void 0 : _d.register(["Mod"], "ArrowDown", () => {
      that.navigate(canvas, "bottom");
    });
    (_e = canvasView.scope) == null ? void 0 : _e.register(["Mod"], "ArrowLeft", () => {
      that.navigate(canvas, "left");
    });
    (_f = canvasView.scope) == null ? void 0 : _f.register(["Mod"], "ArrowRight", () => {
      that.navigate(canvas, "right");
    });
    (_g = canvasView.scope) == null ? void 0 : _g.register(["Mod"], "Enter", () => {
      that.start_editing_node(canvas);
    });
    (_h = canvasView.scope) == null ? void 0 : _h.register(["Mod", "Shift"], "ArrowUp", () => {
      that.create_directional_node(canvas, "top");
    });
    (_i = canvasView.scope) == null ? void 0 : _i.register(["Mod", "Shift"], "ArrowDown", () => {
      that.create_directional_node(canvas, "bottom");
    });
    (_j = canvasView.scope) == null ? void 0 : _j.register(["Mod", "Shift"], "ArrowLeft", () => {
      that.create_directional_node(canvas, "left");
    });
    (_k = canvasView.scope) == null ? void 0 : _k.register(["Mod", "Shift"], "ArrowRight", () => {
      that.create_directional_node(canvas, "right");
    });
    (_l = canvasView.scope) == null ? void 0 : _l.register(["Mod", "Shift"], "Enter", () => {
      that.run_graph_chat(canvas);
    });
    this.register(menuUninstaller);
  }
  create_directional_node(canvas, direction) {
    const selection = canvas.selection;
    const selectionIterator = selection.values();
    const node = selectionIterator.next().value;
    if (!node) {
      return;
    }
    if (node.isEditing) {
      return;
    }
    const parent_node_x = node.x;
    const parent_node_y = node.y;
    const parent_width = node.width;
    const parent_height = node.height;
    let x;
    let y;
    let from_side;
    let to_side;
    switch (direction) {
      case "left":
        x = parent_node_x - parent_width - 200;
        y = parent_node_y;
        from_side = "left";
        to_side = "right";
        break;
      case "right":
        x = parent_node_x + parent_width + 200;
        y = parent_node_y;
        from_side = "right";
        to_side = "left";
        break;
      case "top":
        x = parent_node_x;
        y = parent_node_y - parent_height - 200;
        from_side = "top";
        to_side = "bottom";
        break;
      case "bottom":
        x = parent_node_x;
        y = parent_node_y + parent_height + 200;
        from_side = "bottom";
        to_side = "top";
        break;
      default:
        console.error("Invalid direction provided");
        return;
    }
    this.childNode(canvas, node, x, y, "<role>user</role>", from_side, to_side);
  }
  start_editing_node(canvas) {
    const selection = canvas.selection;
    const selectionIterator = selection.values();
    const node = selectionIterator.next().value;
    const node_id = node.id;
    node.isEditing = true;
    const editButton = document.querySelector('.canvas-menu button[aria-label="Edit"]');
    if (editButton) {
      editButton.click();
    } else {
      console.error("Edit button not found");
    }
  }
  run_graph_chat(canvas) {
    const selection = canvas.selection;
    const selectionIterator = selection.values();
    const node = selectionIterator.next().value;
    const node_id = node.id;
    node.isEditing = true;
    const editButton = document.querySelector('.canvas-menu button[aria-label="Sparkle"]');
    if (editButton) {
      editButton.click();
    } else {
      console.error("Edit button not found");
    }
  }
  navigate(canvas, direction) {
    const selection = canvas.selection;
    const selectionIterator = selection.values();
    const node = selectionIterator.next().value;
    console.log("In canvas");
    console.log(node);
    if (!node) {
      return;
    }
    const node_id = node.id;
    const canvas_data = canvas.getData();
    const edges = canvas_data.edges;
    const nodes = canvas_data.nodes;
    let targetNodeID = null;
    switch (direction) {
      case "right":
        const edgeRightFrom = edges.find((edge) => edge.fromNode === node_id && edge.fromSide === "right");
        if (edgeRightFrom) {
          targetNodeID = edgeRightFrom.toNode;
        } else {
          const edgeRightTo = edges.find((edge) => edge.toNode === node_id && edge.toSide === "right");
          if (edgeRightTo) {
            targetNodeID = edgeRightTo.fromNode;
          }
        }
        break;
      case "left":
        const edgeLeftFrom = edges.find((edge) => edge.fromNode === node_id && edge.fromSide === "left");
        if (edgeLeftFrom) {
          targetNodeID = edgeLeftFrom.toNode;
        } else {
          const edgeLeftTo = edges.find((edge) => edge.toNode === node_id && edge.toSide === "left");
          if (edgeLeftTo) {
            targetNodeID = edgeLeftTo.fromNode;
          }
        }
        break;
      case "top":
        const edgeTopFrom = edges.find((edge) => edge.fromNode === node_id && edge.fromSide === "top");
        if (edgeTopFrom) {
          targetNodeID = edgeTopFrom.toNode;
        } else {
          const edgeTopTo = edges.find((edge) => edge.toNode === node_id && edge.toSide === "top");
          if (edgeTopTo) {
            targetNodeID = edgeTopTo.fromNode;
          }
        }
        break;
      case "bottom":
        const edgeBottomFrom = edges.find((edge) => edge.fromNode === node_id && edge.fromSide === "bottom");
        if (edgeBottomFrom) {
          targetNodeID = edgeBottomFrom.toNode;
        } else {
          const edgeBottomTo = edges.find((edge) => edge.toNode === node_id && edge.toSide === "bottom");
          if (edgeBottomTo) {
            targetNodeID = edgeBottomTo.fromNode;
          }
        }
        break;
    }
    let viewport_nodes = [];
    let initial_viewport_children = canvas.nodeIndex.data.children;
    console.log("View port nodes");
    if (initial_viewport_children.length > 1) {
      for (let i = 0; i < initial_viewport_children.length; i++) {
        const nodes_list = initial_viewport_children[i].children;
        console.log({ nodes_list });
        nodes_list.forEach((node2) => {
          viewport_nodes.push(node2);
        });
      }
    }
    console.log(viewport_nodes);
    console.log(targetNodeID);
    if (targetNodeID) {
      const target_node = viewport_nodes.find((node2) => node2.id === targetNodeID);
      console.log(target_node);
      console.log("Makes it here");
      canvas.selectOnly(target_node);
      canvas.zoomToSelection();
    }
  }
  addGraphButtonIfNeeded(menuEl) {
    if (!menuEl.querySelector(".graph-menu-item")) {
      const graphButtonEl = createEl("button", "clickable-icon graph-menu-item");
      (0, import_obsidian.setTooltip)(graphButtonEl, "Create Node", { placement: "top" });
      (0, import_obsidian.setIcon)(graphButtonEl, "lucide-workflow");
      graphButtonEl.addEventListener("click", () => {
        var _a2;
        console.log("Graph button clicked");
        const canvasView = (_a2 = this.app.workspace.getLeavesOfType("canvas").first()) == null ? void 0 : _a2.view;
        const canvas = canvasView.canvas;
        const selection = canvas.selection;
        const selectionIterator = selection.values();
        const node = selectionIterator.next().value;
        const x = node.x + node.width + 200;
        this.childNode(canvas, node, x, node.y, "<role>user</role>");
      });
      menuEl.appendChild(graphButtonEl);
    }
  }
  get_ancestors(nodes, edges, nodeId) {
    let ancestors = [];
    let currentId = nodeId;
    let processedNodes = /* @__PURE__ */ new Set();
    while (true) {
      const incomingEdges = edges.filter((edge) => edge.toNode === currentId);
      if (incomingEdges.length === 0) {
        break;
      }
      currentId = incomingEdges[0].fromNode;
      if (processedNodes.has(currentId)) {
        break;
      }
      processedNodes.add(currentId);
      const ancestor = nodes.find((node) => node.id === currentId);
      if (ancestor) {
        ancestors.push(ancestor);
      }
    }
    return ancestors;
  }
  getAllAncestorNodes(nodes, edges, nodeId) {
    let ancestors = [];
    let queue = [nodeId];
    let processedNodes = /* @__PURE__ */ new Set();
    while (queue.length > 0) {
      let currentId = queue.shift();
      if (!currentId || processedNodes.has(currentId))
        continue;
      processedNodes.add(currentId);
      const incomingEdges = edges.filter((edge) => edge.toNode === currentId);
      incomingEdges.forEach((edge) => {
        const ancestor = nodes.find((node) => node.id === edge.fromNode);
        if (ancestor && !processedNodes.has(ancestor.id)) {
          ancestors.push(ancestor);
          queue.push(ancestor.id);
        }
      });
    }
    return ancestors;
  }
  getLongestLineage(nodes, edges, nodeId) {
    let longestLineage = [];
    function findLongestPath(currentId, path) {
      const incomingEdges = edges.filter((edge) => edge.toNode === currentId);
      if (incomingEdges.length === 0) {
        if (path.length > longestLineage.length) {
          longestLineage = path.slice();
        }
        return;
      }
      incomingEdges.forEach((edge) => {
        const ancestor = nodes.find((node) => node.id === edge.fromNode);
        if (ancestor) {
          findLongestPath(ancestor.id, path.concat(ancestor));
        }
      });
    }
    const startNode = nodes.find((node) => node.id === nodeId);
    if (startNode) {
      findLongestPath(nodeId, [startNode]);
    }
    return longestLineage;
  }
  addAIButtonIfNeeded(menuEl) {
    if (!menuEl.querySelector(".gpt-menu-item")) {
      const buttonEl = createEl("button", "clickable-icon gpt-menu-item");
      (0, import_obsidian.setTooltip)(buttonEl, "Sparkle", { placement: "top" });
      (0, import_obsidian.setIcon)(buttonEl, "lucide-sparkles");
      buttonEl.addEventListener("click", async () => {
        var _a2;
        const canvasView = (_a2 = this.app.workspace.getLeavesOfType("canvas").first()) == null ? void 0 : _a2.view;
        const canvas = canvasView.canvas;
        const selection = canvas.selection;
        const selectionIterator = selection.values();
        const node = selectionIterator.next().value;
        const canvas_data = canvas.getData();
        const { edges, nodes } = canvas_data;
        const longest_lineage = this.getLongestLineage(nodes, edges, node.id);
        let conversation = [];
        for (let i = 0; i < longest_lineage.length; i++) {
          const node2 = longest_lineage[i];
          const text = node2.text;
          const userRegex = /<role>User<\/role>/i;
          const assistantRegex = /<role>assistant<\/role>/i;
          if (userRegex.test(text)) {
            const split_text = text.split(userRegex);
            const role = "user";
            const content2 = split_text[1].trim();
            const message = {
              role,
              content: content2
            };
            conversation.push(message);
          }
          if (assistantRegex.test(text)) {
            const split_text = text.split(assistantRegex);
            const role = "assistant";
            const content2 = split_text[1].trim();
            const message = {
              role,
              content: content2
            };
            conversation.push(message);
          }
        }
        conversation.reverse();
        console.log({ conversation });
        const data = {
          conversation
        };
        const model = "llama3-70b-8192";
        const params = {
          messages: conversation,
          model,
          // tools: tools,
          // tool_choice: tool_choice,
          max_tokens: 12e3,
          stop: null
        };
        new import_obsidian.Notice("Calling Groq!");
        const chat_completion = await groq.chat.completions.create(params);
        console.log(chat_completion);
        const content = chat_completion.choices[0].message.content;
        const node_content = `<role>assistant</role>
${content}`;
        const x = node.x + node.width + 200;
        this.childNode(canvas, node, x, node.y, node_content, "right", "left", "groq");
      });
      menuEl.appendChild(buttonEl);
    }
  }
  // Method to insert text into the sidebar
  insertTextIntoSidebar(text) {
    const trimmed_text = text.trim();
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view.getViewType() === VIEW_NAME_SIDEBAR_CHAT) {
        const view = leaf.view;
        if (view.textBox) {
          view.textBox.value += trimmed_text;
        }
      }
    });
  }
  // Method to clear text from the sidebar
  clearTextInSidebar() {
    this.app.workspace.iterateAllLeaves((leaf) => {
      if (leaf.view.getViewType() === VIEW_NAME_SIDEBAR_CHAT) {
        const view = leaf.view;
        if (view.textBox) {
          view.textBox.value = "";
        }
        if (view.messagesContainer) {
          view.messagesContainer.innerHTML = "";
        }
      }
    });
  }
  addSidebarTab() {
    this.addRibbonIcon("document", "Open Caret", async (evt) => {
      let main_chat_found = false;
      this.app.workspace.iterateAllLeaves((leaf) => {
        if (leaf.view.getViewType() === VIEW_NAME_MAIN_CHAT) {
          main_chat_found = true;
          if (!leaf.view.containerEl.parentElement.classList.contains("is-active")) {
            this.app.workspace.revealLeaf(leaf);
          }
        }
      });
      if (!main_chat_found) {
        await this.app.workspace.getLeaf(true).setViewState({
          type: VIEW_NAME_MAIN_CHAT,
          active: true
        });
      }
    });
  }
  onunload() {
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
};
//# sourceMappingURL=data:application/json;base64,ewogICJ2ZXJzaW9uIjogMywKICAic291cmNlcyI6IFsibm9kZV9tb2R1bGVzL2RvdGVudi9wYWNrYWdlLmpzb24iLCAibm9kZV9tb2R1bGVzL2RvdGVudi9saWIvbWFpbi5qcyIsICJtYWluLnRzIiwgIm5vZGVfbW9kdWxlcy9ncm9xLXNkay9zcmMvdmVyc2lvbi50cyIsICJub2RlX21vZHVsZXMvZ3JvcS1zZGsvc3JjL19zaGltcy9yZWdpc3RyeS50cyIsICJub2RlX21vZHVsZXMvZ3JvcS1zZGsvc3JjL19zaGltcy9NdWx0aXBhcnRCb2R5LnRzIiwgIm5vZGVfbW9kdWxlcy9ncm9xLXNkay9zcmMvX3NoaW1zL3dlYi1ydW50aW1lLnRzIiwgIm5vZGVfbW9kdWxlcy9ncm9xLXNkay9fc2hpbXMvaW5kZXgubWpzIiwgIm5vZGVfbW9kdWxlcy9ncm9xLXNkay9zcmMvZXJyb3IudHMiLCAibm9kZV9tb2R1bGVzL2dyb3Etc2RrL3NyYy9saWIvc3RyZWFtaW5nLnRzIiwgIm5vZGVfbW9kdWxlcy9ncm9xLXNkay9zcmMvdXBsb2Fkcy50cyIsICJub2RlX21vZHVsZXMvZ3JvcS1zZGsvc3JjL2NvcmUudHMiLCAibm9kZV9tb2R1bGVzL2dyb3Etc2RrL3NyYy9yZXNvdXJjZS50cyIsICJub2RlX21vZHVsZXMvZ3JvcS1zZGsvc3JjL3Jlc291cmNlcy9jaGF0L2NvbXBsZXRpb25zLnRzIiwgIm5vZGVfbW9kdWxlcy9ncm9xLXNkay9zcmMvcmVzb3VyY2VzL2NoYXQvY2hhdC50cyIsICJub2RlX21vZHVsZXMvZ3JvcS1zZGsvc3JjL3Jlc291cmNlcy9tb2RlbHMudHMiLCAibm9kZV9tb2R1bGVzL2dyb3Etc2RrL3NyYy9yZXNvdXJjZXMvYXVkaW8vdHJhbnNjcmlwdGlvbnMudHMiLCAibm9kZV9tb2R1bGVzL2dyb3Etc2RrL3NyYy9yZXNvdXJjZXMvYXVkaW8vdHJhbnNsYXRpb25zLnRzIiwgIm5vZGVfbW9kdWxlcy9ncm9xLXNkay9zcmMvcmVzb3VyY2VzL2F1ZGlvL2F1ZGlvLnRzIiwgIm5vZGVfbW9kdWxlcy9ncm9xLXNkay9zcmMvaW5kZXgudHMiLCAibm9kZV9tb2R1bGVzL21vbmtleS1hcm91bmQvZGlzdC9pbmRleC5tanMiXSwKICAic291cmNlc0NvbnRlbnQiOiBbIntcbiAgXCJuYW1lXCI6IFwiZG90ZW52XCIsXG4gIFwidmVyc2lvblwiOiBcIjE2LjQuNVwiLFxuICBcImRlc2NyaXB0aW9uXCI6IFwiTG9hZHMgZW52aXJvbm1lbnQgdmFyaWFibGVzIGZyb20gLmVudiBmaWxlXCIsXG4gIFwibWFpblwiOiBcImxpYi9tYWluLmpzXCIsXG4gIFwidHlwZXNcIjogXCJsaWIvbWFpbi5kLnRzXCIsXG4gIFwiZXhwb3J0c1wiOiB7XG4gICAgXCIuXCI6IHtcbiAgICAgIFwidHlwZXNcIjogXCIuL2xpYi9tYWluLmQudHNcIixcbiAgICAgIFwicmVxdWlyZVwiOiBcIi4vbGliL21haW4uanNcIixcbiAgICAgIFwiZGVmYXVsdFwiOiBcIi4vbGliL21haW4uanNcIlxuICAgIH0sXG4gICAgXCIuL2NvbmZpZ1wiOiBcIi4vY29uZmlnLmpzXCIsXG4gICAgXCIuL2NvbmZpZy5qc1wiOiBcIi4vY29uZmlnLmpzXCIsXG4gICAgXCIuL2xpYi9lbnYtb3B0aW9uc1wiOiBcIi4vbGliL2Vudi1vcHRpb25zLmpzXCIsXG4gICAgXCIuL2xpYi9lbnYtb3B0aW9ucy5qc1wiOiBcIi4vbGliL2Vudi1vcHRpb25zLmpzXCIsXG4gICAgXCIuL2xpYi9jbGktb3B0aW9uc1wiOiBcIi4vbGliL2NsaS1vcHRpb25zLmpzXCIsXG4gICAgXCIuL2xpYi9jbGktb3B0aW9ucy5qc1wiOiBcIi4vbGliL2NsaS1vcHRpb25zLmpzXCIsXG4gICAgXCIuL3BhY2thZ2UuanNvblwiOiBcIi4vcGFja2FnZS5qc29uXCJcbiAgfSxcbiAgXCJzY3JpcHRzXCI6IHtcbiAgICBcImR0cy1jaGVja1wiOiBcInRzYyAtLXByb2plY3QgdGVzdHMvdHlwZXMvdHNjb25maWcuanNvblwiLFxuICAgIFwibGludFwiOiBcInN0YW5kYXJkXCIsXG4gICAgXCJsaW50LXJlYWRtZVwiOiBcInN0YW5kYXJkLW1hcmtkb3duXCIsXG4gICAgXCJwcmV0ZXN0XCI6IFwibnBtIHJ1biBsaW50ICYmIG5wbSBydW4gZHRzLWNoZWNrXCIsXG4gICAgXCJ0ZXN0XCI6IFwidGFwIHRlc3RzLyouanMgLS0xMDAgLVJzcGVjXCIsXG4gICAgXCJ0ZXN0OmNvdmVyYWdlXCI6IFwidGFwIC0tY292ZXJhZ2UtcmVwb3J0PWxjb3ZcIixcbiAgICBcInByZXJlbGVhc2VcIjogXCJucG0gdGVzdFwiLFxuICAgIFwicmVsZWFzZVwiOiBcInN0YW5kYXJkLXZlcnNpb25cIlxuICB9LFxuICBcInJlcG9zaXRvcnlcIjoge1xuICAgIFwidHlwZVwiOiBcImdpdFwiLFxuICAgIFwidXJsXCI6IFwiZ2l0Oi8vZ2l0aHViLmNvbS9tb3Rkb3RsYS9kb3RlbnYuZ2l0XCJcbiAgfSxcbiAgXCJmdW5kaW5nXCI6IFwiaHR0cHM6Ly9kb3RlbnZ4LmNvbVwiLFxuICBcImtleXdvcmRzXCI6IFtcbiAgICBcImRvdGVudlwiLFxuICAgIFwiZW52XCIsXG4gICAgXCIuZW52XCIsXG4gICAgXCJlbnZpcm9ubWVudFwiLFxuICAgIFwidmFyaWFibGVzXCIsXG4gICAgXCJjb25maWdcIixcbiAgICBcInNldHRpbmdzXCJcbiAgXSxcbiAgXCJyZWFkbWVGaWxlbmFtZVwiOiBcIlJFQURNRS5tZFwiLFxuICBcImxpY2Vuc2VcIjogXCJCU0QtMi1DbGF1c2VcIixcbiAgXCJkZXZEZXBlbmRlbmNpZXNcIjoge1xuICAgIFwiQGRlZmluaXRlbHl0eXBlZC9kdHNsaW50XCI6IFwiXjAuMC4xMzNcIixcbiAgICBcIkB0eXBlcy9ub2RlXCI6IFwiXjE4LjExLjNcIixcbiAgICBcImRlY2FjaGVcIjogXCJeNC42LjFcIixcbiAgICBcInNpbm9uXCI6IFwiXjE0LjAuMVwiLFxuICAgIFwic3RhbmRhcmRcIjogXCJeMTcuMC4wXCIsXG4gICAgXCJzdGFuZGFyZC1tYXJrZG93blwiOiBcIl43LjEuMFwiLFxuICAgIFwic3RhbmRhcmQtdmVyc2lvblwiOiBcIl45LjUuMFwiLFxuICAgIFwidGFwXCI6IFwiXjE2LjMuMFwiLFxuICAgIFwidGFyXCI6IFwiXjYuMS4xMVwiLFxuICAgIFwidHlwZXNjcmlwdFwiOiBcIl40LjguNFwiXG4gIH0sXG4gIFwiZW5naW5lc1wiOiB7XG4gICAgXCJub2RlXCI6IFwiPj0xMlwiXG4gIH0sXG4gIFwiYnJvd3NlclwiOiB7XG4gICAgXCJmc1wiOiBmYWxzZVxuICB9XG59XG4iLCAiY29uc3QgZnMgPSByZXF1aXJlKCdmcycpXG5jb25zdCBwYXRoID0gcmVxdWlyZSgncGF0aCcpXG5jb25zdCBvcyA9IHJlcXVpcmUoJ29zJylcbmNvbnN0IGNyeXB0byA9IHJlcXVpcmUoJ2NyeXB0bycpXG5jb25zdCBwYWNrYWdlSnNvbiA9IHJlcXVpcmUoJy4uL3BhY2thZ2UuanNvbicpXG5cbmNvbnN0IHZlcnNpb24gPSBwYWNrYWdlSnNvbi52ZXJzaW9uXG5cbmNvbnN0IExJTkUgPSAvKD86XnxeKVxccyooPzpleHBvcnRcXHMrKT8oW1xcdy4tXSspKD86XFxzKj1cXHMqP3w6XFxzKz8pKFxccyonKD86XFxcXCd8W14nXSkqJ3xcXHMqXCIoPzpcXFxcXCJ8W15cIl0pKlwifFxccypgKD86XFxcXGB8W15gXSkqYHxbXiNcXHJcXG5dKyk/XFxzKig/OiMuKik/KD86JHwkKS9tZ1xuXG4vLyBQYXJzZSBzcmMgaW50byBhbiBPYmplY3RcbmZ1bmN0aW9uIHBhcnNlIChzcmMpIHtcbiAgY29uc3Qgb2JqID0ge31cblxuICAvLyBDb252ZXJ0IGJ1ZmZlciB0byBzdHJpbmdcbiAgbGV0IGxpbmVzID0gc3JjLnRvU3RyaW5nKClcblxuICAvLyBDb252ZXJ0IGxpbmUgYnJlYWtzIHRvIHNhbWUgZm9ybWF0XG4gIGxpbmVzID0gbGluZXMucmVwbGFjZSgvXFxyXFxuPy9tZywgJ1xcbicpXG5cbiAgbGV0IG1hdGNoXG4gIHdoaWxlICgobWF0Y2ggPSBMSU5FLmV4ZWMobGluZXMpKSAhPSBudWxsKSB7XG4gICAgY29uc3Qga2V5ID0gbWF0Y2hbMV1cblxuICAgIC8vIERlZmF1bHQgdW5kZWZpbmVkIG9yIG51bGwgdG8gZW1wdHkgc3RyaW5nXG4gICAgbGV0IHZhbHVlID0gKG1hdGNoWzJdIHx8ICcnKVxuXG4gICAgLy8gUmVtb3ZlIHdoaXRlc3BhY2VcbiAgICB2YWx1ZSA9IHZhbHVlLnRyaW0oKVxuXG4gICAgLy8gQ2hlY2sgaWYgZG91YmxlIHF1b3RlZFxuICAgIGNvbnN0IG1heWJlUXVvdGUgPSB2YWx1ZVswXVxuXG4gICAgLy8gUmVtb3ZlIHN1cnJvdW5kaW5nIHF1b3Rlc1xuICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXihbJ1wiYF0pKFtcXHNcXFNdKilcXDEkL21nLCAnJDInKVxuXG4gICAgLy8gRXhwYW5kIG5ld2xpbmVzIGlmIGRvdWJsZSBxdW90ZWRcbiAgICBpZiAobWF5YmVRdW90ZSA9PT0gJ1wiJykge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5yZXBsYWNlKC9cXFxcbi9nLCAnXFxuJylcbiAgICAgIHZhbHVlID0gdmFsdWUucmVwbGFjZSgvXFxcXHIvZywgJ1xccicpXG4gICAgfVxuXG4gICAgLy8gQWRkIHRvIG9iamVjdFxuICAgIG9ialtrZXldID0gdmFsdWVcbiAgfVxuXG4gIHJldHVybiBvYmpcbn1cblxuZnVuY3Rpb24gX3BhcnNlVmF1bHQgKG9wdGlvbnMpIHtcbiAgY29uc3QgdmF1bHRQYXRoID0gX3ZhdWx0UGF0aChvcHRpb25zKVxuXG4gIC8vIFBhcnNlIC5lbnYudmF1bHRcbiAgY29uc3QgcmVzdWx0ID0gRG90ZW52TW9kdWxlLmNvbmZpZ0RvdGVudih7IHBhdGg6IHZhdWx0UGF0aCB9KVxuICBpZiAoIXJlc3VsdC5wYXJzZWQpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYE1JU1NJTkdfREFUQTogQ2Fubm90IHBhcnNlICR7dmF1bHRQYXRofSBmb3IgYW4gdW5rbm93biByZWFzb25gKVxuICAgIGVyci5jb2RlID0gJ01JU1NJTkdfREFUQSdcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIC8vIGhhbmRsZSBzY2VuYXJpbyBmb3IgY29tbWEgc2VwYXJhdGVkIGtleXMgLSBmb3IgdXNlIHdpdGgga2V5IHJvdGF0aW9uXG4gIC8vIGV4YW1wbGU6IERPVEVOVl9LRVk9XCJkb3RlbnY6Ly86a2V5XzEyMzRAZG90ZW52eC5jb20vdmF1bHQvLmVudi52YXVsdD9lbnZpcm9ubWVudD1wcm9kLGRvdGVudjovLzprZXlfNzg5MEBkb3RlbnZ4LmNvbS92YXVsdC8uZW52LnZhdWx0P2Vudmlyb25tZW50PXByb2RcIlxuICBjb25zdCBrZXlzID0gX2RvdGVudktleShvcHRpb25zKS5zcGxpdCgnLCcpXG4gIGNvbnN0IGxlbmd0aCA9IGtleXMubGVuZ3RoXG5cbiAgbGV0IGRlY3J5cHRlZFxuICBmb3IgKGxldCBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgdHJ5IHtcbiAgICAgIC8vIEdldCBmdWxsIGtleVxuICAgICAgY29uc3Qga2V5ID0ga2V5c1tpXS50cmltKClcblxuICAgICAgLy8gR2V0IGluc3RydWN0aW9ucyBmb3IgZGVjcnlwdFxuICAgICAgY29uc3QgYXR0cnMgPSBfaW5zdHJ1Y3Rpb25zKHJlc3VsdCwga2V5KVxuXG4gICAgICAvLyBEZWNyeXB0XG4gICAgICBkZWNyeXB0ZWQgPSBEb3RlbnZNb2R1bGUuZGVjcnlwdChhdHRycy5jaXBoZXJ0ZXh0LCBhdHRycy5rZXkpXG5cbiAgICAgIGJyZWFrXG4gICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgIC8vIGxhc3Qga2V5XG4gICAgICBpZiAoaSArIDEgPj0gbGVuZ3RoKSB7XG4gICAgICAgIHRocm93IGVycm9yXG4gICAgICB9XG4gICAgICAvLyB0cnkgbmV4dCBrZXlcbiAgICB9XG4gIH1cblxuICAvLyBQYXJzZSBkZWNyeXB0ZWQgLmVudiBzdHJpbmdcbiAgcmV0dXJuIERvdGVudk1vZHVsZS5wYXJzZShkZWNyeXB0ZWQpXG59XG5cbmZ1bmN0aW9uIF9sb2cgKG1lc3NhZ2UpIHtcbiAgY29uc29sZS5sb2coYFtkb3RlbnZAJHt2ZXJzaW9ufV1bSU5GT10gJHttZXNzYWdlfWApXG59XG5cbmZ1bmN0aW9uIF93YXJuIChtZXNzYWdlKSB7XG4gIGNvbnNvbGUubG9nKGBbZG90ZW52QCR7dmVyc2lvbn1dW1dBUk5dICR7bWVzc2FnZX1gKVxufVxuXG5mdW5jdGlvbiBfZGVidWcgKG1lc3NhZ2UpIHtcbiAgY29uc29sZS5sb2coYFtkb3RlbnZAJHt2ZXJzaW9ufV1bREVCVUddICR7bWVzc2FnZX1gKVxufVxuXG5mdW5jdGlvbiBfZG90ZW52S2V5IChvcHRpb25zKSB7XG4gIC8vIHByaW9yaXRpemUgZGV2ZWxvcGVyIGRpcmVjdGx5IHNldHRpbmcgb3B0aW9ucy5ET1RFTlZfS0VZXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuRE9URU5WX0tFWSAmJiBvcHRpb25zLkRPVEVOVl9LRVkubGVuZ3RoID4gMCkge1xuICAgIHJldHVybiBvcHRpb25zLkRPVEVOVl9LRVlcbiAgfVxuXG4gIC8vIHNlY29uZGFyeSBpbmZyYSBhbHJlYWR5IGNvbnRhaW5zIGEgRE9URU5WX0tFWSBlbnZpcm9ubWVudCB2YXJpYWJsZVxuICBpZiAocHJvY2Vzcy5lbnYuRE9URU5WX0tFWSAmJiBwcm9jZXNzLmVudi5ET1RFTlZfS0VZLmxlbmd0aCA+IDApIHtcbiAgICByZXR1cm4gcHJvY2Vzcy5lbnYuRE9URU5WX0tFWVxuICB9XG5cbiAgLy8gZmFsbGJhY2sgdG8gZW1wdHkgc3RyaW5nXG4gIHJldHVybiAnJ1xufVxuXG5mdW5jdGlvbiBfaW5zdHJ1Y3Rpb25zIChyZXN1bHQsIGRvdGVudktleSkge1xuICAvLyBQYXJzZSBET1RFTlZfS0VZLiBGb3JtYXQgaXMgYSBVUklcbiAgbGV0IHVyaVxuICB0cnkge1xuICAgIHVyaSA9IG5ldyBVUkwoZG90ZW52S2V5KVxuICB9IGNhdGNoIChlcnJvcikge1xuICAgIGlmIChlcnJvci5jb2RlID09PSAnRVJSX0lOVkFMSURfVVJMJykge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdJTlZBTElEX0RPVEVOVl9LRVk6IFdyb25nIGZvcm1hdC4gTXVzdCBiZSBpbiB2YWxpZCB1cmkgZm9ybWF0IGxpa2UgZG90ZW52Oi8vOmtleV8xMjM0QGRvdGVudnguY29tL3ZhdWx0Ly5lbnYudmF1bHQ/ZW52aXJvbm1lbnQ9ZGV2ZWxvcG1lbnQnKVxuICAgICAgZXJyLmNvZGUgPSAnSU5WQUxJRF9ET1RFTlZfS0VZJ1xuICAgICAgdGhyb3cgZXJyXG4gICAgfVxuXG4gICAgdGhyb3cgZXJyb3JcbiAgfVxuXG4gIC8vIEdldCBkZWNyeXB0IGtleVxuICBjb25zdCBrZXkgPSB1cmkucGFzc3dvcmRcbiAgaWYgKCFrZXkpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0lOVkFMSURfRE9URU5WX0tFWTogTWlzc2luZyBrZXkgcGFydCcpXG4gICAgZXJyLmNvZGUgPSAnSU5WQUxJRF9ET1RFTlZfS0VZJ1xuICAgIHRocm93IGVyclxuICB9XG5cbiAgLy8gR2V0IGVudmlyb25tZW50XG4gIGNvbnN0IGVudmlyb25tZW50ID0gdXJpLnNlYXJjaFBhcmFtcy5nZXQoJ2Vudmlyb25tZW50JylcbiAgaWYgKCFlbnZpcm9ubWVudCkge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignSU5WQUxJRF9ET1RFTlZfS0VZOiBNaXNzaW5nIGVudmlyb25tZW50IHBhcnQnKVxuICAgIGVyci5jb2RlID0gJ0lOVkFMSURfRE9URU5WX0tFWSdcbiAgICB0aHJvdyBlcnJcbiAgfVxuXG4gIC8vIEdldCBjaXBoZXJ0ZXh0IHBheWxvYWRcbiAgY29uc3QgZW52aXJvbm1lbnRLZXkgPSBgRE9URU5WX1ZBVUxUXyR7ZW52aXJvbm1lbnQudG9VcHBlckNhc2UoKX1gXG4gIGNvbnN0IGNpcGhlcnRleHQgPSByZXN1bHQucGFyc2VkW2Vudmlyb25tZW50S2V5XSAvLyBET1RFTlZfVkFVTFRfUFJPRFVDVElPTlxuICBpZiAoIWNpcGhlcnRleHQpIHtcbiAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoYE5PVF9GT1VORF9ET1RFTlZfRU5WSVJPTk1FTlQ6IENhbm5vdCBsb2NhdGUgZW52aXJvbm1lbnQgJHtlbnZpcm9ubWVudEtleX0gaW4geW91ciAuZW52LnZhdWx0IGZpbGUuYClcbiAgICBlcnIuY29kZSA9ICdOT1RfRk9VTkRfRE9URU5WX0VOVklST05NRU5UJ1xuICAgIHRocm93IGVyclxuICB9XG5cbiAgcmV0dXJuIHsgY2lwaGVydGV4dCwga2V5IH1cbn1cblxuZnVuY3Rpb24gX3ZhdWx0UGF0aCAob3B0aW9ucykge1xuICBsZXQgcG9zc2libGVWYXVsdFBhdGggPSBudWxsXG5cbiAgaWYgKG9wdGlvbnMgJiYgb3B0aW9ucy5wYXRoICYmIG9wdGlvbnMucGF0aC5sZW5ndGggPiAwKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkob3B0aW9ucy5wYXRoKSkge1xuICAgICAgZm9yIChjb25zdCBmaWxlcGF0aCBvZiBvcHRpb25zLnBhdGgpIHtcbiAgICAgICAgaWYgKGZzLmV4aXN0c1N5bmMoZmlsZXBhdGgpKSB7XG4gICAgICAgICAgcG9zc2libGVWYXVsdFBhdGggPSBmaWxlcGF0aC5lbmRzV2l0aCgnLnZhdWx0JykgPyBmaWxlcGF0aCA6IGAke2ZpbGVwYXRofS52YXVsdGBcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBwb3NzaWJsZVZhdWx0UGF0aCA9IG9wdGlvbnMucGF0aC5lbmRzV2l0aCgnLnZhdWx0JykgPyBvcHRpb25zLnBhdGggOiBgJHtvcHRpb25zLnBhdGh9LnZhdWx0YFxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBwb3NzaWJsZVZhdWx0UGF0aCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCAnLmVudi52YXVsdCcpXG4gIH1cblxuICBpZiAoZnMuZXhpc3RzU3luYyhwb3NzaWJsZVZhdWx0UGF0aCkpIHtcbiAgICByZXR1cm4gcG9zc2libGVWYXVsdFBhdGhcbiAgfVxuXG4gIHJldHVybiBudWxsXG59XG5cbmZ1bmN0aW9uIF9yZXNvbHZlSG9tZSAoZW52UGF0aCkge1xuICByZXR1cm4gZW52UGF0aFswXSA9PT0gJ34nID8gcGF0aC5qb2luKG9zLmhvbWVkaXIoKSwgZW52UGF0aC5zbGljZSgxKSkgOiBlbnZQYXRoXG59XG5cbmZ1bmN0aW9uIF9jb25maWdWYXVsdCAob3B0aW9ucykge1xuICBfbG9nKCdMb2FkaW5nIGVudiBmcm9tIGVuY3J5cHRlZCAuZW52LnZhdWx0JylcblxuICBjb25zdCBwYXJzZWQgPSBEb3RlbnZNb2R1bGUuX3BhcnNlVmF1bHQob3B0aW9ucylcblxuICBsZXQgcHJvY2Vzc0VudiA9IHByb2Nlc3MuZW52XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucHJvY2Vzc0VudiAhPSBudWxsKSB7XG4gICAgcHJvY2Vzc0VudiA9IG9wdGlvbnMucHJvY2Vzc0VudlxuICB9XG5cbiAgRG90ZW52TW9kdWxlLnBvcHVsYXRlKHByb2Nlc3NFbnYsIHBhcnNlZCwgb3B0aW9ucylcblxuICByZXR1cm4geyBwYXJzZWQgfVxufVxuXG5mdW5jdGlvbiBjb25maWdEb3RlbnYgKG9wdGlvbnMpIHtcbiAgY29uc3QgZG90ZW52UGF0aCA9IHBhdGgucmVzb2x2ZShwcm9jZXNzLmN3ZCgpLCAnLmVudicpXG4gIGxldCBlbmNvZGluZyA9ICd1dGY4J1xuICBjb25zdCBkZWJ1ZyA9IEJvb2xlYW4ob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnKVxuXG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMuZW5jb2RpbmcpIHtcbiAgICBlbmNvZGluZyA9IG9wdGlvbnMuZW5jb2RpbmdcbiAgfSBlbHNlIHtcbiAgICBpZiAoZGVidWcpIHtcbiAgICAgIF9kZWJ1ZygnTm8gZW5jb2RpbmcgaXMgc3BlY2lmaWVkLiBVVEYtOCBpcyB1c2VkIGJ5IGRlZmF1bHQnKVxuICAgIH1cbiAgfVxuXG4gIGxldCBvcHRpb25QYXRocyA9IFtkb3RlbnZQYXRoXSAvLyBkZWZhdWx0LCBsb29rIGZvciAuZW52XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucGF0aCkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheShvcHRpb25zLnBhdGgpKSB7XG4gICAgICBvcHRpb25QYXRocyA9IFtfcmVzb2x2ZUhvbWUob3B0aW9ucy5wYXRoKV1cbiAgICB9IGVsc2Uge1xuICAgICAgb3B0aW9uUGF0aHMgPSBbXSAvLyByZXNldCBkZWZhdWx0XG4gICAgICBmb3IgKGNvbnN0IGZpbGVwYXRoIG9mIG9wdGlvbnMucGF0aCkge1xuICAgICAgICBvcHRpb25QYXRocy5wdXNoKF9yZXNvbHZlSG9tZShmaWxlcGF0aCkpXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQnVpbGQgdGhlIHBhcnNlZCBkYXRhIGluIGEgdGVtcG9yYXJ5IG9iamVjdCAoYmVjYXVzZSB3ZSBuZWVkIHRvIHJldHVybiBpdCkuICBPbmNlIHdlIGhhdmUgdGhlIGZpbmFsXG4gIC8vIHBhcnNlZCBkYXRhLCB3ZSB3aWxsIGNvbWJpbmUgaXQgd2l0aCBwcm9jZXNzLmVudiAob3Igb3B0aW9ucy5wcm9jZXNzRW52IGlmIHByb3ZpZGVkKS5cbiAgbGV0IGxhc3RFcnJvclxuICBjb25zdCBwYXJzZWRBbGwgPSB7fVxuICBmb3IgKGNvbnN0IHBhdGggb2Ygb3B0aW9uUGF0aHMpIHtcbiAgICB0cnkge1xuICAgICAgLy8gU3BlY2lmeWluZyBhbiBlbmNvZGluZyByZXR1cm5zIGEgc3RyaW5nIGluc3RlYWQgb2YgYSBidWZmZXJcbiAgICAgIGNvbnN0IHBhcnNlZCA9IERvdGVudk1vZHVsZS5wYXJzZShmcy5yZWFkRmlsZVN5bmMocGF0aCwgeyBlbmNvZGluZyB9KSlcblxuICAgICAgRG90ZW52TW9kdWxlLnBvcHVsYXRlKHBhcnNlZEFsbCwgcGFyc2VkLCBvcHRpb25zKVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBfZGVidWcoYEZhaWxlZCB0byBsb2FkICR7cGF0aH0gJHtlLm1lc3NhZ2V9YClcbiAgICAgIH1cbiAgICAgIGxhc3RFcnJvciA9IGVcbiAgICB9XG4gIH1cblxuICBsZXQgcHJvY2Vzc0VudiA9IHByb2Nlc3MuZW52XG4gIGlmIChvcHRpb25zICYmIG9wdGlvbnMucHJvY2Vzc0VudiAhPSBudWxsKSB7XG4gICAgcHJvY2Vzc0VudiA9IG9wdGlvbnMucHJvY2Vzc0VudlxuICB9XG5cbiAgRG90ZW52TW9kdWxlLnBvcHVsYXRlKHByb2Nlc3NFbnYsIHBhcnNlZEFsbCwgb3B0aW9ucylcblxuICBpZiAobGFzdEVycm9yKSB7XG4gICAgcmV0dXJuIHsgcGFyc2VkOiBwYXJzZWRBbGwsIGVycm9yOiBsYXN0RXJyb3IgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiB7IHBhcnNlZDogcGFyc2VkQWxsIH1cbiAgfVxufVxuXG4vLyBQb3B1bGF0ZXMgcHJvY2Vzcy5lbnYgZnJvbSAuZW52IGZpbGVcbmZ1bmN0aW9uIGNvbmZpZyAob3B0aW9ucykge1xuICAvLyBmYWxsYmFjayB0byBvcmlnaW5hbCBkb3RlbnYgaWYgRE9URU5WX0tFWSBpcyBub3Qgc2V0XG4gIGlmIChfZG90ZW52S2V5KG9wdGlvbnMpLmxlbmd0aCA9PT0gMCkge1xuICAgIHJldHVybiBEb3RlbnZNb2R1bGUuY29uZmlnRG90ZW52KG9wdGlvbnMpXG4gIH1cblxuICBjb25zdCB2YXVsdFBhdGggPSBfdmF1bHRQYXRoKG9wdGlvbnMpXG5cbiAgLy8gZG90ZW52S2V5IGV4aXN0cyBidXQgLmVudi52YXVsdCBmaWxlIGRvZXMgbm90IGV4aXN0XG4gIGlmICghdmF1bHRQYXRoKSB7XG4gICAgX3dhcm4oYFlvdSBzZXQgRE9URU5WX0tFWSBidXQgeW91IGFyZSBtaXNzaW5nIGEgLmVudi52YXVsdCBmaWxlIGF0ICR7dmF1bHRQYXRofS4gRGlkIHlvdSBmb3JnZXQgdG8gYnVpbGQgaXQ/YClcblxuICAgIHJldHVybiBEb3RlbnZNb2R1bGUuY29uZmlnRG90ZW52KG9wdGlvbnMpXG4gIH1cblxuICByZXR1cm4gRG90ZW52TW9kdWxlLl9jb25maWdWYXVsdChvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBkZWNyeXB0IChlbmNyeXB0ZWQsIGtleVN0cikge1xuICBjb25zdCBrZXkgPSBCdWZmZXIuZnJvbShrZXlTdHIuc2xpY2UoLTY0KSwgJ2hleCcpXG4gIGxldCBjaXBoZXJ0ZXh0ID0gQnVmZmVyLmZyb20oZW5jcnlwdGVkLCAnYmFzZTY0JylcblxuICBjb25zdCBub25jZSA9IGNpcGhlcnRleHQuc3ViYXJyYXkoMCwgMTIpXG4gIGNvbnN0IGF1dGhUYWcgPSBjaXBoZXJ0ZXh0LnN1YmFycmF5KC0xNilcbiAgY2lwaGVydGV4dCA9IGNpcGhlcnRleHQuc3ViYXJyYXkoMTIsIC0xNilcblxuICB0cnkge1xuICAgIGNvbnN0IGFlc2djbSA9IGNyeXB0by5jcmVhdGVEZWNpcGhlcml2KCdhZXMtMjU2LWdjbScsIGtleSwgbm9uY2UpXG4gICAgYWVzZ2NtLnNldEF1dGhUYWcoYXV0aFRhZylcbiAgICByZXR1cm4gYCR7YWVzZ2NtLnVwZGF0ZShjaXBoZXJ0ZXh0KX0ke2Flc2djbS5maW5hbCgpfWBcbiAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICBjb25zdCBpc1JhbmdlID0gZXJyb3IgaW5zdGFuY2VvZiBSYW5nZUVycm9yXG4gICAgY29uc3QgaW52YWxpZEtleUxlbmd0aCA9IGVycm9yLm1lc3NhZ2UgPT09ICdJbnZhbGlkIGtleSBsZW5ndGgnXG4gICAgY29uc3QgZGVjcnlwdGlvbkZhaWxlZCA9IGVycm9yLm1lc3NhZ2UgPT09ICdVbnN1cHBvcnRlZCBzdGF0ZSBvciB1bmFibGUgdG8gYXV0aGVudGljYXRlIGRhdGEnXG5cbiAgICBpZiAoaXNSYW5nZSB8fCBpbnZhbGlkS2V5TGVuZ3RoKSB7XG4gICAgICBjb25zdCBlcnIgPSBuZXcgRXJyb3IoJ0lOVkFMSURfRE9URU5WX0tFWTogSXQgbXVzdCBiZSA2NCBjaGFyYWN0ZXJzIGxvbmcgKG9yIG1vcmUpJylcbiAgICAgIGVyci5jb2RlID0gJ0lOVkFMSURfRE9URU5WX0tFWSdcbiAgICAgIHRocm93IGVyclxuICAgIH0gZWxzZSBpZiAoZGVjcnlwdGlvbkZhaWxlZCkge1xuICAgICAgY29uc3QgZXJyID0gbmV3IEVycm9yKCdERUNSWVBUSU9OX0ZBSUxFRDogUGxlYXNlIGNoZWNrIHlvdXIgRE9URU5WX0tFWScpXG4gICAgICBlcnIuY29kZSA9ICdERUNSWVBUSU9OX0ZBSUxFRCdcbiAgICAgIHRocm93IGVyclxuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlcnJvclxuICAgIH1cbiAgfVxufVxuXG4vLyBQb3B1bGF0ZSBwcm9jZXNzLmVudiB3aXRoIHBhcnNlZCB2YWx1ZXNcbmZ1bmN0aW9uIHBvcHVsYXRlIChwcm9jZXNzRW52LCBwYXJzZWQsIG9wdGlvbnMgPSB7fSkge1xuICBjb25zdCBkZWJ1ZyA9IEJvb2xlYW4ob3B0aW9ucyAmJiBvcHRpb25zLmRlYnVnKVxuICBjb25zdCBvdmVycmlkZSA9IEJvb2xlYW4ob3B0aW9ucyAmJiBvcHRpb25zLm92ZXJyaWRlKVxuXG4gIGlmICh0eXBlb2YgcGFyc2VkICE9PSAnb2JqZWN0Jykge1xuICAgIGNvbnN0IGVyciA9IG5ldyBFcnJvcignT0JKRUNUX1JFUVVJUkVEOiBQbGVhc2UgY2hlY2sgdGhlIHByb2Nlc3NFbnYgYXJndW1lbnQgYmVpbmcgcGFzc2VkIHRvIHBvcHVsYXRlJylcbiAgICBlcnIuY29kZSA9ICdPQkpFQ1RfUkVRVUlSRUQnXG4gICAgdGhyb3cgZXJyXG4gIH1cblxuICAvLyBTZXQgcHJvY2Vzcy5lbnZcbiAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMocGFyc2VkKSkge1xuICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocHJvY2Vzc0Vudiwga2V5KSkge1xuICAgICAgaWYgKG92ZXJyaWRlID09PSB0cnVlKSB7XG4gICAgICAgIHByb2Nlc3NFbnZba2V5XSA9IHBhcnNlZFtrZXldXG4gICAgICB9XG5cbiAgICAgIGlmIChkZWJ1Zykge1xuICAgICAgICBpZiAob3ZlcnJpZGUgPT09IHRydWUpIHtcbiAgICAgICAgICBfZGVidWcoYFwiJHtrZXl9XCIgaXMgYWxyZWFkeSBkZWZpbmVkIGFuZCBXQVMgb3ZlcndyaXR0ZW5gKVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIF9kZWJ1ZyhgXCIke2tleX1cIiBpcyBhbHJlYWR5IGRlZmluZWQgYW5kIHdhcyBOT1Qgb3ZlcndyaXR0ZW5gKVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHByb2Nlc3NFbnZba2V5XSA9IHBhcnNlZFtrZXldXG4gICAgfVxuICB9XG59XG5cbmNvbnN0IERvdGVudk1vZHVsZSA9IHtcbiAgY29uZmlnRG90ZW52LFxuICBfY29uZmlnVmF1bHQsXG4gIF9wYXJzZVZhdWx0LFxuICBjb25maWcsXG4gIGRlY3J5cHQsXG4gIHBhcnNlLFxuICBwb3B1bGF0ZVxufVxuXG5tb2R1bGUuZXhwb3J0cy5jb25maWdEb3RlbnYgPSBEb3RlbnZNb2R1bGUuY29uZmlnRG90ZW52XG5tb2R1bGUuZXhwb3J0cy5fY29uZmlnVmF1bHQgPSBEb3RlbnZNb2R1bGUuX2NvbmZpZ1ZhdWx0XG5tb2R1bGUuZXhwb3J0cy5fcGFyc2VWYXVsdCA9IERvdGVudk1vZHVsZS5fcGFyc2VWYXVsdFxubW9kdWxlLmV4cG9ydHMuY29uZmlnID0gRG90ZW52TW9kdWxlLmNvbmZpZ1xubW9kdWxlLmV4cG9ydHMuZGVjcnlwdCA9IERvdGVudk1vZHVsZS5kZWNyeXB0XG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IERvdGVudk1vZHVsZS5wYXJzZVxubW9kdWxlLmV4cG9ydHMucG9wdWxhdGUgPSBEb3RlbnZNb2R1bGUucG9wdWxhdGVcblxubW9kdWxlLmV4cG9ydHMgPSBEb3RlbnZNb2R1bGVcbiIsICJpbXBvcnQgR3JvcSBmcm9tIFwiZ3JvcS1zZGtcIjtcbmltcG9ydCB7IGFyb3VuZCB9IGZyb20gXCJtb25rZXktYXJvdW5kXCI7XG5pbXBvcnQgeyBDYW52YXMsIFZpZXdwb3J0Tm9kZSB9IGZyb20gXCIuL3R5cGVzXCI7XG5pbXBvcnQge1xuICAgIEFwcCxcbiAgICBFZGl0b3IsXG4gICAgTWFya2Rvd25WaWV3LFxuICAgIE1vZGFsLFxuICAgIE5vdGljZSxcbiAgICBQbHVnaW4sXG4gICAgUGx1Z2luU2V0dGluZ1RhYixcbiAgICBTZXR0aW5nLFxuICAgIEl0ZW1WaWV3LFxuICAgIFdvcmtzcGFjZUxlYWYsXG4gICAgc2V0VG9vbHRpcCxcbiAgICBzZXRJY29uLFxuICAgIFZpZXcsXG59IGZyb20gXCJvYnNpZGlhblwiO1xuaW1wb3J0IHtcbiAgICBOb2RlU2lkZSxcbiAgICBFZGdlRW5kLFxuICAgIENhbnZhc0NvbG9yLFxuICAgIENhbnZhc0RhdGEsXG4gICAgQ2FudmFzRWRnZURhdGEsXG4gICAgQ2FudmFzRmlsZURhdGEsXG4gICAgQ2FudmFzR3JvdXBEYXRhLFxuICAgIENhbnZhc0xpbmtEYXRhLFxuICAgIENhbnZhc05vZGVEYXRhLFxuICAgIENhbnZhc1RleHREYXRhLFxuICAgIEFsbENhbnZhc05vZGVEYXRhLFxufSBmcm9tIFwib2JzaWRpYW4vY2FudmFzXCI7XG5pbXBvcnQgeyBzeW50YXhUcmVlIH0gZnJvbSBcIkBjb2RlbWlycm9yL2xhbmd1YWdlXCI7XG5pbXBvcnQgeyBFeHRlbnNpb24sIFJhbmdlU2V0QnVpbGRlciwgU3RhdGVGaWVsZCwgVHJhbnNhY3Rpb24gfSBmcm9tIFwiQGNvZGVtaXJyb3Ivc3RhdGVcIjtcbmltcG9ydCB7IERlY29yYXRpb24sIERlY29yYXRpb25TZXQsIEVkaXRvclZpZXcsIFdpZGdldFR5cGUgfSBmcm9tIFwiQGNvZGVtaXJyb3Ivdmlld1wiO1xuaW1wb3J0ICogYXMgZG90ZW52IGZyb20gXCJkb3RlbnZcIjtcbi8vIGRvdGVudi5jb25maWcoeyBkZWJ1ZzogdHJ1ZX1cblxuY29uc3QgYmFzZVBhdGggPSBcIi9Vc2Vycy9qYWNvYmNvbGxpbmcvRG9jdW1lbnRzL2FjY2VsZXJhdGUvYWNjZWxlcmF0ZS9cIjtcblxuZG90ZW52LmNvbmZpZyh7XG4gICAgcGF0aDogYCR7YmFzZVBhdGh9Ly5vYnNpZGlhbi9wbHVnaW5zL2NhcmV0Ly5lbnZgLFxuICAgIGRlYnVnOiB0cnVlLFxufSk7XG5cbmNvbnN0IGdyb3FfYXBpX2tleSA9IHByb2Nlc3MuZW52LkdST1FfQVBJX0tFWTtcbmNvbnN0IGdyb3EgPSBuZXcgR3JvcSh7IGFwaUtleTogZ3JvcV9hcGlfa2V5LCBkYW5nZXJvdXNseUFsbG93QnJvd3NlcjogdHJ1ZSB9KTtcblxuLy8gU3RhcnQgb2Ygbm9kZSBhbmQgZWRnZSBmdW5jdGlvbnNcbmludGVyZmFjZSBlZGdlVCB7XG4gICAgZnJvbU9yVG86IHN0cmluZztcbiAgICBzaWRlOiBzdHJpbmc7XG4gICAgbm9kZTogQ2FudmFzTm9kZURhdGE7XG59XG5cbmludGVyZmFjZSBUcmVlTm9kZSB7XG4gICAgaWQ6IHN0cmluZztcbiAgICBjaGlsZHJlbjogVHJlZU5vZGVbXTtcbn1cblxuaW50ZXJmYWNlIE5vZGUge1xuICAgIGlkOiBzdHJpbmc7XG4gICAgdHlwZTogc3RyaW5nO1xuICAgIHRleHQ6IHN0cmluZztcbiAgICB4OiBudW1iZXI7XG4gICAgeTogbnVtYmVyO1xuICAgIHdpZHRoOiBudW1iZXI7XG4gICAgaGVpZ2h0OiBudW1iZXI7XG59XG5cbmludGVyZmFjZSBFZGdlIHtcbiAgICBpZDogc3RyaW5nO1xuICAgIGZyb21Ob2RlOiBzdHJpbmc7XG4gICAgZnJvbVNpZGU6IHN0cmluZztcbiAgICB0b05vZGU6IHN0cmluZztcbiAgICB0b1NpZGU6IHN0cmluZztcbn1cbmV4cG9ydCBjbGFzcyBDTURKTW9kYWwgZXh0ZW5kcyBNb2RhbCB7XG4gICAgcmVzdWx0OiBzdHJpbmc7XG4gICAgc2VsZWN0ZWRUZXh0OiBzdHJpbmc7XG4gICAgc3RhcnRJbmRleDogbnVtYmVyO1xuICAgIGVuZEluZGV4OiBudW1iZXI7XG5cbiAgICBjb25zdHJ1Y3RvcihhcHA6IEFwcCwgc2VsZWN0ZWRUZXh0OiBzdHJpbmcsIHN0YXJ0SW5kZXg6IG51bWJlciwgZW5kSW5kZXg6IG51bWJlcikge1xuICAgICAgICBzdXBlcihhcHApO1xuICAgICAgICB0aGlzLnNlbGVjdGVkVGV4dCA9IHNlbGVjdGVkVGV4dDtcbiAgICAgICAgdGhpcy5zdGFydEluZGV4ID0gc3RhcnRJbmRleDtcbiAgICAgICAgdGhpcy5lbmRJbmRleCA9IGVuZEluZGV4O1xuICAgIH1cblxuICAgIG9uT3BlbigpIHtcbiAgICAgICAgY29uc3QgeyBjb250ZW50RWwgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHRleHREaXNwbGF5ID0gY29udGVudEVsLmNyZWF0ZUVsKFwiZGl2XCIsIHtcbiAgICAgICAgICAgIHRleHQ6IHRoaXMuc2VsZWN0ZWRUZXh0LFxuICAgICAgICB9KTtcbiAgICAgICAgdGV4dERpc3BsYXkuc3R5bGUuaGVpZ2h0ID0gXCI2MHB4XCI7XG4gICAgICAgIHRleHREaXNwbGF5LnN0eWxlLm92ZXJmbG93ID0gXCJzY3JvbGxcIjtcblxuICAgICAgICBjb250ZW50RWwuY3JlYXRlRWwoXCJiclwiKTsgLy8gTGluZSBicmVha1xuXG4gICAgICAgIGNvbnN0IHRleHRBcmVhID0gY29udGVudEVsLmNyZWF0ZUVsKFwidGV4dGFyZWFcIiwge1xuICAgICAgICAgICAgcGxhY2Vob2xkZXI6IFwiVHlwZSBoZXJlLi4uXCIsXG4gICAgICAgIH0pO1xuICAgICAgICB0ZXh0QXJlYS5zdHlsZS53aWR0aCA9IFwiMTAwJVwiO1xuICAgICAgICB0ZXh0QXJlYS5zdHlsZS5taW5IZWlnaHQgPSBcIjEwMHB4XCI7XG4gICAgICAgIHRleHRBcmVhLnN0eWxlLnJlc2l6ZSA9IFwibm9uZVwiO1xuICAgICAgICB0ZXh0QXJlYS5vbmlucHV0ID0gKCkgPT4ge1xuICAgICAgICAgICAgdGV4dEFyZWEuc3R5bGUuaGVpZ2h0ID0gXCJcIjsgLy8gUmVzZXQgdGhlIGhlaWdodFxuICAgICAgICAgICAgdGV4dEFyZWEuc3R5bGUuaGVpZ2h0ID0gYCR7dGV4dEFyZWEuc2Nyb2xsSGVpZ2h0fXB4YDtcbiAgICAgICAgfTtcblxuICAgICAgICBjb25zdCBidXR0b25Db250YWluZXIgPSBjb250ZW50RWwuY3JlYXRlRWwoXCJkaXZcIiwgeyBjbHM6IFwiYnV0dG9uLWNvbnRhaW5lclwiIH0pO1xuICAgICAgICAvLyBidXR0b25Db250YWluZXIuc3R5bGUuZGlzcGxheSA9IFwiZmxleFwiO1xuICAgICAgICAvLyBidXR0b25Db250YWluZXIuc3R5bGUuanVzdGlmeUNvbnRlbnQgPSBcInNwYWNlLWJldHdlZW5cIjsgLy8gVGhpcyB3aWxsIHNwYWNlIHRoZSBidXR0b25zIGV2ZW5seVxuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgXCJBcHBlbmQgT3V0cHV0XCIgYnV0dG9uXG4gICAgICAgIG5ldyBTZXR0aW5nKGJ1dHRvbkNvbnRhaW5lcilcbiAgICAgICAgICAgIC5hZGRCdXR0b24oKGJ0bikgPT5cbiAgICAgICAgICAgICAgICBidG5cbiAgICAgICAgICAgICAgICAgICAgLnNldEJ1dHRvblRleHQoXCJBcHBlbmQgT3V0cHV0XCIpXG5cbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB0ZXh0QXJlYS52YWx1ZTsgLy8gQ2FwdHVyZSB0aGUgdmFsdWUgZnJvbSB0aGUgdGV4dGFyZWFcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IHRoaXMuc3VibWl0X2VkaXQodGhpcy5yZXN1bHQpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRfcmVzcG9uc2UoY29udGVudCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgICAuYWRkQnV0dG9uKChidG4pID0+XG4gICAgICAgICAgICAgICAgYnRuXG4gICAgICAgICAgICAgICAgICAgIC5zZXRCdXR0b25UZXh0KFwiUmVwbGFjZVwiKVxuICAgICAgICAgICAgICAgICAgICAuc2V0Q3RhKClcbiAgICAgICAgICAgICAgICAgICAgLm9uQ2xpY2soYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXN1bHQgPSB0ZXh0QXJlYS52YWx1ZTsgLy8gQ2FwdHVyZSB0aGUgdmFsdWUgZnJvbSB0aGUgdGV4dGFyZWFcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBhd2FpdCB0aGlzLnN1Ym1pdF9lZGl0KHRoaXMucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwbHlfZGVsZXRlKHRoaXMucmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuaW5zZXJ0X3Jlc3BvbnNlKGNvbnRlbnQsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICB9XG5cbiAgICBhc3luYyBzdWJtaXRfZWRpdChyZXN1bHQ6IHN0cmluZykge1xuICAgICAgICBsZXQgbWVzc2FnZSA9IGBcblBsZWFzZSBhcHBseSB0aGUgZm9sbG93aW5nIGluc3RydWN0aW9ucyB0byB0aGUgYmVsb3cgY29udGVudDpcblxuSW5zdHJ1Y3Rpb25zOlxuJHt0aGlzLnJlc3VsdH1cblxuQ29udGVudDpcbiR7dGhpcy5zZWxlY3RlZFRleHR9XG5cbiMjIFJ1bGVzOlxuLSBKdXN0IHJldHVybiB0aGUgcmVwb25zZSB0aGF0IGZvbGxvd3MgdGhlIGluc3RydWN0aW9ucy4gTm8gbmVlZCB0byBpbmNsdWRlIGEgcHJlYW1wbGUgb3IgYW55dGhpbmdcblxuIyMgTWFya2Rvd24gRm9ybWF0dGluZzogXG5BbHdheXMgYXBwbHkgbWFya2Rvd24gZm9ybWF0dGluZy4gRm9yIGtleXdvcmRzIHVzZSB0aGUgZm9sbG93aW5nOlxuXHR0b2RvcyAtIFByZXBlbmQgdG9kbyBsaW5lcyB3aXRoOlxuXHQtIFsgXSBcbmAudHJpbSgpO1xuXG4gICAgICAgIGNvbnN0IGRhdGEgPSB7IG1lc3NhZ2UgfTtcbiAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IGZldGNoKFwiaHR0cDovL2xvY2FsaG9zdDo4MDAwL3NpbmdsZS10dXJuXCIsIHtcbiAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICBoZWFkZXJzOiB7XG4gICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgYm9keTogSlNPTi5zdHJpbmdpZnkoZGF0YSksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCByZXNwLmpzb24oKTtcbiAgICAgICAgcmV0dXJuIG91dHB1dC5jb250ZW50O1xuICAgIH1cblxuICAgIGluc2VydF9yZXNwb25zZShyZXNwb25zZTogc3RyaW5nLCByZXBsYWNlOiBib29sZWFuID0gZmFsc2UpIHtcbiAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KT8uZWRpdG9yO1xuICAgICAgICBpZiAoZWRpdG9yKSB7XG4gICAgICAgICAgICBsZXQgaW5kZXggPSB0aGlzLmVuZEluZGV4O1xuICAgICAgICAgICAgaWYgKHJlcGxhY2UpIHtcbiAgICAgICAgICAgICAgICBpbmRleCA9IGluZGV4ICsgNDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IHBvcyA9IGVkaXRvci5vZmZzZXRUb1BvcyhpbmRleCk7XG4gICAgICAgICAgICBlZGl0b3IucmVwbGFjZVJhbmdlKGBcXG58KyR7cmVzcG9uc2V9K3xgLCBwb3MpO1xuICAgICAgICAgICAgZWRpdG9yLnNldEN1cnNvcihwb3MpOyAvLyBPcHRpb25hbGx5IHNldCB0aGUgY3Vyc29yIGFmdGVyIHRoZSBpbnNlcnRlZCB0ZXh0XG4gICAgICAgICAgICBlZGl0b3IuZm9jdXMoKTsgLy8gRm9jdXMgdGhlIGVkaXRvciBhZnRlciBpbnNlcnRpbmcgdGV4dFxuICAgICAgICB9XG4gICAgfVxuXG4gICAgYXBwbHlfZGVsZXRlKHRleHQ6IHN0cmluZykge1xuICAgICAgICBjb25zdCBlZGl0b3IgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0QWN0aXZlVmlld09mVHlwZShNYXJrZG93blZpZXcpPy5lZGl0b3I7XG4gICAgICAgIGlmIChlZGl0b3IpIHtcbiAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBlZGl0b3IuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gY29udGVudC5pbmRleE9mKHRoaXMuc2VsZWN0ZWRUZXh0KTtcbiAgICAgICAgICAgIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBiZWZvcmVUZXh0ID0gY29udGVudC5zdWJzdHJpbmcoMCwgaW5kZXgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGFmdGVyVGV4dCA9IGNvbnRlbnQuc3Vic3RyaW5nKGluZGV4ICsgdGhpcy5zZWxlY3RlZFRleHQubGVuZ3RoKTtcbiAgICAgICAgICAgICAgICBjb25zdCBuZXdUZXh0ID0gYmVmb3JlVGV4dCArIGB8LSR7dGhpcy5zZWxlY3RlZFRleHR9LXxgICsgYWZ0ZXJUZXh0O1xuICAgICAgICAgICAgICAgIGVkaXRvci5zZXRWYWx1ZShuZXdUZXh0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIG9uQ2xvc2UoKSB7XG4gICAgICAgIGxldCB7IGNvbnRlbnRFbCB9ID0gdGhpcztcbiAgICAgICAgY29udGVudEVsLmVtcHR5KCk7XG4gICAgfVxufVxuXG5leHBvcnQgY29uc3QgcmVkQmFja2dyb3VuZEZpZWxkID0gU3RhdGVGaWVsZC5kZWZpbmU8RGVjb3JhdGlvblNldD4oe1xuICAgIGNyZWF0ZShzdGF0ZSk6IERlY29yYXRpb25TZXQge1xuICAgICAgICByZXR1cm4gRGVjb3JhdGlvbi5ub25lO1xuICAgIH0sXG4gICAgdXBkYXRlKG9sZFN0YXRlOiBEZWNvcmF0aW9uU2V0LCB0cmFuc2FjdGlvbjogVHJhbnNhY3Rpb24pOiBEZWNvcmF0aW9uU2V0IHtcbiAgICAgICAgY29uc3QgYnVpbGRlciA9IG5ldyBSYW5nZVNldEJ1aWxkZXI8RGVjb3JhdGlvbj4oKTtcbiAgICAgICAgY29uc3QgZG9jVGV4dCA9IHRyYW5zYWN0aW9uLnN0YXRlLmRvYy50b1N0cmluZygpO1xuICAgICAgICBjb25zdCBkZWxldGVfcmVnZXggPSAvXFx8LSguKj8pLVxcfC9nczsgLy8gQ2hhbmdlZCB0byBtYXRjaCBhY3Jvc3MgbGluZXNcbiAgICAgICAgY29uc3QgYWRkX3JlZ2V4ID0gL1xcfFxcKyguKj8pXFwrXFx8L2dzOyAvLyBDaGFuZ2VkIHRvIG1hdGNoIGFjcm9zcyBsaW5lc1xuICAgICAgICBsZXQgZGVsZXRlX21hdGNoO1xuICAgICAgICBsZXQgYWRkX21hdGNoO1xuICAgICAgICBsZXQgcmFuZ2VzID0gW107XG5cbiAgICAgICAgd2hpbGUgKChkZWxldGVfbWF0Y2ggPSBkZWxldGVfcmVnZXguZXhlYyhkb2NUZXh0KSkgIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gZGVsZXRlX21hdGNoLmluZGV4O1xuICAgICAgICAgICAgY29uc3QgZW5kID0gZGVsZXRlX3JlZ2V4Lmxhc3RJbmRleDtcbiAgICAgICAgICAgIHJhbmdlcy5wdXNoKHsgc3RhcnQsIGVuZCwgc3R5bGU6IFwiYmFja2dyb3VuZC1jb2xvcjogI2Y1NmM2MjtcIiB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHdoaWxlICgoYWRkX21hdGNoID0gYWRkX3JlZ2V4LmV4ZWMoZG9jVGV4dCkpICE9PSBudWxsKSB7XG4gICAgICAgICAgICBjb25zdCBzdGFydCA9IGFkZF9tYXRjaC5pbmRleDtcbiAgICAgICAgICAgIGNvbnN0IGVuZCA9IGFkZF9yZWdleC5sYXN0SW5kZXg7XG4gICAgICAgICAgICByYW5nZXMucHVzaCh7IHN0YXJ0LCBlbmQsIHN0eWxlOiBcImJhY2tncm91bmQtY29sb3I6ICM2NGY1NjI7XCIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gU29ydCByYW5nZXMgYnkgc3RhcnQgcG9zaXRpb25cbiAgICAgICAgcmFuZ2VzLnNvcnQoKGEsIGIpID0+IGEuc3RhcnQgLSBiLnN0YXJ0KTtcblxuICAgICAgICAvLyBBZGQgc29ydGVkIHJhbmdlcyB0byB0aGUgYnVpbGRlclxuICAgICAgICByYW5nZXMuZm9yRWFjaCgocmFuZ2UpID0+IHtcbiAgICAgICAgICAgIGJ1aWxkZXIuYWRkKFxuICAgICAgICAgICAgICAgIHJhbmdlLnN0YXJ0LFxuICAgICAgICAgICAgICAgIHJhbmdlLmVuZCxcbiAgICAgICAgICAgICAgICBEZWNvcmF0aW9uLm1hcmsoe1xuICAgICAgICAgICAgICAgICAgICBhdHRyaWJ1dGVzOiB7IHN0eWxlOiByYW5nZS5zdHlsZSB9LFxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApO1xuICAgICAgICB9KTtcblxuICAgICAgICByZXR1cm4gYnVpbGRlci5maW5pc2goKTtcbiAgICB9LFxuICAgIHByb3ZpZGUoZmllbGQ6IFN0YXRlRmllbGQ8RGVjb3JhdGlvblNldD4pOiBFeHRlbnNpb24ge1xuICAgICAgICByZXR1cm4gRWRpdG9yVmlldy5kZWNvcmF0aW9ucy5mcm9tKGZpZWxkKTtcbiAgICB9LFxufSk7XG4vLyBSZW1lbWJlciB0byByZW5hbWUgdGhlc2UgY2xhc3NlcyBhbmQgaW50ZXJmYWNlcyFcblxuaW50ZXJmYWNlIE15UGx1Z2luU2V0dGluZ3Mge1xuICAgIG15U2V0dGluZzogc3RyaW5nO1xufVxuXG5jb25zdCBERUZBVUxUX1NFVFRJTkdTOiBNeVBsdWdpblNldHRpbmdzID0ge1xuICAgIG15U2V0dGluZzogXCJkZWZhdWx0XCIsXG59O1xuXG5leHBvcnQgY29uc3QgVklFV19OQU1FX1NJREVCQVJfQ0hBVCA9IFwic2lkZWJhci1jYXJldFwiO1xuY2xhc3MgU2lkZWJhckNoYXQgZXh0ZW5kcyBJdGVtVmlldyB7XG4gICAgY29uc3RydWN0b3IobGVhZjogV29ya3NwYWNlTGVhZikge1xuICAgICAgICBzdXBlcihsZWFmKTtcbiAgICB9XG4gICAgdGV4dEJveDogSFRNTFRleHRBcmVhRWxlbWVudDtcbiAgICBtZXNzYWdlc0NvbnRhaW5lcjogSFRNTEVsZW1lbnQ7IC8vIENvbnRhaW5lciBmb3IgbWVzc2FnZXNcblxuICAgIGdldFZpZXdUeXBlKCkge1xuICAgICAgICByZXR1cm4gVklFV19OQU1FX1NJREVCQVJfQ0hBVDtcbiAgICB9XG5cbiAgICBnZXREaXNwbGF5VGV4dCgpIHtcbiAgICAgICAgcmV0dXJuIFZJRVdfTkFNRV9TSURFQkFSX0NIQVQ7XG4gICAgfVxuXG4gICAgYXN5bmMgb25PcGVuKCkge1xuICAgICAgICBjb25zdCBtZXRhY29udGFpbmVyID0gdGhpcy5jb250YWluZXJFbC5jaGlsZHJlblsxXTtcbiAgICAgICAgbWV0YWNvbnRhaW5lci5lbXB0eSgpO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBtZXRhY29udGFpbmVyLmNyZWF0ZUVsKFwiZGl2XCIsIHtcbiAgICAgICAgICAgIGNsczogXCJjb250YWluZXJcIixcbiAgICAgICAgfSk7XG4gICAgICAgIG1ldGFjb250YWluZXIucHJlcGVuZChjb250YWluZXIpO1xuICAgICAgICAvLyB0aGlzLmNvbnRhaW5lckVsLmFwcGVuZENoaWxkKGNvbnRhaW5lcik7XG5cbiAgICAgICAgLy8gQ3JlYXRlIGEgY29udGFpbmVyIGZvciBtZXNzYWdlc1xuICAgICAgICB0aGlzLm1lc3NhZ2VzQ29udGFpbmVyID0gY29udGFpbmVyLmNyZWF0ZUVsKFwiZGl2XCIsIHtcbiAgICAgICAgICAgIGNsczogXCJtZXNzYWdlcy1jb250YWluZXJcIixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQWRkIGEgXCJIZWxsbyBXb3JsZFwiIG1lc3NhZ2VcbiAgICAgICAgdGhpcy5hZGRNZXNzYWdlKFwiTUxYIFRlc3RpbmdcIiwgXCJzeXN0ZW1cIik7XG4gICAgICAgIHRoaXMuY3JlYXRlQ2hhdElucHV0QXJlYShjb250YWluZXIpO1xuICAgIH1cbiAgICBjcmVhdGVDaGF0SW5wdXRBcmVhKGNvbnRhaW5lcjogSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgLy8gQ3JlYXRlIGEgY29udGFpbmVyIGZvciB0aGUgdGV4dCBib3ggYW5kIHRoZSBzdWJtaXQgYnV0dG9uXG4gICAgICAgIGNvbnN0IGlucHV0Q29udGFpbmVyID0gY29udGFpbmVyLmNyZWF0ZUVsKFwiZGl2XCIsIHtcbiAgICAgICAgICAgIGNsczogXCJjaGF0LWlucHV0LWNvbnRhaW5lclwiLFxuICAgICAgICB9KTtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIHRleHQgYm94IHdpdGhpbiB0aGUgaW5wdXQgY29udGFpbmVyXG4gICAgICAgIHRoaXMudGV4dEJveCA9IGlucHV0Q29udGFpbmVyLmNyZWF0ZUVsKFwidGV4dGFyZWFcIiwge1xuICAgICAgICAgICAgY2xzOiBcImZ1bGxfd2lkdGhfdGV4dF9jb250YWluZXJcIixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudGV4dEJveC5wbGFjZWhvbGRlciA9IFwiVHlwZSBzb21ldGhpbmcuLi5cIjtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIHN1Ym1pdCBidXR0b24gd2l0aGluIHRoZSBpbnB1dCBjb250YWluZXJcbiAgICAgICAgY29uc3QgYnV0dG9uID0gaW5wdXRDb250YWluZXIuY3JlYXRlRWwoXCJidXR0b25cIik7XG4gICAgICAgIGJ1dHRvbi50ZXh0Q29udGVudCA9IFwiU3VibWl0XCI7XG4gICAgICAgIGJ1dHRvbi5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhpcy5zdWJtaXRNZXNzYWdlKHRoaXMudGV4dEJveC52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLnRleHRCb3gudmFsdWUgPSBcIlwiOyAvLyBDbGVhciB0aGUgdGV4dCBib3ggYWZ0ZXIgc2VuZGluZ1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhZGRNZXNzYWdlKHRleHQ6IHN0cmluZywgc2VuZGVyOiBcInVzZXJcIiB8IFwic3lzdGVtXCIpIHtcbiAgICAgICAgY29uc3QgbWVzc2FnZURpdiA9IHRoaXMubWVzc2FnZXNDb250YWluZXIuY3JlYXRlRWwoXCJkaXZcIiwge1xuICAgICAgICAgICAgY2xzOiBgbWVzc2FnZSAke3NlbmRlcn1gLFxuICAgICAgICB9KTtcbiAgICAgICAgbWVzc2FnZURpdi50ZXh0Q29udGVudCA9IHRleHQ7XG4gICAgfVxuXG4gICAgc3VibWl0TWVzc2FnZSh1c2VyTWVzc2FnZTogc3RyaW5nKSB7XG4gICAgICAgIGxldCBjdXJyZW50X3BhZ2VfY29udGVudCA9IFwiXCI7XG4gICAgICAgIGlmICh1c2VyTWVzc2FnZS5pbmNsdWRlcyhcIkBjdXJyZW50XCIpKSB7XG4gICAgICAgICAgICAvLyBGaW5kIHRoZSBmaXJzdCBNYXJrZG93blZpZXcgdGhhdCBpcyBvcGVuIGluIHRoZSB3b3Jrc3BhY2VcbiAgICAgICAgICAgIGNvbnN0IG1hcmtkb3duVmlldyA9IHRoaXMuYXBwLndvcmtzcGFjZVxuICAgICAgICAgICAgICAgIC5nZXRMZWF2ZXNPZlR5cGUoXCJtYXJrZG93blwiKVxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAuZmluZCgobGVhZikgPT4gbGVhZi52aWV3IGluc3RhbmNlb2YgTWFya2Rvd25WaWV3ICYmIGxlYWYud2lkdGggPiAwKT8udmlldyBhcyBNYXJrZG93blZpZXc7XG4gICAgICAgICAgICBpZiAobWFya2Rvd25WaWV3ICYmIG1hcmtkb3duVmlldy5lZGl0b3IpIHtcbiAgICAgICAgICAgICAgICBjdXJyZW50X3BhZ2VfY29udGVudCA9IG1hcmtkb3duVmlldy5lZGl0b3IuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLmFkZE1lc3NhZ2UodXNlck1lc3NhZ2UsIFwidXNlclwiKTsgLy8gRGlzcGxheSB0aGUgdXNlciBtZXNzYWdlIGltbWVkaWF0ZWx5XG5cbiAgICAgICAgY29uc3QgY3VycmVudF9wYWdlX21lc3NhZ2UgPSBgXG5cdFx0JHt1c2VyTWVzc2FnZX1cblxuXHRcdC0tLS0tLSBOb3RlIGZvciBNb2RlbCAtLS0gXG5cdFx0V2hlbiBJIGFtIHJlZmVycmluZyB0byBAY3VycmVudCwgSSBtZWFudCB0aGUgZm9sbG93aW5nOlxuXG5cdFx0JHtjdXJyZW50X3BhZ2VfY29udGVudH1cblx0XHRgO1xuXG4gICAgICAgIGxldCBmaW5hbF9tZXNzYWdlID0gdXNlck1lc3NhZ2U7XG4gICAgICAgIGlmIChjdXJyZW50X3BhZ2VfY29udGVudC5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBmaW5hbF9tZXNzYWdlID0gY3VycmVudF9wYWdlX21lc3NhZ2U7XG4gICAgICAgIH1cblxuICAgICAgICBjb25zdCBkYXRhID0geyBtZXNzYWdlOiBmaW5hbF9tZXNzYWdlIH07XG4gICAgICAgIGZldGNoKFwiaHR0cDovL2xvY2FsaG9zdDo4MDAwL2NvbnZlcnNhdGlvblwiLCB7XG4gICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgIFwiQ29udGVudC1UeXBlXCI6IFwiYXBwbGljYXRpb24vanNvblwiLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICB9KVxuICAgICAgICAgICAgLnRoZW4oKHJlc3BvbnNlKSA9PiByZXNwb25zZS5qc29uKCkpXG4gICAgICAgICAgICAudGhlbigoZGF0YSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMuYWRkTWVzc2FnZShkYXRhLnJlc3BvbnNlLCBcInN5c3RlbVwiKTsgLy8gRGlzcGxheSB0aGUgcmVzcG9uc2VcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAuY2F0Y2goKGVycm9yKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVycm9yOlwiLCBlcnJvcik7XG4gICAgICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBvbkNsb3NlKCkge1xuICAgICAgICAvLyBDbGVhbnVwIGxvZ2ljIGlmIG5lY2Vzc2FyeVxuICAgIH1cbn1cblxuZXhwb3J0IGNvbnN0IFZJRVdfTkFNRV9NQUlOX0NIQVQgPSBcIm1haW4tY2FyZXRcIjtcbmNsYXNzIE1haW5DaGF0IGV4dGVuZHMgSXRlbVZpZXcge1xuICAgIGNoYXRfaWQ6IHN0cmluZztcbiAgICBjb25zdHJ1Y3RvcihcbiAgICAgICAgbGVhZjogV29ya3NwYWNlTGVhZixcbiAgICAgICAgY2hhdF9pZD86IHN0cmluZyxcbiAgICAgICAgY29udmVyc2F0aW9uOiB7IGNvbnRlbnQ6IHN0cmluZzsgcm9sZTogXCJ1c2VyXCIgfCBcInN5c3RlbVwiIH1bXSA9IFtdXG4gICAgKSB7XG4gICAgICAgIHN1cGVyKGxlYWYpO1xuICAgICAgICB0aGlzLmNoYXRfaWQgPSBjaGF0X2lkIHx8IHRoaXMuZ2VuZXJhdGVSYW5kb21JRCg1KTtcbiAgICAgICAgdGhpcy5jb252ZXJzYXRpb24gPSBjb252ZXJzYXRpb247IC8vIEluaXRpYWxpemUgY29udmVyc2F0aW9uIGxpc3Qgd2l0aCBkZWZhdWx0IG9yIHBhc3NlZCB2YWx1ZVxuICAgIH1cbiAgICB0ZXh0Qm94OiBIVE1MVGV4dEFyZWFFbGVtZW50O1xuICAgIG1lc3NhZ2VzQ29udGFpbmVyOiBIVE1MRWxlbWVudDsgLy8gQ29udGFpbmVyIGZvciBtZXNzYWdlc1xuICAgIGNvbnZlcnNhdGlvbjogeyBjb250ZW50OiBzdHJpbmc7IHJvbGU6IFwidXNlclwiIHwgXCJzeXN0ZW1cIiB9W107IC8vIExpc3QgdG8gc3RvcmUgY29udmVyc2F0aW9uIG1lc3NhZ2VzXG5cbiAgICBnZXRWaWV3VHlwZSgpIHtcbiAgICAgICAgcmV0dXJuIFZJRVdfTkFNRV9NQUlOX0NIQVQ7XG4gICAgfVxuXG4gICAgZ2V0RGlzcGxheVRleHQoKSB7XG4gICAgICAgIHJldHVybiBgTUxYIExvY2FsIENoYXQ6ICR7dGhpcy5jaGF0X2lkfWA7XG4gICAgfVxuXG4gICAgYXN5bmMgb25PcGVuKCkge1xuICAgICAgICBjb25zdCBtZXRhY29udGFpbmVyID0gdGhpcy5jb250YWluZXJFbC5jaGlsZHJlblsxXTtcbiAgICAgICAgbWV0YWNvbnRhaW5lci5lbXB0eSgpO1xuICAgICAgICBjb25zdCBjb250YWluZXIgPSBtZXRhY29udGFpbmVyLmNyZWF0ZUVsKFwiZGl2XCIsIHtcbiAgICAgICAgICAgIGNsczogXCJjb250YWluZXJcIixcbiAgICAgICAgfSk7XG4gICAgICAgIG1ldGFjb250YWluZXIucHJlcGVuZChjb250YWluZXIpO1xuXG4gICAgICAgIC8vIENyZWF0ZSBhIGNvbnRhaW5lciBmb3IgbWVzc2FnZXNcbiAgICAgICAgdGhpcy5tZXNzYWdlc0NvbnRhaW5lciA9IGNvbnRhaW5lci5jcmVhdGVFbChcImRpdlwiLCB7XG4gICAgICAgICAgICBjbHM6IFwibWVzc2FnZXMtY29udGFpbmVyXCIsXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlbmRlciBpbml0aWFsIGNvbnZlcnNhdGlvblxuICAgICAgICB0aGlzLnJlbmRlckNvbnZlcnNhdGlvbigpO1xuICAgICAgICB0aGlzLmNyZWF0ZUNoYXRJbnB1dEFyZWEoY29udGFpbmVyKTtcbiAgICB9XG4gICAgY3JlYXRlQ2hhdElucHV0QXJlYShjb250YWluZXI6IEhUTUxFbGVtZW50KSB7XG4gICAgICAgIC8vIENyZWF0ZSBhIGNvbnRhaW5lciBmb3IgdGhlIHRleHQgYm94XG4gICAgICAgIGNvbnN0IGlucHV0Q29udGFpbmVyID0gY29udGFpbmVyLmNyZWF0ZUVsKFwiZGl2XCIsIHt9KTtcblxuICAgICAgICAvLyBDcmVhdGUgdGhlIHRleHQgYm94IHdpdGhpbiB0aGUgaW5wdXQgY29udGFpbmVyXG4gICAgICAgIHRoaXMudGV4dEJveCA9IGlucHV0Q29udGFpbmVyLmNyZWF0ZUVsKFwidGV4dGFyZWFcIiwge1xuICAgICAgICAgICAgY2xzOiBcImZ1bGxfd2lkdGhfdGV4dF9jb250YWluZXJcIixcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMudGV4dEJveC5wbGFjZWhvbGRlciA9IFwiVHlwZSBzb21ldGhpbmcuLi5cIjtcblxuICAgICAgICAvLyBDcmVhdGUgYSBzZXBhcmF0ZSBjb250YWluZXIgZm9yIGJ1dHRvbnMgd2l0aGluIHRoZSBpbnB1dCBjb250YWluZXJcbiAgICAgICAgY29uc3QgYnV0dG9uQ29udGFpbmVyID0gaW5wdXRDb250YWluZXIuY3JlYXRlRWwoXCJkaXZcIiwge1xuICAgICAgICAgICAgY2xzOiBcImJ1dHRvbi1jb250YWluZXJcIixcbiAgICAgICAgfSk7XG5cbiAgICAgICAgLy8gQ3JlYXRlIHRoZSBzYXZlIGJ1dHRvbiB3aXRoaW4gdGhlIGJ1dHRvbiBjb250YWluZXJcbiAgICAgICAgY29uc3Qgc2F2ZUJ1dHRvbiA9IGJ1dHRvbkNvbnRhaW5lci5jcmVhdGVFbChcImJ1dHRvblwiKTtcbiAgICAgICAgc2F2ZUJ1dHRvbi50ZXh0Q29udGVudCA9IFwiU2F2ZSBDaGF0XCI7XG4gICAgICAgIHNhdmVCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc2F2ZUNoYXQoKTsgLy8gQ2FsbCB0aGUgc2F2ZUNoYXQgZnVuY3Rpb24gdG8gc2F2ZSB0aGUgY29udmVyc2F0aW9uXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIENyZWF0ZSB0aGUgc3VibWl0IGJ1dHRvbiB3aXRoaW4gdGhlIGJ1dHRvbiBjb250YWluZXJcbiAgICAgICAgY29uc3Qgc3VibWl0QnV0dG9uID0gYnV0dG9uQ29udGFpbmVyLmNyZWF0ZUVsKFwiYnV0dG9uXCIpO1xuICAgICAgICBzdWJtaXRCdXR0b24udGV4dENvbnRlbnQgPSBcIlN1Ym1pdFwiO1xuICAgICAgICBzdWJtaXRCdXR0b24uYWRkRXZlbnRMaXN0ZW5lcihcImNsaWNrXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoaXMuc3VibWl0TWVzc2FnZSh0aGlzLnRleHRCb3gudmFsdWUpO1xuICAgICAgICAgICAgdGhpcy50ZXh0Qm94LnZhbHVlID0gXCJcIjsgLy8gQ2xlYXIgdGhlIHRleHQgYm94IGFmdGVyIHNlbmRpbmdcbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgYWRkTWVzc2FnZSh0ZXh0OiBzdHJpbmcsIHNlbmRlcjogXCJ1c2VyXCIgfCBcInN5c3RlbVwiKSB7XG4gICAgICAgIC8vIEFkZCBtZXNzYWdlIHRvIHRoZSBjb252ZXJzYXRpb24gYXJyYXlcbiAgICAgICAgdGhpcy5jb252ZXJzYXRpb24ucHVzaCh7IGNvbnRlbnQ6IHRleHQsIHJvbGU6IHNlbmRlciB9KTtcbiAgICAgICAgLy8gUmUtcmVuZGVyIHRoZSBjb252ZXJzYXRpb24gaW4gdGhlIEhUTUxcbiAgICAgICAgdGhpcy5yZW5kZXJDb252ZXJzYXRpb24oKTtcbiAgICB9XG5cbiAgICByZW5kZXJDb252ZXJzYXRpb24oKSB7XG4gICAgICAgIC8vIENsZWFyIHRoZSBjdXJyZW50IG1lc3NhZ2VzXG4gICAgICAgIHRoaXMubWVzc2FnZXNDb250YWluZXIuZW1wdHkoKTtcblxuICAgICAgICAvLyBBZGQgZWFjaCBtZXNzYWdlIGluIHRoZSBjb252ZXJzYXRpb24gdG8gdGhlIG1lc3NhZ2VzIGNvbnRhaW5lclxuICAgICAgICB0aGlzLmNvbnZlcnNhdGlvbi5mb3JFYWNoKChtZXNzYWdlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBtZXNzYWdlRGl2ID0gdGhpcy5tZXNzYWdlc0NvbnRhaW5lci5jcmVhdGVFbChcImRpdlwiLCB7XG4gICAgICAgICAgICAgICAgY2xzOiBgbWVzc2FnZSAke21lc3NhZ2Uucm9sZX1gLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBtZXNzYWdlRGl2LnRleHRDb250ZW50ID0gbWVzc2FnZS5jb250ZW50O1xuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBhc3luYyBzdWJtaXRNZXNzYWdlKHVzZXJNZXNzYWdlOiBzdHJpbmcpIHtcbiAgICAgICAgdGhpcy5hZGRNZXNzYWdlKHVzZXJNZXNzYWdlLCBcInVzZXJcIik7IC8vIERpc3BsYXkgdGhlIHVzZXIgbWVzc2FnZSBpbW1lZGlhdGVseVxuXG4gICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICBjb252ZXJzYXRpb246IHRoaXMuY29udmVyc2F0aW9uLFxuICAgICAgICB9O1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHA6Ly9sb2NhbGhvc3Q6ODAwMC9jb252ZXJzYXRpb25cIiwge1xuICAgICAgICAgICAgICAgIG1ldGhvZDogXCJQT1NUXCIsXG4gICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIGJvZHk6IEpTT04uc3RyaW5naWZ5KGRhdGEpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBjb25zdCBvdXRwdXQgPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG4gICAgICAgICAgICB0aGlzLmFkZE1lc3NhZ2Uob3V0cHV0LnJlc3BvbnNlLCBcInN5c3RlbVwiKTsgLy8gRGlzcGxheSB0aGUgcmVzcG9uc2VcbiAgICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFcnJvcjpcIiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuICAgIGFzeW5jIHNhdmVDaGF0KCkge1xuICAgICAgICBjb25zdCBjaGF0X2ZvbGRlcl9wYXRoID0gXCJjaGF0cy9cIjtcbiAgICAgICAgY29uc3QgZmlsZV9uYW1lID0gYCR7dGhpcy5jaGF0X2lkfS5tZGA7XG4gICAgICAgIGNvbnN0IGZpbGVfcGF0aCA9IGNoYXRfZm9sZGVyX3BhdGggKyBmaWxlX25hbWU7XG5cbiAgICAgICAgbGV0IGZpbGVfY29udGVudCA9IGBcXGBcXGBcXGB4bWxcblx0XHQ8bWV0YWRhdGE+XFxuPGlkPiR7dGhpcy5jaGF0X2lkfTwvaWQ+XFxuPC9tZXRhZGF0YT5cblx0XHRgO1xuXG4gICAgICAgIGxldCBtZXNzYWdlcyA9IGBgO1xuXG4gICAgICAgIHRoaXMuY29udmVyc2F0aW9uLmZvckVhY2goKG1lc3NhZ2UpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VfeG1sID0gYFxuXHRcdFx0PG1lc3NhZ2U+XG5cdFx0XHRcdDxyb2xlPiR7bWVzc2FnZS5yb2xlfTwvcm9sZT5cblx0XHRcdFx0PGNvbnRlbnQ+JHttZXNzYWdlLmNvbnRlbnR9PC9jb250ZW50PlxuXHRcdFx0PC9tZXNzYWdlPlxuXHRcdFx0YC50cmltKCk7XG4gICAgICAgICAgICBtZXNzYWdlcyArPSBtZXNzYWdlX3htbDtcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBjb252ZXJzYXRpb24gPSBgPGNvbnZlcnNhdGlvbj5cXG4ke21lc3NhZ2VzfTwvY29udmVyc2F0aW9uPlxcYFxcYFxcYGA7XG4gICAgICAgIGZpbGVfY29udGVudCArPSBjb252ZXJzYXRpb247XG4gICAgICAgIGNvbnN0IGZpbGUgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5nZXRGaWxlQnlQYXRoKGZpbGVfcGF0aCk7XG5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGlmIChmaWxlKSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgdGhpcy5hcHAudmF1bHQubW9kaWZ5KGZpbGUsIGZpbGVfY29udGVudCk7XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMuYXBwLnZhdWx0LmNyZWF0ZShmaWxlX3BhdGgsIGZpbGVfY29udGVudCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0gY2F0Y2ggKGVycm9yKSB7XG4gICAgICAgICAgICBjb25zb2xlLmVycm9yKFwiRmFpbGVkIHRvIHNhdmUgY2hhdDpcIiwgZXJyb3IpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZ2VuZXJhdGVSYW5kb21JRChsZW5ndGg6IG51bWJlcikge1xuICAgICAgICBjb25zdCBjaGFycyA9IFwiQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODlcIjtcbiAgICAgICAgbGV0IHJlc3VsdCA9IFwiXCI7XG4gICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHJlc3VsdCArPSBjaGFycy5jaGFyQXQoTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogY2hhcnMubGVuZ3RoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9XG5cbiAgICBhc3luYyBvbkNsb3NlKCkge1xuICAgICAgICAvLyBDbGVhbnVwIGxvZ2ljIGlmIG5lY2Vzc2FyeVxuICAgIH1cbn1cblxuZXhwb3J0IGRlZmF1bHQgY2xhc3MgTXlQbHVnaW4gZXh0ZW5kcyBQbHVnaW4ge1xuICAgIHNldHRpbmdzOiBNeVBsdWdpblNldHRpbmdzO1xuICAgIGFzeW5jIG9ubG9hZCgpIHtcbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgICAgICAgIGlkOiBcInBhdGNoLW1lbnVcIixcbiAgICAgICAgICAgIG5hbWU6IFwiUGF0Y2ggTWVudVwiLFxuICAgICAgICAgICAgY2FsbGJhY2s6IGFzeW5jICgpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnBhdGNoQ2FudmFzTWVudSgpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJFdmVudChcbiAgICAgICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5vbihcImFjdGl2ZS1sZWFmLWNoYW5nZVwiLCAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coXCJMZWFmIGNoYW5nZWRcIik7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudExlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuYWN0aXZlTGVhZjtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudExlYWY/LnZpZXcuZ2V0Vmlld1R5cGUoKSA9PT0gXCJjYW52YXNcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyhcIkxlYWYgaXMgY2FudmFzIVwiKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXRjaENhbnZhc01lbnUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuICAgICAgICApO1xuXG4gICAgICAgIGF3YWl0IHRoaXMubG9hZFNldHRpbmdzKCk7XG4gICAgICAgIHRoaXMucmVnaXN0ZXJFZGl0b3JFeHRlbnNpb24oW3JlZEJhY2tncm91bmRGaWVsZF0pO1xuXG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBzaWRlYmFyIGljb25cbiAgICAgICAgdGhpcy5hZGRTaWRlYmFyVGFiKCk7XG5cbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgICAgICAgIGlkOiBcImxvZ1wiLFxuICAgICAgICAgICAgbmFtZTogXCJMb2dcIixcbiAgICAgICAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY3VycmVudExlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuYWN0aXZlTGVhZjtcbiAgICAgICAgICAgICAgICBpZiAoY3VycmVudExlYWY/LnZpZXcuZ2V0Vmlld1R5cGUoKSA9PT0gXCJjYW52YXNcIikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBjYW52YXNWaWV3ID0gY3VycmVudExlYWYudmlldztcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FudmFzID0gKGNhbnZhc1ZpZXcgYXMgYW55KS5jYW52YXM7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNhbnZhcyk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNhbnZhcy5ub2RlSW5kZXguZGF0YS5jaGlsZHJlbik7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHZpZXdwb3J0Tm9kZXMgPSBjYW52YXMuZ2V0Vmlld3BvcnROb2RlcygpO1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmxvZyh2aWV3cG9ydE5vZGVzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6IFwiY2FudmFzLXByb21wdFwiLFxuICAgICAgICAgICAgbmFtZTogXCJDYW52YXMgUHJvbXB0XCIsXG4gICAgICAgICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMZWFmID0gdGhpcy5hcHAud29ya3NwYWNlLmFjdGl2ZUxlYWY7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMZWFmPy52aWV3LmdldFZpZXdUeXBlKCkgPT09IFwiY2FudmFzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FudmFzVmlldyA9IGN1cnJlbnRMZWFmLnZpZXc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IChjYW52YXNWaWV3IGFzIGFueSkuY2FudmFzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBjYW52YXMuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYXZlcmFnZV95ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGF2ZXJhZ2VfaGVpZ2h0ID0gMDtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGF2ZXJhZ2Vfd2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgbWF4X3ggPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG90YWxfeSA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb3VudCA9IDA7XG4gICAgICAgICAgICAgICAgICAgIGxldCB0b3RhbF9oZWlnaHQgPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgdG90YWxfd2lkdGggPSAwO1xuICAgICAgICAgICAgICAgICAgICBsZXQgYWxsX3RleHQgPSBcIlwiO1xuICAgICAgICAgICAgICAgICAgICBmb3IgKGNvbnN0IG9iaiBvZiBzZWxlY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgeCwgeSwgaGVpZ2h0LCB3aWR0aCB9ID0gb2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF4X3ggPSBNYXRoLm1heChtYXhfeCwgeCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbF95ICs9IHk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0b3RhbF9oZWlnaHQgKz0gaGVpZ2h0O1xuICAgICAgICAgICAgICAgICAgICAgICAgdG90YWxfd2lkdGggKz0gd2lkdGg7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb3VudCsrO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKFwidGV4dFwiIGluIG9iaikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHsgdGV4dCB9ID0gb2JqO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWxsX3RleHQgKz0gdGV4dCArIFwiXFxuXCI7XG4gICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKFwiZmlsZVBhdGhcIiBpbiBvYmopIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsZXQgeyBmaWxlUGF0aCB9ID0gb2JqO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpbGUgPSBhd2FpdCB0aGlzLmFwcC52YXVsdC5nZXRGaWxlQnlQYXRoKGZpbGVQYXRoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoZmlsZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0ID0gYXdhaXQgdGhpcy5hcHAudmF1bHQucmVhZChmaWxlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmlsZV90ZXh0ID0gYFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBUaXRsZTogJHtmaWxlUGF0aC5yZXBsYWNlKFwiLm1kXCIsIFwiXCIpfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAke3RleHR9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGAudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhbGxfdGV4dCArPSBmaWxlX3RleHQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGF2ZXJhZ2VfeSA9IGNvdW50ID4gMCA/IHRvdGFsX3kgLyBjb3VudCA6IDA7XG4gICAgICAgICAgICAgICAgICAgIGF2ZXJhZ2VfaGVpZ2h0ID0gY291bnQgPiAwID8gdG90YWxfaGVpZ2h0IC8gY291bnQgOiAwO1xuICAgICAgICAgICAgICAgICAgICBhdmVyYWdlX3dpZHRoID0gY291bnQgPiAwID8gdG90YWxfd2lkdGggLyBjb3VudCA6IDA7XG5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyBoYW5kbGVzIHRoZSBtb2RlbCAtLS1cbiAgICAgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGEgbW9kYWwgd2l0aCBhIHRleHQgaW5wdXQgYW5kIGEgc3VibWl0IGJ1dHRvblxuICAgICAgICAgICAgICAgICAgICBjb25zdCBtb2RhbCA9IG5ldyBNb2RhbCh0aGlzLmFwcCk7XG4gICAgICAgICAgICAgICAgICAgIG1vZGFsLmNvbnRlbnRFbC5jcmVhdGVFbChcImgxXCIsIHsgdGV4dDogXCJDYW52YXMgUHJvbXB0XCIgfSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRhaW5lciA9IG1vZGFsLmNvbnRlbnRFbC5jcmVhdGVEaXYoeyBjbHM6IFwiZmxleC1jb2xcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgdGV4dEFyZWEgPSBjb250YWluZXIuY3JlYXRlRWwoXCJ0ZXh0YXJlYVwiLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwbGFjZWhvbGRlcjogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsczogXCJ3LWZ1bGwgbWItMlwiLFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3VibWl0QnV0dG9uID0gY29udGFpbmVyLmNyZWF0ZUVsKFwiYnV0dG9uXCIsIHsgdGV4dDogXCJTdWJtaXRcIiB9KTtcbiAgICAgICAgICAgICAgICAgICAgc3VibWl0QnV0dG9uLm9uY2xpY2sgPSBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RhbC5jbG9zZSgpO1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgcHJvbXB0ID0gYFxuICAgICAgICAgICAgICAgICAgICAgICAgUGxlYXNlIGRvIHRoZSBmb2xsb3dpbmc6XG4gICAgICAgICAgICAgICAgICAgICAgICAke3RleHRBcmVhLnZhbHVlfVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBHaXZlbiB0aGlzIGNvbnRlbnQ6XG4gICAgICAgICAgICAgICAgICAgICAgICAke2FsbF90ZXh0fVxuICAgICAgICAgICAgICAgICAgICAgICAgYDtcblxuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGF3YWl0IG9uZV9zaG90KHByb21wdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCB0ZXh0Tm9kZUNvbmZpZyA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3M6IHsgeDogbWF4X3ggKyA1MCwgeTogYXZlcmFnZV95IH0sIC8vIFBvc2l0aW9uIG9uIHRoZSBjYW52YXNcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzaXplOiB7IHdpZHRoOiBhdmVyYWdlX3dpZHRoLCBoZWlnaHQ6IGF2ZXJhZ2VfaGVpZ2h0IH0sIC8vIFNpemUgb2YgdGhlIHRleHQgYm94XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwiY2VudGVyXCIsIC8vIFRoaXMgbWlnaHQgcmVsYXRlIHRvIHRleHQgYWxpZ25tZW50XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGV4dDogY29udGVudCwgLy8gVGV4dCBjb250ZW50IGZyb20gaW5wdXRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzYXZlOiB0cnVlLCAvLyBTYXZlIHRoaXMgbm9kZSdzIHN0YXRlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZm9jdXM6IHRydWUsIC8vIEZvY3VzIGFuZCBzdGFydCBlZGl0aW5nIGltbWVkaWF0ZWx5XG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBDcmVhdGUgdGhlIHRleHQgbm9kZSBvbiB0aGUgY2FudmFzXG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBub2RlID0gY2FudmFzLmNyZWF0ZVRleHROb2RlKHRleHROb2RlQ29uZmlnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGVfaWQgPSBub2RlLmlkO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS5jb2xvciA9IFwiNlwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgbm9kZS56b29tVG9TZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgbW9kYWwub3BlbigpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogXCJjcmVhdGUtY2hpbGRcIixcbiAgICAgICAgICAgIG5hbWU6IFwiQ3JlYXRlIENoaWxkXCIsXG4gICAgICAgICAgICBjYWxsYmFjazogYXN5bmMgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRMZWFmID0gdGhpcy5hcHAud29ya3NwYWNlLmFjdGl2ZUxlYWY7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRMZWFmPy52aWV3LmdldFZpZXdUeXBlKCkgPT09IFwiY2FudmFzXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY2FudmFzVmlldyA9IGN1cnJlbnRMZWFmLnZpZXc7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGNhbnZhcyA9IChjYW52YXNWaWV3IGFzIGFueSkuY2FudmFzO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBjYW52YXMuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb25JdGVyYXRvciA9IHNlbGVjdGlvbi52YWx1ZXMoKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3Qgbm9kZSA9IHNlbGVjdGlvbkl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgY2hpbGROb2RlKGNhbnZhcywgbm9kZSwgbm9kZS55KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcblxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6IFwib3Blbi1jbWRqLW1vZGFsXCIsXG4gICAgICAgICAgICBuYW1lOiBcIk9wZW4gQ01EK0ogTW9kYWxcIixcbiAgICAgICAgICAgIGhvdGtleXM6IFt7IG1vZGlmaWVyczogW1wiTW9kXCJdLCBrZXk6IFwialwiIH1dLFxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBhY3RpdmVWaWV3ID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KTtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlVmlldyAmJiBhY3RpdmVWaWV3LmVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3RlZFRleHQgPSBhY3RpdmVWaWV3LmVkaXRvci5nZXRTZWxlY3Rpb24oKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGFjdGl2ZVZpZXcuZWRpdG9yLmdldFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0SW5kZXggPSBjb250ZW50LmluZGV4T2Yoc2VsZWN0ZWRUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZW5kSW5kZXggPSBzdGFydEluZGV4ICsgc2VsZWN0ZWRUZXh0Lmxlbmd0aDtcbiAgICAgICAgICAgICAgICAgICAgbmV3IENNREpNb2RhbCh0aGlzLmFwcCwgc2VsZWN0ZWRUZXh0LCBzdGFydEluZGV4LCBlbmRJbmRleCkub3BlbigpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJObyBhY3RpdmUgbWFya2Rvd24gZWRpdG9yIG9yIG5vIHRleHQgc2VsZWN0ZWQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIFJlZ2lzdGVyIHRoZSBjdXN0b20gdmlld1xuICAgICAgICB0aGlzLnJlZ2lzdGVyVmlldyhWSUVXX05BTUVfU0lERUJBUl9DSEFULCAobGVhZikgPT4gbmV3IFNpZGViYXJDaGF0KGxlYWYpKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlclZpZXcoVklFV19OQU1FX01BSU5fQ0hBVCwgKGxlYWYpID0+IG5ldyBNYWluQ2hhdChsZWFmKSk7XG4gICAgICAgIC8vIERlZmluZSBhIGNvbW1hbmQgdG8gaW5zZXJ0IHRleHQgaW50byB0aGUgc2lkZWJhclxuICAgICAgICB0aGlzLmFkZENvbW1hbmQoe1xuICAgICAgICAgICAgaWQ6IFwiaW5zZXJ0LXRleHQtaW50by1zaWRlYmFyXCIsXG4gICAgICAgICAgICBuYW1lOiBcIkluc2VydCBUZXh0IGludG8gU2lkZWJhclwiLFxuICAgICAgICAgICAgaG90a2V5czogW3sgbW9kaWZpZXJzOiBbXCJNb2RcIl0sIGtleTogXCJsXCIgfV0sXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGFjdGl2ZUxlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuYWN0aXZlTGVhZjtcbiAgICAgICAgICAgICAgICBpZiAoYWN0aXZlTGVhZikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBlZGl0b3IgPSBhY3RpdmVMZWFmLnZpZXcgaW5zdGFuY2VvZiBNYXJrZG93blZpZXcgPyBhY3RpdmVMZWFmLnZpZXcuZWRpdG9yIDogbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVkaXRvcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc2VsZWN0ZWRUZXh0ID0gZWRpdG9yLmdldFNlbGVjdGlvbigpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5pbnNlcnRUZXh0SW50b1NpZGViYXIoc2VsZWN0ZWRUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIERlZmluZSBhIGNvbW1hbmQgdG8gY2xlYXIgdGV4dCBmcm9tIHRoZSBzaWRlYmFyXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogXCJjbGVhci10ZXh0LWluLXNpZGViYXJcIixcbiAgICAgICAgICAgIG5hbWU6IFwiQ2xlYXIgVGV4dCBpbiBTaWRlYmFyXCIsXG4gICAgICAgICAgICBob3RrZXlzOiBbeyBtb2RpZmllcnM6IFtcIk1vZFwiXSwga2V5OiBcIjtcIiB9XSxcbiAgICAgICAgICAgIGNhbGxiYWNrOiAoKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy5jbGVhclRleHRJblNpZGViYXIoKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIGFzeW5jIGZ1bmN0aW9uIG9uZV9zaG90KG1lc3NhZ2U6IHN0cmluZykge1xuICAgICAgICAgICAgY29uc3QgZGF0YSA9IHsgbWVzc2FnZSB9O1xuICAgICAgICAgICAgY29uc3QgcmVzcCA9IGF3YWl0IGZldGNoKFwiaHR0cDovL2xvY2FsaG9zdDo4MDAwL3NpbmdsZS10dXJuXCIsIHtcbiAgICAgICAgICAgICAgICBtZXRob2Q6IFwiUE9TVFwiLFxuICAgICAgICAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAgICAgXCJDb250ZW50LVR5cGVcIjogXCJhcHBsaWNhdGlvbi9qc29uXCIsXG4gICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgY29uc3Qgb3V0cHV0ID0gYXdhaXQgcmVzcC5qc29uKCk7XG4gICAgICAgICAgICByZXR1cm4gb3V0cHV0LmNvbnRlbnQ7XG4gICAgICAgIH1cblxuICAgICAgICBmdW5jdGlvbiBwYXJzZUN1c3RvbVhNTCh4bWxTdHJpbmc6IHN0cmluZykge1xuICAgICAgICAgICAgLy8gRnVuY3Rpb24gdG8gZXh0cmFjdCBjb250ZW50IGJldHdlZW4gdGFnc1xuICAgICAgICAgICAgZnVuY3Rpb24gZ2V0Q29udGVudCh0YWc6IHN0cmluZywgc3RyaW5nOiBzdHJpbmcpIHtcbiAgICAgICAgICAgICAgICBjb25zdCBvcGVuVGFnID0gYDwke3RhZ30+YDtcbiAgICAgICAgICAgICAgICBjb25zdCBjbG9zZVRhZyA9IGA8LyR7dGFnfT5gO1xuICAgICAgICAgICAgICAgIGNvbnN0IHN0YXJ0ID0gc3RyaW5nLmluZGV4T2Yob3BlblRhZykgKyBvcGVuVGFnLmxlbmd0aDtcbiAgICAgICAgICAgICAgICBjb25zdCBlbmQgPSBzdHJpbmcuaW5kZXhPZihjbG9zZVRhZyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHN0cmluZy5zdWJzdHJpbmcoc3RhcnQsIGVuZCkudHJpbSgpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAvLyBFeHRyYWN0IGNvbnZlcnNhdGlvbiBJRFxuICAgICAgICAgICAgY29uc3QgY29udmVyc2F0aW9uSWQgPSBnZXRDb250ZW50KFwiaWRcIiwgeG1sU3RyaW5nKTtcblxuICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZSB0aGUgcmVzdWx0IG9iamVjdCB3aXRoIG1ldGFkYXRhXG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSB7XG4gICAgICAgICAgICAgICAgbWV0YWRhdGE6IHtcbiAgICAgICAgICAgICAgICAgICAgaWQ6IGNvbnZlcnNhdGlvbklkLFxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgY29udmVyc2F0aW9uOiB7XG4gICAgICAgICAgICAgICAgICAgIG1lc3NhZ2VzOiBbXSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgLy8gRXh0cmFjdCBtZXNzYWdlc1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZXNDb250ZW50ID0gZ2V0Q29udGVudChcImNvbnZlcnNhdGlvblwiLCB4bWxTdHJpbmcpO1xuICAgICAgICAgICAgY29uc3QgbWVzc2FnZVRhZ3MgPSBtZXNzYWdlc0NvbnRlbnQuc3BsaXQoXCI8L21lc3NhZ2U+XCIpLnNsaWNlKDAsIC0xKTsgLy8gU3BsaXQgYW5kIHJlbW92ZSBsYXN0IGVtcHR5IGVsZW1lbnRcblxuICAgICAgICAgICAgZm9yIChjb25zdCBtZXNzYWdlVGFnIG9mIG1lc3NhZ2VUYWdzKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgcm9sZSA9IGdldENvbnRlbnQoXCJyb2xlXCIsIG1lc3NhZ2VUYWcpO1xuICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBnZXRDb250ZW50KFwiY29udGVudFwiLCBtZXNzYWdlVGFnKTtcbiAgICAgICAgICAgICAgICAvL0B0cy1pZ25vcmUgLy8gVE9ETyAtIFJlbW92ZSB0aGlzIGFuZCBmaXggaXRcbiAgICAgICAgICAgICAgICByZXN1bHQuY29udmVyc2F0aW9uLm1lc3NhZ2VzLnB1c2goeyByb2xlLCBjb250ZW50IH0pO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy5hZGRDb21tYW5kKHtcbiAgICAgICAgICAgIGlkOiBcIm9wZW4tY2hhdFwiLFxuICAgICAgICAgICAgbmFtZTogXCJPcGVuIENoYXRcIixcbiAgICAgICAgICAgIGNhbGxiYWNrOiBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgZWRpdG9yID0gdGhpcy5hcHAud29ya3NwYWNlLmdldEFjdGl2ZVZpZXdPZlR5cGUoTWFya2Rvd25WaWV3KT8uZWRpdG9yO1xuICAgICAgICAgICAgICAgIGlmIChlZGl0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgbGV0IGNvbnRlbnQgPSBlZGl0b3IuZ2V0VmFsdWUoKTtcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZShcImBgYHhtbFwiLCBcIlwiKS50cmltKCk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2UoXCJgYGBcIiwgXCJcIikudHJpbSgpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCB4bWwgPSBwYXJzZUN1c3RvbVhNTChjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgY29udm9faWQgPSB4bWwubWV0YWRhdGEuaWQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2VzID0geG1sLmNvbnZlcnNhdGlvbi5tZXNzYWdlcztcblxuICAgICAgICAgICAgICAgICAgICBpZiAoY29udm9faWQgJiYgbWVzc2FnZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGxlYWYgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZih0cnVlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNoYXRWaWV3ID0gbmV3IE1haW5DaGF0KGxlYWYsIGNvbnZvX2lkLCBtZXNzYWdlcyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyBhd2FpdCBsZWFmLnNldFZpZXdTdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICAvLyAgICAgdHlwZTogVklFV19OQU1FX01BSU5fQ0hBVCxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBzdGF0ZTogeyBjaGF0SWQ6IGNvbnZvX2lkLCBtZXNzYWdlczogbWVzc2FnZXMgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxlYWYub3BlbihjaGF0Vmlldyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2UucmV2ZWFsTGVhZihsZWFmKTtcbiAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJObyB2YWxpZCBjaGF0IGRhdGEgZm91bmQgaW4gdGhlIGN1cnJlbnQgZG9jdW1lbnQuXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIk5vIGFjdGl2ZSBtYXJrZG93biBlZGl0b3IgZm91bmQuXCIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuXG4gICAgICAgIHRoaXMuYWRkQ29tbWFuZCh7XG4gICAgICAgICAgICBpZDogXCJhcHBseS1kaWZmc1wiLFxuICAgICAgICAgICAgbmFtZTogXCJBcHBseSBEaWZmc1wiLFxuICAgICAgICAgICAgaG90a2V5czogW3sgbW9kaWZpZXJzOiBbXCJNb2RcIl0sIGtleTogXCJkXCIgfV0sXG4gICAgICAgICAgICBjYWxsYmFjazogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVkaXRvciA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRBY3RpdmVWaWV3T2ZUeXBlKE1hcmtkb3duVmlldyk/LmVkaXRvcjtcbiAgICAgICAgICAgICAgICBpZiAoZWRpdG9yKSB7XG4gICAgICAgICAgICAgICAgICAgIGxldCBjb250ZW50ID0gZWRpdG9yLmdldFZhbHVlKCk7XG4gICAgICAgICAgICAgICAgICAgIC8vIFJlZ2V4IHRvIGZpbmQgfC1jb250ZW50LXxcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZGVsZXRlUmVnZXggPSAvXFx8LSguKj8pLVxcfC9ncztcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVnZXggdG8gZmluZCB8K2NvbnRlbnQrfFxuXG4gICAgICAgICAgICAgICAgICAgIC8vIFJlcGxhY2UgYWxsIGluc3RhbmNlcyBvZiB8LWNvbnRlbnQtfCB3aXRoIGVtcHR5IHN0cmluZ1xuICAgICAgICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5yZXBsYWNlKGRlbGV0ZVJlZ2V4LCBcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gUmVwbGFjZSBhbGwgaW5zdGFuY2VzIG9mIHwrY29udGVudCt8IHdpdGggZW1wdHkgc3RyaW5nXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgY29udGVudCA9IGNvbnRlbnQucmVwbGFjZUFsbChcInwrXCIsIFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50LnJlcGxhY2VBbGwoXCIrfFwiLCBcIlwiKTtcblxuICAgICAgICAgICAgICAgICAgICAvLyBTZXQgdGhlIG1vZGlmaWVkIGNvbnRlbnQgYmFjayB0byB0aGUgZWRpdG9yXG4gICAgICAgICAgICAgICAgICAgIGVkaXRvci5zZXRWYWx1ZShjb250ZW50KTtcbiAgICAgICAgICAgICAgICAgICAgbmV3IE5vdGljZShcIkRpcHMgYXBwbGllZCBzdWNjZXNzZnVsbHkuXCIpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIG5ldyBOb3RpY2UoXCJObyBhY3RpdmUgbWFya2Rvd24gZWRpdG9yIGZvdW5kLlwiKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBwYXRjaENhbnZhc01lbnUoKSB7XG4gICAgICAgIGNvbnN0IGNhbnZhc1ZpZXcgPSB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhdmVzT2ZUeXBlKFwiY2FudmFzXCIpLmZpcnN0KCk/LnZpZXc7XG4gICAgICAgIGlmICghY2FudmFzVmlldykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IGNhbnZhcyA9IGNhbnZhc1ZpZXcuY2FudmFzO1xuXG4gICAgICAgIGNvbnN0IG1lbnUgPSBjYW52YXNWaWV3LmNhbnZhcy5tZW51O1xuICAgICAgICBpZiAoIW1lbnUpIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJObyBtZW51IGZvdW5kIG9uIHRoZSBjYW52YXNcIik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgdGhhdCA9IHRoaXM7IC8vIENhcHR1cmUgdGhlIGNvcnJlY3QgJ3RoaXMnIGNvbnRleHQuXG5cbiAgICAgICAgY29uc3QgbWVudVVuaW5zdGFsbGVyID0gYXJvdW5kKG1lbnUuY29uc3RydWN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgICAgICByZW5kZXI6IChuZXh0OiBhbnkpID0+XG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKC4uLmFyZ3M6IGFueSkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZXN1bHQgPSBuZXh0LmNhbGwodGhpcywgLi4uYXJncyk7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYWRkR3JhcGhCdXR0b25JZk5lZWRlZCh0aGlzLm1lbnVFbCk7XG4gICAgICAgICAgICAgICAgICAgIHRoYXQuYWRkQUlCdXR0b25JZk5lZWRlZCh0aGlzLm1lbnVFbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICB9KTtcbiAgICAgICAgY29uc29sZS5sb2coXCJIZXJlZS0tLVwiKTtcbiAgICAgICAgY29uc29sZS5sb2coY2FudmFzVmlldy5jb25zdHJ1Y3Rvci5wcm90b3R5cGUpO1xuICAgICAgICBjYW52YXNWaWV3LnNjb3BlPy5yZWdpc3RlcihbXCJNb2RcIiwgXCJTaGlmdFwiXSwgXCJBcnJvd1VwXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoYXQuY3JlYXRlX2RpcmVjdGlvbmFsX25vZGUoY2FudmFzLCBcInRvcFwiKTtcbiAgICAgICAgfSk7XG5cbiAgICAgICAgY2FudmFzVmlldy5zY29wZT8ucmVnaXN0ZXIoW1wiTW9kXCJdLCBcIkFycm93VXBcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhhdC5uYXZpZ2F0ZShjYW52YXMsIFwidG9wXCIpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2FudmFzVmlldy5zY29wZT8ucmVnaXN0ZXIoW1wiTW9kXCJdLCBcIkFycm93RG93blwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGF0Lm5hdmlnYXRlKGNhbnZhcywgXCJib3R0b21cIik7XG4gICAgICAgIH0pO1xuICAgICAgICBjYW52YXNWaWV3LnNjb3BlPy5yZWdpc3RlcihbXCJNb2RcIl0sIFwiQXJyb3dMZWZ0XCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoYXQubmF2aWdhdGUoY2FudmFzLCBcImxlZnRcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBjYW52YXNWaWV3LnNjb3BlPy5yZWdpc3RlcihbXCJNb2RcIl0sIFwiQXJyb3dSaWdodFwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGF0Lm5hdmlnYXRlKGNhbnZhcywgXCJyaWdodFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbnZhc1ZpZXcuc2NvcGU/LnJlZ2lzdGVyKFtcIk1vZFwiXSwgXCJFbnRlclwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGF0LnN0YXJ0X2VkaXRpbmdfbm9kZShjYW52YXMpO1xuICAgICAgICB9KTtcblxuICAgICAgICBjYW52YXNWaWV3LnNjb3BlPy5yZWdpc3RlcihbXCJNb2RcIiwgXCJTaGlmdFwiXSwgXCJBcnJvd1VwXCIsICgpID0+IHtcbiAgICAgICAgICAgIHRoYXQuY3JlYXRlX2RpcmVjdGlvbmFsX25vZGUoY2FudmFzLCBcInRvcFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbnZhc1ZpZXcuc2NvcGU/LnJlZ2lzdGVyKFtcIk1vZFwiLCBcIlNoaWZ0XCJdLCBcIkFycm93RG93blwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGF0LmNyZWF0ZV9kaXJlY3Rpb25hbF9ub2RlKGNhbnZhcywgXCJib3R0b21cIik7XG4gICAgICAgIH0pO1xuICAgICAgICBjYW52YXNWaWV3LnNjb3BlPy5yZWdpc3RlcihbXCJNb2RcIiwgXCJTaGlmdFwiXSwgXCJBcnJvd0xlZnRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhhdC5jcmVhdGVfZGlyZWN0aW9uYWxfbm9kZShjYW52YXMsIFwibGVmdFwiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGNhbnZhc1ZpZXcuc2NvcGU/LnJlZ2lzdGVyKFtcIk1vZFwiLCBcIlNoaWZ0XCJdLCBcIkFycm93UmlnaHRcIiwgKCkgPT4ge1xuICAgICAgICAgICAgdGhhdC5jcmVhdGVfZGlyZWN0aW9uYWxfbm9kZShjYW52YXMsIFwicmlnaHRcIik7XG4gICAgICAgIH0pO1xuICAgICAgICBjYW52YXNWaWV3LnNjb3BlPy5yZWdpc3RlcihbXCJNb2RcIiwgXCJTaGlmdFwiXSwgXCJFbnRlclwiLCAoKSA9PiB7XG4gICAgICAgICAgICB0aGF0LnJ1bl9ncmFwaF9jaGF0KGNhbnZhcyk7XG4gICAgICAgIH0pO1xuXG4gICAgICAgIC8vIGNvbnN0IGNhbnZhc1ZpZXd1bmlzdGFsbGVyID0gYXJvdW5kKGNhbnZhc1ZpZXcuY29uc3RydWN0b3IucHJvdG90eXBlLCB7XG4gICAgICAgIC8vICAgICBvbk9wZW46IChuZXh0KSA9PlxuICAgICAgICAvLyAgICAgICAgIGFzeW5jIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKHRoaXMuc2NvcGUpO1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdGhpcy5zY29wZS5yZWdpc3RlcihbXCJNb2RcIl0sIFwiQXJyb3dVcFwiLCAoKSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgdGhhdC5uYXZpZ2F0ZSh0aGlzLmNhbnZhcywgXCJ0b3BcIik7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHRoaXMuc2NvcGUucmVnaXN0ZXIoW1wiTW9kXCJdLCBcIkFycm93RG93blwiLCAoKSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgdGhhdC5uYXZpZ2F0ZSh0aGlzLmNhbnZhcywgXCJib3R0b21cIik7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHRoaXMuc2NvcGUucmVnaXN0ZXIoW1wiTW9kXCJdLCBcIkFycm93TGVmdFwiLCAoKSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgdGhhdC5uYXZpZ2F0ZSh0aGlzLmNhbnZhcywgXCJsZWZ0XCIpO1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB0aGlzLnNjb3BlLnJlZ2lzdGVyKFtcIk1vZFwiXSwgXCJBcnJvd1JpZ2h0XCIsICgpID0+IHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgICAgICB0aGF0Lm5hdmlnYXRlKHRoaXMuY2FudmFzLCBcInJpZ2h0XCIpO1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB0aGlzLnNjb3BlLnJlZ2lzdGVyKFtcIk1vZFwiXSwgXCJFbnRlclwiLCAoKSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICAgICAgdGhhdC5zdGFydF9lZGl0aW5nX25vZGUodGhpcy5jYW52YXMpO1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIC8vICAgICAgICAgICAgIH1cbiAgICAgICAgLy8gICAgICAgICAgICAgdGhpcy5zY29wZS5yZWdpc3RlcihbXCJNb2RcIiwgXCJTaGlmdFwiXSwgXCJBcnJvd1VwXCIsICgpID0+IHtcbiAgICAgICAgLy8gICAgICAgICAgICAgICAgIHRoYXQuY3JlYXRlX2RpcmVjdGlvbmFsX25vZGUodGhpcy5jYW52YXMsIFwidG9wXCIpO1xuICAgICAgICAvLyAgICAgICAgICAgICB9KTtcbiAgICAgICAgLy8gICAgICAgICAgICAgdGhpcy5zY29wZS5yZWdpc3RlcihbXCJNb2RcIiwgXCJTaGlmdFwiXSwgXCJBcnJvd0Rvd25cIiwgKCkgPT4ge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdGhhdC5jcmVhdGVfZGlyZWN0aW9uYWxfbm9kZSh0aGlzLmNhbnZhcywgXCJib3R0b21cIik7XG4gICAgICAgIC8vICAgICAgICAgICAgIH0pO1xuICAgICAgICAvLyAgICAgICAgICAgICB0aGlzLnNjb3BlLnJlZ2lzdGVyKFtcIk1vZFwiLCBcIlNoaWZ0XCJdLCBcIkFycm93TGVmdFwiLCAoKSA9PiB7XG4gICAgICAgIC8vICAgICAgICAgICAgICAgICB0aGF0LmNyZWF0ZV9kaXJlY3Rpb25hbF9ub2RlKHRoaXMuY2FudmFzLCBcImxlZnRcIik7XG4gICAgICAgIC8vICAgICAgICAgICAgIH0pO1xuICAgICAgICAvLyAgICAgICAgICAgICB0aGlzLnNjb3BlLnJlZ2lzdGVyKFtcIk1vZFwiLCBcIlNoaWZ0XCJdLCBcIkFycm93UmlnaHRcIiwgKCkgPT4ge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdGhhdC5jcmVhdGVfZGlyZWN0aW9uYWxfbm9kZSh0aGlzLmNhbnZhcywgXCJyaWdodFwiKTtcbiAgICAgICAgLy8gICAgICAgICAgICAgfSk7XG4gICAgICAgIC8vICAgICAgICAgICAgIHRoaXMuc2NvcGUucmVnaXN0ZXIoW1wiTW9kXCIsIFwiU2hpZnRcIl0sIFwiRW50ZXJcIiwgKCkgPT4ge1xuICAgICAgICAvLyAgICAgICAgICAgICAgICAgdGhhdC5ydW5fZ3JhcGhfY2hhdCh0aGlzLmNhbnZhcyk7XG4gICAgICAgIC8vICAgICAgICAgICAgIH0pO1xuXG4gICAgICAgIC8vICAgICAgICAgICAgIHJldHVybiBuZXh0LmNhbGwodGhpcyk7XG4gICAgICAgIC8vICAgICAgICAgfSxcbiAgICAgICAgLy8gfSk7XG5cbiAgICAgICAgdGhpcy5yZWdpc3RlcihtZW51VW5pbnN0YWxsZXIpO1xuICAgIH1cbiAgICBjcmVhdGVfZGlyZWN0aW9uYWxfbm9kZShjYW52YXM6IGFueSwgZGlyZWN0aW9uOiBzdHJpbmcpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gY2FudmFzLnNlbGVjdGlvbjtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uSXRlcmF0b3IgPSBzZWxlY3Rpb24udmFsdWVzKCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzZWxlY3Rpb25JdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgICAgIGlmICghbm9kZSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChub2RlLmlzRWRpdGluZykge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNvbnN0IHBhcmVudF9ub2RlX3ggPSBub2RlLng7XG4gICAgICAgIGNvbnN0IHBhcmVudF9ub2RlX3kgPSBub2RlLnk7XG4gICAgICAgIGNvbnN0IHBhcmVudF93aWR0aCA9IG5vZGUud2lkdGg7XG4gICAgICAgIGNvbnN0IHBhcmVudF9oZWlnaHQgPSBub2RlLmhlaWdodDtcblxuICAgICAgICBsZXQgeDogbnVtYmVyO1xuICAgICAgICBsZXQgeTogbnVtYmVyO1xuICAgICAgICBsZXQgZnJvbV9zaWRlOiBzdHJpbmc7XG4gICAgICAgIGxldCB0b19zaWRlOiBzdHJpbmc7XG5cbiAgICAgICAgc3dpdGNoIChkaXJlY3Rpb24pIHtcbiAgICAgICAgICAgIGNhc2UgXCJsZWZ0XCI6XG4gICAgICAgICAgICAgICAgeCA9IHBhcmVudF9ub2RlX3ggLSBwYXJlbnRfd2lkdGggLSAyMDA7XG4gICAgICAgICAgICAgICAgeSA9IHBhcmVudF9ub2RlX3k7XG4gICAgICAgICAgICAgICAgZnJvbV9zaWRlID0gXCJsZWZ0XCI7XG4gICAgICAgICAgICAgICAgdG9fc2lkZSA9IFwicmlnaHRcIjtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJyaWdodFwiOlxuICAgICAgICAgICAgICAgIHggPSBwYXJlbnRfbm9kZV94ICsgcGFyZW50X3dpZHRoICsgMjAwO1xuICAgICAgICAgICAgICAgIHkgPSBwYXJlbnRfbm9kZV95O1xuICAgICAgICAgICAgICAgIGZyb21fc2lkZSA9IFwicmlnaHRcIjtcbiAgICAgICAgICAgICAgICB0b19zaWRlID0gXCJsZWZ0XCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwidG9wXCI6XG4gICAgICAgICAgICAgICAgeCA9IHBhcmVudF9ub2RlX3g7XG4gICAgICAgICAgICAgICAgeSA9IHBhcmVudF9ub2RlX3kgLSBwYXJlbnRfaGVpZ2h0IC0gMjAwO1xuICAgICAgICAgICAgICAgIGZyb21fc2lkZSA9IFwidG9wXCI7XG4gICAgICAgICAgICAgICAgdG9fc2lkZSA9IFwiYm90dG9tXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgICAgICAgeCA9IHBhcmVudF9ub2RlX3g7XG4gICAgICAgICAgICAgICAgeSA9IHBhcmVudF9ub2RlX3kgKyBwYXJlbnRfaGVpZ2h0ICsgMjAwO1xuICAgICAgICAgICAgICAgIGZyb21fc2lkZSA9IFwiYm90dG9tXCI7XG4gICAgICAgICAgICAgICAgdG9fc2lkZSA9IFwidG9wXCI7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJJbnZhbGlkIGRpcmVjdGlvbiBwcm92aWRlZFwiKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cblxuICAgICAgICB0aGlzLmNoaWxkTm9kZShjYW52YXMsIG5vZGUsIHgsIHksIFwiPHJvbGU+dXNlcjwvcm9sZT5cIiwgZnJvbV9zaWRlLCB0b19zaWRlKTtcbiAgICB9XG4gICAgc3RhcnRfZWRpdGluZ19ub2RlKGNhbnZhcykge1xuICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBjYW52YXMuc2VsZWN0aW9uO1xuICAgICAgICBjb25zdCBzZWxlY3Rpb25JdGVyYXRvciA9IHNlbGVjdGlvbi52YWx1ZXMoKTtcbiAgICAgICAgY29uc3Qgbm9kZSA9IHNlbGVjdGlvbkl0ZXJhdG9yLm5leHQoKS52YWx1ZTtcbiAgICAgICAgY29uc3Qgbm9kZV9pZCA9IG5vZGUuaWQ7XG4gICAgICAgIG5vZGUuaXNFZGl0aW5nID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZWRpdEJ1dHRvbiA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJy5jYW52YXMtbWVudSBidXR0b25bYXJpYS1sYWJlbD1cIkVkaXRcIl0nKTtcbiAgICAgICAgaWYgKGVkaXRCdXR0b24pIHtcbiAgICAgICAgICAgIGVkaXRCdXR0b24uY2xpY2soKTsgLy8gU2ltdWxhdGUgdGhlIGNsaWNrIG9uIHRoZSBlZGl0IGJ1dHRvblxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29uc29sZS5lcnJvcihcIkVkaXQgYnV0dG9uIG5vdCBmb3VuZFwiKTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBydW5fZ3JhcGhfY2hhdChjYW52YXMpIHtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gY2FudmFzLnNlbGVjdGlvbjtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uSXRlcmF0b3IgPSBzZWxlY3Rpb24udmFsdWVzKCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzZWxlY3Rpb25JdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgICAgIGNvbnN0IG5vZGVfaWQgPSBub2RlLmlkO1xuICAgICAgICBub2RlLmlzRWRpdGluZyA9IHRydWU7XG4gICAgICAgIGNvbnN0IGVkaXRCdXR0b24gPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKCcuY2FudmFzLW1lbnUgYnV0dG9uW2FyaWEtbGFiZWw9XCJTcGFya2xlXCJdJyk7XG4gICAgICAgIGlmIChlZGl0QnV0dG9uKSB7XG4gICAgICAgICAgICBlZGl0QnV0dG9uLmNsaWNrKCk7IC8vIFNpbXVsYXRlIHRoZSBjbGljayBvbiB0aGUgZWRpdCBidXR0b25cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoXCJFZGl0IGJ1dHRvbiBub3QgZm91bmRcIik7XG4gICAgICAgIH1cbiAgICB9XG4gICAgbmF2aWdhdGUoY2FudmFzLCBkaXJlY3Rpb246IHN0cmluZykge1xuICAgICAgICAvLyBjb25zdCBjYW52YXMgPSBjYW52YXNWaWV3LmNhbnZhcztcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uID0gY2FudmFzLnNlbGVjdGlvbjtcbiAgICAgICAgY29uc3Qgc2VsZWN0aW9uSXRlcmF0b3IgPSBzZWxlY3Rpb24udmFsdWVzKCk7XG4gICAgICAgIGNvbnN0IG5vZGUgPSBzZWxlY3Rpb25JdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgICAgIGNvbnNvbGUubG9nKFwiSW4gY2FudmFzXCIpO1xuICAgICAgICBjb25zb2xlLmxvZyhub2RlKTtcbiAgICAgICAgaWYgKCFub2RlKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgbm9kZV9pZCA9IG5vZGUuaWQ7XG4gICAgICAgIGNvbnN0IGNhbnZhc19kYXRhID0gY2FudmFzLmdldERhdGEoKTtcblxuICAgICAgICAvLyBBc3N1bWluZyBkaXJlY3Rpb24gY2FuIGJlICduZXh0JyBvciAncHJldmlvdXMnIGZvciBzaW1wbGljaXR5XG4gICAgICAgIGNvbnN0IGVkZ2VzID0gY2FudmFzX2RhdGEuZWRnZXM7XG4gICAgICAgIGNvbnN0IG5vZGVzID0gY2FudmFzX2RhdGEubm9kZXM7XG4gICAgICAgIGxldCB0YXJnZXROb2RlSUQ6IHN0cmluZyB8IG51bGwgPSBudWxsO1xuXG4gICAgICAgIHN3aXRjaCAoZGlyZWN0aW9uKSB7XG4gICAgICAgICAgICBjYXNlIFwicmlnaHRcIjpcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYm90aCAnZnJvbScgYW5kICd0bycgY2FzZXMgZm9yICdyaWdodCdcbiAgICAgICAgICAgICAgICBjb25zdCBlZGdlUmlnaHRGcm9tID0gZWRnZXMuZmluZCgoZWRnZSkgPT4gZWRnZS5mcm9tTm9kZSA9PT0gbm9kZV9pZCAmJiBlZGdlLmZyb21TaWRlID09PSBcInJpZ2h0XCIpO1xuICAgICAgICAgICAgICAgIGlmIChlZGdlUmlnaHRGcm9tKSB7XG4gICAgICAgICAgICAgICAgICAgIHRhcmdldE5vZGVJRCA9IGVkZ2VSaWdodEZyb20udG9Ob2RlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2VSaWdodFRvID0gZWRnZXMuZmluZCgoZWRnZSkgPT4gZWRnZS50b05vZGUgPT09IG5vZGVfaWQgJiYgZWRnZS50b1NpZGUgPT09IFwicmlnaHRcIik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlZGdlUmlnaHRUbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZUlEID0gZWRnZVJpZ2h0VG8uZnJvbU5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwibGVmdFwiOlxuICAgICAgICAgICAgICAgIC8vIEhhbmRsZSBib3RoICdmcm9tJyBhbmQgJ3RvJyBjYXNlcyBmb3IgJ2xlZnQnXG4gICAgICAgICAgICAgICAgY29uc3QgZWRnZUxlZnRGcm9tID0gZWRnZXMuZmluZCgoZWRnZSkgPT4gZWRnZS5mcm9tTm9kZSA9PT0gbm9kZV9pZCAmJiBlZGdlLmZyb21TaWRlID09PSBcImxlZnRcIik7XG4gICAgICAgICAgICAgICAgaWYgKGVkZ2VMZWZ0RnJvbSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlSUQgPSBlZGdlTGVmdEZyb20udG9Ob2RlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2VMZWZ0VG8gPSBlZGdlcy5maW5kKChlZGdlKSA9PiBlZGdlLnRvTm9kZSA9PT0gbm9kZV9pZCAmJiBlZGdlLnRvU2lkZSA9PT0gXCJsZWZ0XCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWRnZUxlZnRUbykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZUlEID0gZWRnZUxlZnRUby5mcm9tTm9kZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgXCJ0b3BcIjpcbiAgICAgICAgICAgICAgICAvLyBIYW5kbGUgYm90aCAnZnJvbScgYW5kICd0bycgY2FzZXMgZm9yICd0b3AnXG4gICAgICAgICAgICAgICAgY29uc3QgZWRnZVRvcEZyb20gPSBlZGdlcy5maW5kKChlZGdlKSA9PiBlZGdlLmZyb21Ob2RlID09PSBub2RlX2lkICYmIGVkZ2UuZnJvbVNpZGUgPT09IFwidG9wXCIpO1xuICAgICAgICAgICAgICAgIGlmIChlZGdlVG9wRnJvbSkge1xuICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlSUQgPSBlZGdlVG9wRnJvbS50b05vZGU7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZWRnZVRvcFRvID0gZWRnZXMuZmluZCgoZWRnZSkgPT4gZWRnZS50b05vZGUgPT09IG5vZGVfaWQgJiYgZWRnZS50b1NpZGUgPT09IFwidG9wXCIpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoZWRnZVRvcFRvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0YXJnZXROb2RlSUQgPSBlZGdlVG9wVG8uZnJvbU5vZGU7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIFwiYm90dG9tXCI6XG4gICAgICAgICAgICAgICAgLy8gSGFuZGxlIGJvdGggJ2Zyb20nIGFuZCAndG8nIGNhc2VzIGZvciAnYm90dG9tJ1xuICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2VCb3R0b21Gcm9tID0gZWRnZXMuZmluZCgoZWRnZSkgPT4gZWRnZS5mcm9tTm9kZSA9PT0gbm9kZV9pZCAmJiBlZGdlLmZyb21TaWRlID09PSBcImJvdHRvbVwiKTtcbiAgICAgICAgICAgICAgICBpZiAoZWRnZUJvdHRvbUZyb20pIHtcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZUlEID0gZWRnZUJvdHRvbUZyb20udG9Ob2RlO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVkZ2VCb3R0b21UbyA9IGVkZ2VzLmZpbmQoKGVkZ2UpID0+IGVkZ2UudG9Ob2RlID09PSBub2RlX2lkICYmIGVkZ2UudG9TaWRlID09PSBcImJvdHRvbVwiKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVkZ2VCb3R0b21Ubykge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFyZ2V0Tm9kZUlEID0gZWRnZUJvdHRvbVRvLmZyb21Ob2RlO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvbnN0IHZpZXdwb3J0Tm9kZXMgPSBjYW52YXMuZ2V0Vmlld3BvcnROb2RlcygpO1xuICAgICAgICBsZXQgdmlld3BvcnRfbm9kZXM6IFZpZXdwb3J0Tm9kZVtdID0gW107XG4gICAgICAgIGxldCBpbml0aWFsX3ZpZXdwb3J0X2NoaWxkcmVuID0gY2FudmFzLm5vZGVJbmRleC5kYXRhLmNoaWxkcmVuO1xuICAgICAgICBjb25zb2xlLmxvZyhcIlZpZXcgcG9ydCBub2Rlc1wiKTtcbiAgICAgICAgaWYgKGluaXRpYWxfdmlld3BvcnRfY2hpbGRyZW4ubGVuZ3RoID4gMSkge1xuICAgICAgICAgICAgZm9yIChsZXQgaSA9IDA7IGkgPCBpbml0aWFsX3ZpZXdwb3J0X2NoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgY29uc3Qgbm9kZXNfbGlzdCA9IGluaXRpYWxfdmlld3BvcnRfY2hpbGRyZW5baV0uY2hpbGRyZW47XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coeyBub2Rlc19saXN0IH0pO1xuICAgICAgICAgICAgICAgIG5vZGVzX2xpc3QuZm9yRWFjaCgobm9kZTogVmlld3BvcnROb2RlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHZpZXdwb3J0X25vZGVzLnB1c2gobm9kZSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBjb25zb2xlLmxvZyh2aWV3cG9ydF9ub2Rlcyk7XG4gICAgICAgIGNvbnNvbGUubG9nKHRhcmdldE5vZGVJRCk7XG5cbiAgICAgICAgaWYgKHRhcmdldE5vZGVJRCkge1xuICAgICAgICAgICAgY29uc3QgdGFyZ2V0X25vZGUgPSB2aWV3cG9ydF9ub2Rlcy5maW5kKChub2RlKSA9PiBub2RlLmlkID09PSB0YXJnZXROb2RlSUQpO1xuICAgICAgICAgICAgY29uc29sZS5sb2codGFyZ2V0X25vZGUpO1xuICAgICAgICAgICAgY29uc29sZS5sb2coXCJNYWtlcyBpdCBoZXJlXCIpO1xuXG4gICAgICAgICAgICAvLyBjb25zb2xlLmxvZyh7IHRhcmdldF9ub2RlIH0pO1xuICAgICAgICAgICAgY2FudmFzLnNlbGVjdE9ubHkodGFyZ2V0X25vZGUpO1xuICAgICAgICAgICAgY2FudmFzLnpvb21Ub1NlbGVjdGlvbigpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgYWRkR3JhcGhCdXR0b25JZk5lZWRlZChtZW51RWw6IEhUTUxFbGVtZW50KSB7XG4gICAgICAgIGlmICghbWVudUVsLnF1ZXJ5U2VsZWN0b3IoXCIuZ3JhcGgtbWVudS1pdGVtXCIpKSB7XG4gICAgICAgICAgICBjb25zdCBncmFwaEJ1dHRvbkVsID0gY3JlYXRlRWwoXCJidXR0b25cIiwgXCJjbGlja2FibGUtaWNvbiBncmFwaC1tZW51LWl0ZW1cIik7XG4gICAgICAgICAgICBzZXRUb29sdGlwKGdyYXBoQnV0dG9uRWwsIFwiQ3JlYXRlIE5vZGVcIiwgeyBwbGFjZW1lbnQ6IFwidG9wXCIgfSk7XG4gICAgICAgICAgICBzZXRJY29uKGdyYXBoQnV0dG9uRWwsIFwibHVjaWRlLXdvcmtmbG93XCIpO1xuICAgICAgICAgICAgZ3JhcGhCdXR0b25FbC5hZGRFdmVudExpc3RlbmVyKFwiY2xpY2tcIiwgKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKFwiR3JhcGggYnV0dG9uIGNsaWNrZWRcIik7XG4gICAgICAgICAgICAgICAgLy8gQXNzdW1pbmcgY2FudmFzVmlldyBpcyBhY2Nlc3NpYmxlIGhlcmUsIG9yIHlvdSBuZWVkIHRvIHBhc3MgaXQgc2ltaWxhcmx5XG4gICAgICAgICAgICAgICAgY29uc3QgY2FudmFzVmlldyA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWF2ZXNPZlR5cGUoXCJjYW52YXNcIikuZmlyc3QoKT8udmlldztcbiAgICAgICAgICAgICAgICBjb25zdCBjYW52YXMgPSBjYW52YXNWaWV3LmNhbnZhcztcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBjYW52YXMuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbkl0ZXJhdG9yID0gc2VsZWN0aW9uLnZhbHVlcygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBzZWxlY3Rpb25JdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgeCA9IG5vZGUueCArIG5vZGUud2lkdGggKyAyMDA7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGlsZE5vZGUoY2FudmFzLCBub2RlLCB4LCBub2RlLnksIFwiPHJvbGU+dXNlcjwvcm9sZT5cIik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIG1lbnVFbC5hcHBlbmRDaGlsZChncmFwaEJ1dHRvbkVsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGdldF9hbmNlc3RvcnMobm9kZXM6IE5vZGVbXSwgZWRnZXM6IEVkZ2VbXSwgbm9kZUlkOiBzdHJpbmcpOiBOb2RlW10ge1xuICAgICAgICBsZXQgYW5jZXN0b3JzOiBOb2RlW10gPSBbXTtcbiAgICAgICAgbGV0IGN1cnJlbnRJZDogc3RyaW5nID0gbm9kZUlkO1xuICAgICAgICBsZXQgcHJvY2Vzc2VkTm9kZXM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpO1xuXG4gICAgICAgIHdoaWxlICh0cnVlKSB7XG4gICAgICAgICAgICBjb25zdCBpbmNvbWluZ0VkZ2VzOiBFZGdlW10gPSBlZGdlcy5maWx0ZXIoKGVkZ2UpID0+IGVkZ2UudG9Ob2RlID09PSBjdXJyZW50SWQpO1xuICAgICAgICAgICAgaWYgKGluY29taW5nRWRnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgYnJlYWs7IC8vIE5vIG1vcmUgYW5jZXN0b3JzXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGN1cnJlbnRJZCA9IGluY29taW5nRWRnZXNbMF0uZnJvbU5vZGU7XG4gICAgICAgICAgICBpZiAocHJvY2Vzc2VkTm9kZXMuaGFzKGN1cnJlbnRJZCkpIHtcbiAgICAgICAgICAgICAgICBicmVhazsgLy8gQXZvaWQgaW5maW5pdGUgbG9vcHMgaW4gY3ljbGljIGdyYXBoc1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcHJvY2Vzc2VkTm9kZXMuYWRkKGN1cnJlbnRJZCk7XG5cbiAgICAgICAgICAgIGNvbnN0IGFuY2VzdG9yOiBOb2RlIHwgdW5kZWZpbmVkID0gbm9kZXMuZmluZCgobm9kZSkgPT4gbm9kZS5pZCA9PT0gY3VycmVudElkKTtcbiAgICAgICAgICAgIGlmIChhbmNlc3Rvcikge1xuICAgICAgICAgICAgICAgIGFuY2VzdG9ycy5wdXNoKGFuY2VzdG9yKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhbmNlc3RvcnM7XG4gICAgfVxuICAgIGdldEFsbEFuY2VzdG9yTm9kZXMobm9kZXM6IE5vZGVbXSwgZWRnZXM6IEVkZ2VbXSwgbm9kZUlkOiBzdHJpbmcpOiBOb2RlW10ge1xuICAgICAgICBsZXQgYW5jZXN0b3JzOiBOb2RlW10gPSBbXTtcbiAgICAgICAgbGV0IHF1ZXVlOiBzdHJpbmdbXSA9IFtub2RlSWRdO1xuICAgICAgICBsZXQgcHJvY2Vzc2VkTm9kZXM6IFNldDxzdHJpbmc+ID0gbmV3IFNldCgpO1xuXG4gICAgICAgIHdoaWxlIChxdWV1ZS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICBsZXQgY3VycmVudElkID0gcXVldWUuc2hpZnQoKTtcbiAgICAgICAgICAgIGlmICghY3VycmVudElkIHx8IHByb2Nlc3NlZE5vZGVzLmhhcyhjdXJyZW50SWQpKSBjb250aW51ZTtcblxuICAgICAgICAgICAgcHJvY2Vzc2VkTm9kZXMuYWRkKGN1cnJlbnRJZCk7XG4gICAgICAgICAgICBjb25zdCBpbmNvbWluZ0VkZ2VzOiBFZGdlW10gPSBlZGdlcy5maWx0ZXIoKGVkZ2UpID0+IGVkZ2UudG9Ob2RlID09PSBjdXJyZW50SWQpO1xuICAgICAgICAgICAgaW5jb21pbmdFZGdlcy5mb3JFYWNoKChlZGdlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5jZXN0b3IgPSBub2Rlcy5maW5kKChub2RlKSA9PiBub2RlLmlkID09PSBlZGdlLmZyb21Ob2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoYW5jZXN0b3IgJiYgIXByb2Nlc3NlZE5vZGVzLmhhcyhhbmNlc3Rvci5pZCkpIHtcbiAgICAgICAgICAgICAgICAgICAgYW5jZXN0b3JzLnB1c2goYW5jZXN0b3IpO1xuICAgICAgICAgICAgICAgICAgICBxdWV1ZS5wdXNoKGFuY2VzdG9yLmlkKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJldHVybiBhbmNlc3RvcnM7XG4gICAgfVxuICAgIGdldExvbmdlc3RMaW5lYWdlKG5vZGVzOiBOb2RlW10sIGVkZ2VzOiBFZGdlW10sIG5vZGVJZDogc3RyaW5nKTogTm9kZVtdIHtcbiAgICAgICAgbGV0IGxvbmdlc3RMaW5lYWdlOiBOb2RlW10gPSBbXTtcblxuICAgICAgICBmdW5jdGlvbiBmaW5kTG9uZ2VzdFBhdGgoY3VycmVudElkOiBzdHJpbmcsIHBhdGg6IE5vZGVbXSk6IHZvaWQge1xuICAgICAgICAgICAgY29uc3QgaW5jb21pbmdFZGdlczogRWRnZVtdID0gZWRnZXMuZmlsdGVyKChlZGdlKSA9PiBlZGdlLnRvTm9kZSA9PT0gY3VycmVudElkKTtcbiAgICAgICAgICAgIGlmIChpbmNvbWluZ0VkZ2VzLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSBjdXJyZW50IHBhdGggaXMgdGhlIGxvbmdlc3Qgd2UndmUgZW5jb3VudGVyZWRcbiAgICAgICAgICAgICAgICBpZiAocGF0aC5sZW5ndGggPiBsb25nZXN0TGluZWFnZS5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9uZ2VzdExpbmVhZ2UgPSBwYXRoLnNsaWNlKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaW5jb21pbmdFZGdlcy5mb3JFYWNoKChlZGdlKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgYW5jZXN0b3IgPSBub2Rlcy5maW5kKChub2RlKSA9PiBub2RlLmlkID09PSBlZGdlLmZyb21Ob2RlKTtcbiAgICAgICAgICAgICAgICBpZiAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgZmluZExvbmdlc3RQYXRoKGFuY2VzdG9yLmlkLCBwYXRoLmNvbmNhdChhbmNlc3RvcikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gU3RhcnQgd2l0aCB0aGUgZ2l2ZW4gbm9kZVxuICAgICAgICBjb25zdCBzdGFydE5vZGUgPSBub2Rlcy5maW5kKChub2RlKSA9PiBub2RlLmlkID09PSBub2RlSWQpO1xuICAgICAgICBpZiAoc3RhcnROb2RlKSB7XG4gICAgICAgICAgICBmaW5kTG9uZ2VzdFBhdGgobm9kZUlkLCBbc3RhcnROb2RlXSk7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gbG9uZ2VzdExpbmVhZ2U7XG4gICAgfVxuXG4gICAgYWRkQUlCdXR0b25JZk5lZWRlZChtZW51RWw6IEhUTUxFbGVtZW50KSB7XG4gICAgICAgIGlmICghbWVudUVsLnF1ZXJ5U2VsZWN0b3IoXCIuZ3B0LW1lbnUtaXRlbVwiKSkge1xuICAgICAgICAgICAgY29uc3QgYnV0dG9uRWwgPSBjcmVhdGVFbChcImJ1dHRvblwiLCBcImNsaWNrYWJsZS1pY29uIGdwdC1tZW51LWl0ZW1cIik7XG4gICAgICAgICAgICBzZXRUb29sdGlwKGJ1dHRvbkVsLCBcIlNwYXJrbGVcIiwgeyBwbGFjZW1lbnQ6IFwidG9wXCIgfSk7XG4gICAgICAgICAgICBzZXRJY29uKGJ1dHRvbkVsLCBcImx1Y2lkZS1zcGFya2xlc1wiKTtcbiAgICAgICAgICAgIGJ1dHRvbkVsLmFkZEV2ZW50TGlzdGVuZXIoXCJjbGlja1wiLCBhc3luYyAoKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FudmFzVmlldyA9IHRoaXMuYXBwLndvcmtzcGFjZS5nZXRMZWF2ZXNPZlR5cGUoXCJjYW52YXNcIikuZmlyc3QoKT8udmlldztcbiAgICAgICAgICAgICAgICBjb25zdCBjYW52YXMgPSBjYW52YXNWaWV3LmNhbnZhcztcbiAgICAgICAgICAgICAgICBjb25zdCBzZWxlY3Rpb24gPSBjYW52YXMuc2VsZWN0aW9uO1xuICAgICAgICAgICAgICAgIGNvbnN0IHNlbGVjdGlvbkl0ZXJhdG9yID0gc2VsZWN0aW9uLnZhbHVlcygpO1xuICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBzZWxlY3Rpb25JdGVyYXRvci5uZXh0KCkudmFsdWU7XG4gICAgICAgICAgICAgICAgY29uc3QgY2FudmFzX2RhdGEgPSBjYW52YXMuZ2V0RGF0YSgpO1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgZWRnZXMsIG5vZGVzIH0gPSBjYW52YXNfZGF0YTtcblxuICAgICAgICAgICAgICAgIC8vIGNvbnN0IGFuY2VzdG9ycyA9IHRoaXMuZ2V0X2FuY2VzdG9ycyhub2RlcywgZWRnZXMsIG5vZGUuaWQpO1xuICAgICAgICAgICAgICAgIC8vIGNvbnN0IGFsbF9hbmNlc3RvcnMgPSB0aGlzLmdldEFsbEFuY2VzdG9yTm9kZXMobm9kZXMsIGVkZ2VzLCBub2RlLmlkKTtcbiAgICAgICAgICAgICAgICBjb25zdCBsb25nZXN0X2xpbmVhZ2UgPSB0aGlzLmdldExvbmdlc3RMaW5lYWdlKG5vZGVzLCBlZGdlcywgbm9kZS5pZCk7XG4gICAgICAgICAgICAgICAgbGV0IGNvbnZlcnNhdGlvbiA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAobGV0IGkgPSAwOyBpIDwgbG9uZ2VzdF9saW5lYWdlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IG5vZGUgPSBsb25nZXN0X2xpbmVhZ2VbaV07XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHRleHQgPSBub2RlLnRleHQ7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHVzZXJSZWdleCA9IC88cm9sZT5Vc2VyPFxcL3JvbGU+L2k7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGFzc2lzdGFudFJlZ2V4ID0gLzxyb2xlPmFzc2lzdGFudDxcXC9yb2xlPi9pO1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICh1c2VyUmVnZXgudGVzdCh0ZXh0KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29uc3Qgc3BsaXRfdGV4dCA9IHRleHQuc3BsaXQodXNlclJlZ2V4KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IHJvbGUgPSBcInVzZXJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBzcGxpdF90ZXh0WzFdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChhc3Npc3RhbnRSZWdleC50ZXN0KHRleHQpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCBzcGxpdF90ZXh0ID0gdGV4dC5zcGxpdChhc3Npc3RhbnRSZWdleCk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25zdCByb2xlID0gXCJhc3Npc3RhbnRcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGNvbnRlbnQgPSBzcGxpdF90ZXh0WzFdLnRyaW0oKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IG1lc3NhZ2UgPSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcm9sZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5wdXNoKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNvbnZlcnNhdGlvbi5yZXZlcnNlKCk7XG4gICAgICAgICAgICAgICAgY29uc29sZS5sb2coeyBjb252ZXJzYXRpb24gfSk7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBkYXRhID0ge1xuICAgICAgICAgICAgICAgICAgICBjb252ZXJzYXRpb24sXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIFRoaXMgaXMgZm9yIGxvY2FsXG4gICAgICAgICAgICAgICAgLy8gdHJ5IHtcbiAgICAgICAgICAgICAgICAvLyAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChcImh0dHA6Ly9sb2NhbGhvc3Q6ODAwMC9jb252ZXJzYXRpb25cIiwge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgbWV0aG9kOiBcIlBPU1RcIixcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGhlYWRlcnM6IHtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgICAgICBcIkNvbnRlbnQtVHlwZVwiOiBcImFwcGxpY2F0aW9uL2pzb25cIixcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgLy8gICAgICAgICBib2R5OiBKU09OLnN0cmluZ2lmeShkYXRhKSxcbiAgICAgICAgICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gICAgIGNvbnN0IG91dHB1dCA9IGF3YWl0IHJlc3BvbnNlLmpzb24oKTtcbiAgICAgICAgICAgICAgICAvLyAgICAgY29uc29sZS5sb2cob3V0cHV0KTtcbiAgICAgICAgICAgICAgICAvLyAgICAgaWYgKG91dHB1dCkge1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgY29uc3QgY29udGVudCA9IGA8cm9sZT5hc3Npc3RhbnQ8L3JvbGU+XFxuJHtvdXRwdXQucmVzcG9uc2V9YDtcbiAgICAgICAgICAgICAgICAvLyAgICAgICAgIGNvbnN0IHggPSBub2RlLnggKyBub2RlLndpZHRoICsgMjAwO1xuICAgICAgICAgICAgICAgIC8vICAgICAgICAgdGhpcy5jaGlsZE5vZGUoY2FudmFzLCBub2RlLCB4LCBub2RlLnksIGNvbnRlbnQpO1xuICAgICAgICAgICAgICAgIC8vICAgICB9XG4gICAgICAgICAgICAgICAgLy8gfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgY29uc29sZS5lcnJvcihcIkVycm9yOlwiLCBlcnJvcik7XG4gICAgICAgICAgICAgICAgLy8gfVxuICAgICAgICAgICAgICAgIGNvbnN0IG1vZGVsID0gXCJsbGFtYTMtNzBiLTgxOTJcIjtcblxuICAgICAgICAgICAgICAgIGNvbnN0IHBhcmFtcyA9IHtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZXM6IGNvbnZlcnNhdGlvbixcbiAgICAgICAgICAgICAgICAgICAgbW9kZWw6IG1vZGVsLFxuICAgICAgICAgICAgICAgICAgICAvLyB0b29sczogdG9vbHMsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRvb2xfY2hvaWNlOiB0b29sX2Nob2ljZSxcbiAgICAgICAgICAgICAgICAgICAgbWF4X3Rva2VuczogMTIwMDAsXG4gICAgICAgICAgICAgICAgICAgIHN0b3A6IG51bGwsXG4gICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICBuZXcgTm90aWNlKFwiQ2FsbGluZyBHcm9xIVwiKTtcbiAgICAgICAgICAgICAgICBjb25zdCBjaGF0X2NvbXBsZXRpb246IE9wZW5BSS5DaGF0LkNoYXRDb21wbGV0aW9uID0gYXdhaXQgZ3JvcS5jaGF0LmNvbXBsZXRpb25zLmNyZWF0ZShwYXJhbXMpO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUubG9nKGNoYXRfY29tcGxldGlvbik7XG4gICAgICAgICAgICAgICAgY29uc3QgY29udGVudCA9IGNoYXRfY29tcGxldGlvbi5jaG9pY2VzWzBdLm1lc3NhZ2UuY29udGVudDtcbiAgICAgICAgICAgICAgICBjb25zdCBub2RlX2NvbnRlbnQgPSBgPHJvbGU+YXNzaXN0YW50PC9yb2xlPlxcbiR7Y29udGVudH1gO1xuICAgICAgICAgICAgICAgIGNvbnN0IHggPSBub2RlLnggKyBub2RlLndpZHRoICsgMjAwO1xuICAgICAgICAgICAgICAgIHRoaXMuY2hpbGROb2RlKGNhbnZhcywgbm9kZSwgeCwgbm9kZS55LCBub2RlX2NvbnRlbnQsIFwicmlnaHRcIiwgXCJsZWZ0XCIsIFwiZ3JvcVwiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgbWVudUVsLmFwcGVuZENoaWxkKGJ1dHRvbkVsKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGNoaWxkTm9kZSA9IGFzeW5jIChcbiAgICAgICAgY2FudmFzOiBDYW52YXMsXG4gICAgICAgIHBhcmVudE5vZGU6IENhbnZhc05vZGVEYXRhLFxuICAgICAgICB4OiBudW1iZXIsXG4gICAgICAgIHk6IG51bWJlcixcbiAgICAgICAgY29udGVudDogc3RyaW5nID0gXCJcIixcbiAgICAgICAgZnJvbV9zaWRlOiBzdHJpbmcgPSBcInJpZ2h0XCIsXG4gICAgICAgIHRvX3NpZGU6IHN0cmluZyA9IFwibGVmdFwiLFxuICAgICAgICBvcmlnaW46IHN0cmluZyA9IFwiaWdub3JlXCJcbiAgICApID0+IHtcbiAgICAgICAgbGV0IHRlbXBDaGlsZE5vZGUgPSB0aGlzLmFkZE5vZGUoY2FudmFzLCB0aGlzLnJhbmRvbSgxNiksIHtcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgd2lkdGg6IHBhcmVudE5vZGUud2lkdGgsXG4gICAgICAgICAgICBoZWlnaHQ6IHBhcmVudE5vZGUuaGVpZ2h0LFxuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIsXG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICB9KTtcbiAgICAgICAgYXdhaXQgdGhpcy5jcmVhdGVFZGdlKHBhcmVudE5vZGUsIHRlbXBDaGlsZE5vZGUsIGNhbnZhcywgZnJvbV9zaWRlLCB0b19zaWRlKTtcblxuICAgICAgICBjb25zdCBub2RlID0gY2FudmFzLm5vZGVzPy5nZXQodGVtcENoaWxkTm9kZT8uaWQhKTtcbiAgICAgICAgaWYgKCFub2RlKSByZXR1cm47XG4gICAgICAgIGlmIChvcmlnaW4gPT09IFwiZ3JvcVwiKSB7XG4gICAgICAgICAgICBuZXcgTm90aWNlKFwiTWVzc2FnZSBiYWNrIGZyb20gR3JvcVwiKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIGNhbnZhcy5zZWxlY3RPbmx5KG5vZGUpO1xuXG4gICAgICAgIGNhbnZhcy5yZXF1ZXN0U2F2ZSgpO1xuXG4gICAgICAgIHJldHVybiB0ZW1wQ2hpbGROb2RlO1xuICAgIH07XG5cbiAgICBhZGROb2RlID0gKFxuICAgICAgICBjYW52YXM6IENhbnZhcyxcbiAgICAgICAgaWQ6IHN0cmluZyxcbiAgICAgICAge1xuICAgICAgICAgICAgeCxcbiAgICAgICAgICAgIHksXG4gICAgICAgICAgICB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICBjb250ZW50LFxuICAgICAgICAgICAgc3VicGF0aCxcbiAgICAgICAgfToge1xuICAgICAgICAgICAgeDogbnVtYmVyO1xuICAgICAgICAgICAgeTogbnVtYmVyO1xuICAgICAgICAgICAgd2lkdGg6IG51bWJlcjtcbiAgICAgICAgICAgIGhlaWdodDogbnVtYmVyO1xuICAgICAgICAgICAgdHlwZTogXCJ0ZXh0XCIgfCBcImZpbGVcIjtcbiAgICAgICAgICAgIGNvbnRlbnQ6IHN0cmluZztcbiAgICAgICAgICAgIHN1YnBhdGg/OiBzdHJpbmc7XG4gICAgICAgIH1cbiAgICApID0+IHtcbiAgICAgICAgaWYgKCFjYW52YXMpIHJldHVybjtcblxuICAgICAgICBjb25zdCBkYXRhID0gY2FudmFzLmdldERhdGEoKTtcbiAgICAgICAgaWYgKCFkYXRhKSByZXR1cm47XG5cbiAgICAgICAgY29uc3Qgbm9kZTogUGFydGlhbDxDYW52YXNUZXh0RGF0YSB8IENhbnZhc0ZpbGVEYXRhPiA9IHtcbiAgICAgICAgICAgIGlkOiBpZCxcbiAgICAgICAgICAgIHg6IHgsXG4gICAgICAgICAgICB5OiB5LFxuICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgaGVpZ2h0OiBoZWlnaHQsXG4gICAgICAgICAgICB0eXBlOiB0eXBlLFxuICAgICAgICB9O1xuXG4gICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgY2FzZSBcInRleHRcIjpcbiAgICAgICAgICAgICAgICBub2RlLnRleHQgPSBjb250ZW50O1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBcImZpbGVcIjpcbiAgICAgICAgICAgICAgICBub2RlLmZpbGUgPSBjb250ZW50O1xuICAgICAgICAgICAgICAgIGlmIChzdWJwYXRoKSBub2RlLnN1YnBhdGggPSBzdWJwYXRoO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG5cbiAgICAgICAgY2FudmFzLmltcG9ydERhdGEoPENhbnZhc0RhdGE+e1xuICAgICAgICAgICAgbm9kZXM6IFsuLi5kYXRhLm5vZGVzLCBub2RlXSxcbiAgICAgICAgICAgIGVkZ2VzOiBkYXRhLmVkZ2VzLFxuICAgICAgICB9KTtcblxuICAgICAgICBjYW52YXMucmVxdWVzdEZyYW1lKCk7XG5cbiAgICAgICAgcmV0dXJuIG5vZGU7XG4gICAgfTtcbiAgICBjcmVhdGVFZGdlID0gYXN5bmMgKG5vZGUxOiBhbnksIG5vZGUyOiBhbnksIGNhbnZhczogYW55LCBmcm9tX3NpZGU6IHN0cmluZyA9IFwicmlnaHRcIiwgdG9fc2lkZTogc3RyaW5nID0gXCJsZWZ0XCIpID0+IHtcbiAgICAgICAgdGhpcy5hZGRFZGdlKFxuICAgICAgICAgICAgY2FudmFzLFxuICAgICAgICAgICAgdGhpcy5yYW5kb20oMTYpLFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZyb21PclRvOiBcImZyb21cIixcbiAgICAgICAgICAgICAgICBzaWRlOiBmcm9tX3NpZGUsXG4gICAgICAgICAgICAgICAgbm9kZTogbm9kZTEsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgIGZyb21PclRvOiBcInRvXCIsXG4gICAgICAgICAgICAgICAgc2lkZTogdG9fc2lkZSxcbiAgICAgICAgICAgICAgICBub2RlOiBub2RlMixcbiAgICAgICAgICAgIH1cbiAgICAgICAgKTtcbiAgICB9O1xuICAgIC8vIFRPRE8gLSBDaGFuZ2UgdGhpc1xuICAgIHJhbmRvbSA9IChlOiBudW1iZXIpID0+IHtcbiAgICAgICAgbGV0IHQgPSBbXTtcbiAgICAgICAgZm9yIChsZXQgbiA9IDA7IG4gPCBlOyBuKyspIHtcbiAgICAgICAgICAgIHQucHVzaCgoKDE2ICogTWF0aC5yYW5kb20oKSkgfCAwKS50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0LmpvaW4oXCJcIik7XG4gICAgfTtcbiAgICBhZGRFZGdlID0gKGNhbnZhczogYW55LCBlZGdlSUQ6IHN0cmluZywgZnJvbUVkZ2U6IGVkZ2VULCB0b0VkZ2U6IGVkZ2VUKSA9PiB7XG4gICAgICAgIGlmICghY2FudmFzKSByZXR1cm47XG5cbiAgICAgICAgY29uc3QgZGF0YSA9IGNhbnZhcy5nZXREYXRhKCk7XG4gICAgICAgIGlmICghZGF0YSkgcmV0dXJuO1xuXG4gICAgICAgIGNhbnZhcy5pbXBvcnREYXRhKHtcbiAgICAgICAgICAgIGVkZ2VzOiBbXG4gICAgICAgICAgICAgICAgLi4uZGF0YS5lZGdlcyxcbiAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGlkOiBlZGdlSUQsXG4gICAgICAgICAgICAgICAgICAgIGZyb21Ob2RlOiBmcm9tRWRnZS5ub2RlLmlkLFxuICAgICAgICAgICAgICAgICAgICBmcm9tU2lkZTogZnJvbUVkZ2Uuc2lkZSxcbiAgICAgICAgICAgICAgICAgICAgdG9Ob2RlOiB0b0VkZ2Uubm9kZS5pZCxcbiAgICAgICAgICAgICAgICAgICAgdG9TaWRlOiB0b0VkZ2Uuc2lkZSxcbiAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgXSxcbiAgICAgICAgICAgIG5vZGVzOiBkYXRhLm5vZGVzLFxuICAgICAgICB9KTtcblxuICAgICAgICBjYW52YXMucmVxdWVzdEZyYW1lKCk7XG4gICAgfTtcblxuICAgIC8vIE1ldGhvZCB0byBpbnNlcnQgdGV4dCBpbnRvIHRoZSBzaWRlYmFyXG4gICAgaW5zZXJ0VGV4dEludG9TaWRlYmFyKHRleHQ6IHN0cmluZykge1xuICAgICAgICBjb25zdCB0cmltbWVkX3RleHQgPSB0ZXh0LnRyaW0oKTtcbiAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLml0ZXJhdGVBbGxMZWF2ZXMoKGxlYWYpID0+IHtcbiAgICAgICAgICAgIGlmIChsZWFmLnZpZXcuZ2V0Vmlld1R5cGUoKSA9PT0gVklFV19OQU1FX1NJREVCQVJfQ0hBVCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBsZWFmLnZpZXcgYXMgU2lkZWJhckNoYXQ7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXcudGV4dEJveCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LnRleHRCb3gudmFsdWUgKz0gdHJpbW1lZF90ZXh0O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gTWV0aG9kIHRvIGNsZWFyIHRleHQgZnJvbSB0aGUgc2lkZWJhclxuICAgIGNsZWFyVGV4dEluU2lkZWJhcigpIHtcbiAgICAgICAgdGhpcy5hcHAud29ya3NwYWNlLml0ZXJhdGVBbGxMZWF2ZXMoKGxlYWYpID0+IHtcbiAgICAgICAgICAgIGlmIChsZWFmLnZpZXcuZ2V0Vmlld1R5cGUoKSA9PT0gVklFV19OQU1FX1NJREVCQVJfQ0hBVCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHZpZXcgPSBsZWFmLnZpZXcgYXMgU2lkZWJhckNoYXQ7XG4gICAgICAgICAgICAgICAgaWYgKHZpZXcudGV4dEJveCkge1xuICAgICAgICAgICAgICAgICAgICB2aWV3LnRleHRCb3gudmFsdWUgPSBcIlwiOyAvLyBDbGVhciB0aGUgdGV4dCBib3hcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHZpZXcubWVzc2FnZXNDb250YWluZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmlldy5tZXNzYWdlc0NvbnRhaW5lci5pbm5lckhUTUwgPSBcIlwiOyAvLyBDbGVhciB0aGUgbWVzc2FnZXMgY29udGFpbmVyXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG4gICAgYWRkU2lkZWJhclRhYigpIHtcbiAgICAgICAgdGhpcy5hZGRSaWJib25JY29uKFwiZG9jdW1lbnRcIiwgXCJPcGVuIENhcmV0XCIsIGFzeW5jIChldnQpID0+IHtcbiAgICAgICAgICAgIC8vIENoZWNrIGlmIHRoZSB2aWV3IGlzIGFscmVhZHkgcHJlc2VudCBpbiBhbnkgbGVhZlxuXG4gICAgICAgICAgICAvLyBUaGlzIGNyZWF0ZXMgdGhlIHZpZXcgaW4gdGhlIHNpZGViYXJcbiAgICAgICAgICAgIC8vIGxldCBmb3VuZCA9IGZhbHNlO1xuICAgICAgICAgICAgLy8gdGhpcy5hcHAud29ya3NwYWNlLml0ZXJhdGVBbGxMZWF2ZXMoKGxlYWYpID0+IHtcbiAgICAgICAgICAgIC8vICAgICBpZiAobGVhZi52aWV3LmdldFZpZXdUeXBlKCkgPT09IFZJRVdfTkFNRV9TSURFQkFSX0NIQVQpIHtcbiAgICAgICAgICAgIC8vICAgICAgICAgZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgLy8gICAgICAgICAvLyBJZiB0aGUgdmlldyBpcyBub3QgdGhlIGFjdGl2ZSB2aWV3LCBicmluZyBpdCBpbnRvIGZvY3VzXG4gICAgICAgICAgICAvLyAgICAgICAgIGlmICghbGVhZi52aWV3LmNvbnRhaW5lckVsLnBhcmVudEVsZW1lbnQuY2xhc3NMaXN0LmNvbnRhaW5zKFwiaXMtYWN0aXZlXCIpKSB7XG4gICAgICAgICAgICAvLyAgICAgICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2UucmV2ZWFsTGVhZihsZWFmKTtcbiAgICAgICAgICAgIC8vICAgICAgICAgfVxuICAgICAgICAgICAgLy8gICAgIH1cbiAgICAgICAgICAgIC8vIH0pO1xuXG4gICAgICAgICAgICAvLyAvLyBJZiB0aGUgdmlldyB3YXMgbm90IGZvdW5kLCBjcmVhdGUgaXQgaW4gdGhlIHJpZ2h0IHNpZGViYXJcbiAgICAgICAgICAgIC8vIGlmICghZm91bmQpIHtcbiAgICAgICAgICAgIC8vICAgICBhd2FpdCB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0UmlnaHRMZWFmKGZhbHNlKS5zZXRWaWV3U3RhdGUoe1xuICAgICAgICAgICAgLy8gICAgICAgICB0eXBlOiBWSUVXX05BTUVfU0lERUJBUl9DSEFULFxuICAgICAgICAgICAgLy8gICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgICAgICAvLyAgICAgfSk7XG4gICAgICAgICAgICAvLyAgICAgdGhpcy5hcHAud29ya3NwYWNlLnJldmVhbExlYWYodGhpcy5hcHAud29ya3NwYWNlLmdldExlYWYodHJ1ZSkpO1xuICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICBsZXQgbWFpbl9jaGF0X2ZvdW5kID0gZmFsc2U7XG4gICAgICAgICAgICB0aGlzLmFwcC53b3Jrc3BhY2UuaXRlcmF0ZUFsbExlYXZlcygobGVhZikgPT4ge1xuICAgICAgICAgICAgICAgIGlmIChsZWFmLnZpZXcuZ2V0Vmlld1R5cGUoKSA9PT0gVklFV19OQU1FX01BSU5fQ0hBVCkge1xuICAgICAgICAgICAgICAgICAgICBtYWluX2NoYXRfZm91bmQgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICAvLyBJZiB0aGUgdmlldyBpcyBub3QgdGhlIGFjdGl2ZSB2aWV3LCBicmluZyBpdCBpbnRvIGZvY3VzXG4gICAgICAgICAgICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFsZWFmLnZpZXcuY29udGFpbmVyRWwucGFyZW50RWxlbWVudC5jbGFzc0xpc3QuY29udGFpbnMoXCJpcy1hY3RpdmVcIikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuYXBwLndvcmtzcGFjZS5yZXZlYWxMZWFmKGxlYWYpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG5cbiAgICAgICAgICAgIC8vIElmIHRoZSB2aWV3IHdhcyBub3QgZm91bmQsIGNyZWF0ZSBpdCBpbiB0aGUgcmlnaHQgc2lkZWJhclxuICAgICAgICAgICAgaWYgKCFtYWluX2NoYXRfZm91bmQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCB0aGlzLmFwcC53b3Jrc3BhY2UuZ2V0TGVhZih0cnVlKS5zZXRWaWV3U3RhdGUoe1xuICAgICAgICAgICAgICAgICAgICB0eXBlOiBWSUVXX05BTUVfTUFJTl9DSEFULFxuICAgICAgICAgICAgICAgICAgICBhY3RpdmU6IHRydWUsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgLy8gdGhpcy5hcHAud29ya3NwYWNlLnJldmVhbExlYWYodGhpcy5hcHAud29ya3NwYWNlLmdldExlYWYodHJ1ZSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9XG5cbiAgICBvbnVubG9hZCgpIHt9XG5cbiAgICBhc3luYyBsb2FkU2V0dGluZ3MoKSB7XG4gICAgICAgIHRoaXMuc2V0dGluZ3MgPSBPYmplY3QuYXNzaWduKHt9LCBERUZBVUxUX1NFVFRJTkdTLCBhd2FpdCB0aGlzLmxvYWREYXRhKCkpO1xuICAgIH1cblxuICAgIGFzeW5jIHNhdmVTZXR0aW5ncygpIHtcbiAgICAgICAgYXdhaXQgdGhpcy5zYXZlRGF0YSh0aGlzLnNldHRpbmdzKTtcbiAgICB9XG59XG5cbmNsYXNzIFNhbXBsZVNldHRpbmdUYWIgZXh0ZW5kcyBQbHVnaW5TZXR0aW5nVGFiIHtcbiAgICBwbHVnaW46IE15UGx1Z2luO1xuXG4gICAgY29uc3RydWN0b3IoYXBwOiBBcHAsIHBsdWdpbjogTXlQbHVnaW4pIHtcbiAgICAgICAgc3VwZXIoYXBwLCBwbHVnaW4pO1xuICAgICAgICB0aGlzLnBsdWdpbiA9IHBsdWdpbjtcbiAgICB9XG5cbiAgICBkaXNwbGF5KCk6IHZvaWQge1xuICAgICAgICBjb25zdCB7IGNvbnRhaW5lckVsIH0gPSB0aGlzO1xuXG4gICAgICAgIGNvbnRhaW5lckVsLmVtcHR5KCk7XG5cbiAgICAgICAgbmV3IFNldHRpbmcoY29udGFpbmVyRWwpXG4gICAgICAgICAgICAuc2V0TmFtZShcIlNldHRpbmcgIzFcIilcbiAgICAgICAgICAgIC5zZXREZXNjKFwiSXQncyBhIHNlY3JldFwiKVxuICAgICAgICAgICAgLmFkZFRleHQoKHRleHQpID0+XG4gICAgICAgICAgICAgICAgdGV4dFxuICAgICAgICAgICAgICAgICAgICAuc2V0UGxhY2Vob2xkZXIoXCJFbnRlciB5b3VyIHNlY3JldFwiKVxuICAgICAgICAgICAgICAgICAgICAuc2V0VmFsdWUodGhpcy5wbHVnaW4uc2V0dGluZ3MubXlTZXR0aW5nKVxuICAgICAgICAgICAgICAgICAgICAub25DaGFuZ2UoYXN5bmMgKHZhbHVlKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnBsdWdpbi5zZXR0aW5ncy5teVNldHRpbmcgPSB2YWx1ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGF3YWl0IHRoaXMucGx1Z2luLnNhdmVTZXR0aW5ncygpO1xuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgKTtcbiAgICB9XG59XG4iLCAiZXhwb3J0IGNvbnN0IFZFUlNJT04gPSAnMC4zLjMnOyAvLyB4LXJlbGVhc2UtcGxlYXNlLXZlcnNpb25cbiIsICIvKipcbiAqIERpc2NsYWltZXI6IG1vZHVsZXMgaW4gX3NoaW1zIGFyZW4ndCBpbnRlbmRlZCB0byBiZSBpbXBvcnRlZCBieSBTREsgdXNlcnMuXG4gKi9cbmltcG9ydCB7IHR5cGUgUmVxdWVzdE9wdGlvbnMgfSBmcm9tICcuLi9jb3JlJztcblxuZXhwb3J0IGludGVyZmFjZSBTaGltcyB7XG4gIGtpbmQ6IHN0cmluZztcbiAgZmV0Y2g6IGFueTtcbiAgUmVxdWVzdDogYW55O1xuICBSZXNwb25zZTogYW55O1xuICBIZWFkZXJzOiBhbnk7XG4gIEZvcm1EYXRhOiBhbnk7XG4gIEJsb2I6IGFueTtcbiAgRmlsZTogYW55O1xuICBSZWFkYWJsZVN0cmVhbTogYW55O1xuICBnZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9uczogPFQgPSBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPj4oXG4gICAgZm9ybTogU2hpbXNbJ0Zvcm1EYXRhJ10sXG4gICAgb3B0czogUmVxdWVzdE9wdGlvbnM8VD4sXG4gICkgPT4gUHJvbWlzZTxSZXF1ZXN0T3B0aW9uczxUPj47XG4gIGdldERlZmF1bHRBZ2VudDogKHVybDogc3RyaW5nKSA9PiBhbnk7XG4gIGZpbGVGcm9tUGF0aDpcbiAgICB8ICgocGF0aDogc3RyaW5nLCBmaWxlbmFtZT86IHN0cmluZywgb3B0aW9ucz86IHt9KSA9PiBQcm9taXNlPFNoaW1zWydGaWxlJ10+KVxuICAgIHwgKChwYXRoOiBzdHJpbmcsIG9wdGlvbnM/OiB7fSkgPT4gUHJvbWlzZTxTaGltc1snRmlsZSddPik7XG4gIGlzRnNSZWFkU3RyZWFtOiAodmFsdWU6IGFueSkgPT4gYm9vbGVhbjtcbn1cblxuZXhwb3J0IGxldCBhdXRvID0gZmFsc2U7XG5leHBvcnQgbGV0IGtpbmQ6IFNoaW1zWydraW5kJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGZldGNoOiBTaGltc1snZmV0Y2gnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgUmVxdWVzdDogU2hpbXNbJ1JlcXVlc3QnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgUmVzcG9uc2U6IFNoaW1zWydSZXNwb25zZSddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBIZWFkZXJzOiBTaGltc1snSGVhZGVycyddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBGb3JtRGF0YTogU2hpbXNbJ0Zvcm1EYXRhJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IEJsb2I6IFNoaW1zWydCbG9iJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IEZpbGU6IFNoaW1zWydGaWxlJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IFJlYWRhYmxlU3RyZWFtOiBTaGltc1snUmVhZGFibGVTdHJlYW0nXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnM6IFNoaW1zWydnZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9ucyddIHwgdW5kZWZpbmVkID0gdW5kZWZpbmVkO1xuZXhwb3J0IGxldCBnZXREZWZhdWx0QWdlbnQ6IFNoaW1zWydnZXREZWZhdWx0QWdlbnQnXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcbmV4cG9ydCBsZXQgZmlsZUZyb21QYXRoOiBTaGltc1snZmlsZUZyb21QYXRoJ10gfCB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5leHBvcnQgbGV0IGlzRnNSZWFkU3RyZWFtOiBTaGltc1snaXNGc1JlYWRTdHJlYW0nXSB8IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuZXhwb3J0IGZ1bmN0aW9uIHNldFNoaW1zKHNoaW1zOiBTaGltcywgb3B0aW9uczogeyBhdXRvOiBib29sZWFuIH0gPSB7IGF1dG86IGZhbHNlIH0pIHtcbiAgaWYgKGF1dG8pIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICBgeW91IG11c3QgXFxgaW1wb3J0ICdncm9xLXNkay9zaGltcy8ke3NoaW1zLmtpbmR9J1xcYCBiZWZvcmUgaW1wb3J0aW5nIGFueXRoaW5nIGVsc2UgZnJvbSBncm9xLXNka2AsXG4gICAgKTtcbiAgfVxuICBpZiAoa2luZCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBjYW4ndCBcXGBpbXBvcnQgJ2dyb3Etc2RrL3NoaW1zLyR7c2hpbXMua2luZH0nXFxgIGFmdGVyIFxcYGltcG9ydCAnZ3JvcS1zZGsvc2hpbXMvJHtraW5kfSdcXGBgLFxuICAgICk7XG4gIH1cbiAgYXV0byA9IG9wdGlvbnMuYXV0bztcbiAga2luZCA9IHNoaW1zLmtpbmQ7XG4gIGZldGNoID0gc2hpbXMuZmV0Y2g7XG4gIFJlcXVlc3QgPSBzaGltcy5SZXF1ZXN0O1xuICBSZXNwb25zZSA9IHNoaW1zLlJlc3BvbnNlO1xuICBIZWFkZXJzID0gc2hpbXMuSGVhZGVycztcbiAgRm9ybURhdGEgPSBzaGltcy5Gb3JtRGF0YTtcbiAgQmxvYiA9IHNoaW1zLkJsb2I7XG4gIEZpbGUgPSBzaGltcy5GaWxlO1xuICBSZWFkYWJsZVN0cmVhbSA9IHNoaW1zLlJlYWRhYmxlU3RyZWFtO1xuICBnZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9ucyA9IHNoaW1zLmdldE11bHRpcGFydFJlcXVlc3RPcHRpb25zO1xuICBnZXREZWZhdWx0QWdlbnQgPSBzaGltcy5nZXREZWZhdWx0QWdlbnQ7XG4gIGZpbGVGcm9tUGF0aCA9IHNoaW1zLmZpbGVGcm9tUGF0aDtcbiAgaXNGc1JlYWRTdHJlYW0gPSBzaGltcy5pc0ZzUmVhZFN0cmVhbTtcbn1cbiIsICIvKipcbiAqIERpc2NsYWltZXI6IG1vZHVsZXMgaW4gX3NoaW1zIGFyZW4ndCBpbnRlbmRlZCB0byBiZSBpbXBvcnRlZCBieSBTREsgdXNlcnMuXG4gKi9cbmV4cG9ydCBjbGFzcyBNdWx0aXBhcnRCb2R5IHtcbiAgY29uc3RydWN0b3IocHVibGljIGJvZHk6IGFueSkge31cbiAgZ2V0IFtTeW1ib2wudG9TdHJpbmdUYWddKCk6IHN0cmluZyB7XG4gICAgcmV0dXJuICdNdWx0aXBhcnRCb2R5JztcbiAgfVxufVxuIiwgIi8qKlxuICogRGlzY2xhaW1lcjogbW9kdWxlcyBpbiBfc2hpbXMgYXJlbid0IGludGVuZGVkIHRvIGJlIGltcG9ydGVkIGJ5IFNESyB1c2Vycy5cbiAqL1xuaW1wb3J0IHsgTXVsdGlwYXJ0Qm9keSB9IGZyb20gJy4vTXVsdGlwYXJ0Qm9keSc7XG5pbXBvcnQgeyB0eXBlIFJlcXVlc3RPcHRpb25zIH0gZnJvbSAnLi4vY29yZSc7XG5pbXBvcnQgeyB0eXBlIFNoaW1zIH0gZnJvbSAnLi9yZWdpc3RyeSc7XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRSdW50aW1lKHsgbWFudWFsbHlJbXBvcnRlZCB9OiB7IG1hbnVhbGx5SW1wb3J0ZWQ/OiBib29sZWFuIH0gPSB7fSk6IFNoaW1zIHtcbiAgY29uc3QgcmVjb21tZW5kYXRpb24gPVxuICAgIG1hbnVhbGx5SW1wb3J0ZWQgP1xuICAgICAgYFlvdSBtYXkgbmVlZCB0byB1c2UgcG9seWZpbGxzYFxuICAgIDogYEFkZCBvbmUgb2YgdGhlc2UgaW1wb3J0cyBiZWZvcmUgeW91ciBmaXJzdCBcXGBpbXBvcnQgXHUyMDI2IGZyb20gJ2dyb3Etc2RrJ1xcYDpcbi0gXFxgaW1wb3J0ICdncm9xLXNkay9zaGltcy9ub2RlJ1xcYCAoaWYgeW91J3JlIHJ1bm5pbmcgb24gTm9kZSlcbi0gXFxgaW1wb3J0ICdncm9xLXNkay9zaGltcy93ZWInXFxgIChvdGhlcndpc2UpXG5gO1xuXG4gIGxldCBfZmV0Y2gsIF9SZXF1ZXN0LCBfUmVzcG9uc2UsIF9IZWFkZXJzO1xuICB0cnkge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBfZmV0Y2ggPSBmZXRjaDtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgX1JlcXVlc3QgPSBSZXF1ZXN0O1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBfUmVzcG9uc2UgPSBSZXNwb25zZTtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgX0hlYWRlcnMgPSBIZWFkZXJzO1xuICB9IGNhdGNoIChlcnJvcikge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGB0aGlzIGVudmlyb25tZW50IGlzIG1pc3NpbmcgdGhlIGZvbGxvd2luZyBXZWIgRmV0Y2ggQVBJIHR5cGU6ICR7XG4gICAgICAgIChlcnJvciBhcyBhbnkpLm1lc3NhZ2VcbiAgICAgIH0uICR7cmVjb21tZW5kYXRpb259YCxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHtcbiAgICBraW5kOiAnd2ViJyxcbiAgICBmZXRjaDogX2ZldGNoLFxuICAgIFJlcXVlc3Q6IF9SZXF1ZXN0LFxuICAgIFJlc3BvbnNlOiBfUmVzcG9uc2UsXG4gICAgSGVhZGVyczogX0hlYWRlcnMsXG4gICAgRm9ybURhdGE6XG4gICAgICAvLyBAdHMtaWdub3JlXG4gICAgICB0eXBlb2YgRm9ybURhdGEgIT09ICd1bmRlZmluZWQnID8gRm9ybURhdGEgOiAoXG4gICAgICAgIGNsYXNzIEZvcm1EYXRhIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgY29uc3RydWN0b3IoKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICAgICAgIGBmaWxlIHVwbG9hZHMgYXJlbid0IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50IHlldCBhcyAnRm9ybURhdGEnIGlzIHVuZGVmaW5lZC4gJHtyZWNvbW1lbmRhdGlvbn1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgQmxvYjpcbiAgICAgIHR5cGVvZiBCbG9iICE9PSAndW5kZWZpbmVkJyA/IEJsb2IgOiAoXG4gICAgICAgIGNsYXNzIEJsb2Ige1xuICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgZmlsZSB1cGxvYWRzIGFyZW4ndCBzdXBwb3J0ZWQgaW4gdGhpcyBlbnZpcm9ubWVudCB5ZXQgYXMgJ0Jsb2InIGlzIHVuZGVmaW5lZC4gJHtyZWNvbW1lbmRhdGlvbn1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgRmlsZTpcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIHR5cGVvZiBGaWxlICE9PSAndW5kZWZpbmVkJyA/IEZpbGUgOiAoXG4gICAgICAgIGNsYXNzIEZpbGUge1xuICAgICAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgICAgICBjb25zdHJ1Y3RvcigpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgICAgICAgICAgYGZpbGUgdXBsb2FkcyBhcmVuJ3Qgc3VwcG9ydGVkIGluIHRoaXMgZW52aXJvbm1lbnQgeWV0IGFzICdGaWxlJyBpcyB1bmRlZmluZWQuICR7cmVjb21tZW5kYXRpb259YCxcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICApLFxuICAgIFJlYWRhYmxlU3RyZWFtOlxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgdHlwZW9mIFJlYWRhYmxlU3RyZWFtICE9PSAndW5kZWZpbmVkJyA/IFJlYWRhYmxlU3RyZWFtIDogKFxuICAgICAgICBjbGFzcyBSZWFkYWJsZVN0cmVhbSB7XG4gICAgICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgICAgIGNvbnN0cnVjdG9yKCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAgICAgICBgc3RyZWFtaW5nIGlzbid0IHN1cHBvcnRlZCBpbiB0aGlzIGVudmlyb25tZW50IHlldCBhcyAnUmVhZGFibGVTdHJlYW0nIGlzIHVuZGVmaW5lZC4gJHtyZWNvbW1lbmRhdGlvbn1gLFxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICksXG4gICAgZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnM6IGFzeW5jIDxUID0gUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KFxuICAgICAgLy8gQHRzLWlnbm9yZVxuICAgICAgZm9ybTogRm9ybURhdGEsXG4gICAgICBvcHRzOiBSZXF1ZXN0T3B0aW9uczxUPixcbiAgICApOiBQcm9taXNlPFJlcXVlc3RPcHRpb25zPFQ+PiA9PiAoe1xuICAgICAgLi4ub3B0cyxcbiAgICAgIGJvZHk6IG5ldyBNdWx0aXBhcnRCb2R5KGZvcm0pIGFzIGFueSxcbiAgICB9KSxcbiAgICBnZXREZWZhdWx0QWdlbnQ6ICh1cmw6IHN0cmluZykgPT4gdW5kZWZpbmVkLFxuICAgIGZpbGVGcm9tUGF0aDogKCkgPT4ge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVGhlIGBmaWxlRnJvbVBhdGhgIGZ1bmN0aW9uIGlzIG9ubHkgc3VwcG9ydGVkIGluIE5vZGUuIFNlZSB0aGUgUkVBRE1FIGZvciBtb3JlIGRldGFpbHM6IGh0dHBzOi8vd3d3LmdpdGh1Yi5jb20vZ3JvcS9ncm9xLXR5cGVzY3JpcHQjZmlsZS11cGxvYWRzJyxcbiAgICAgICk7XG4gICAgfSxcbiAgICBpc0ZzUmVhZFN0cmVhbTogKHZhbHVlOiBhbnkpID0+IGZhbHNlLFxuICB9O1xufVxuIiwgIi8qKlxuICogRGlzY2xhaW1lcjogbW9kdWxlcyBpbiBfc2hpbXMgYXJlbid0IGludGVuZGVkIHRvIGJlIGltcG9ydGVkIGJ5IFNESyB1c2Vycy5cbiAqL1xuaW1wb3J0ICogYXMgc2hpbXMgZnJvbSAnLi9yZWdpc3RyeS5tanMnO1xuaW1wb3J0ICogYXMgYXV0byBmcm9tICdncm9xLXNkay9fc2hpbXMvYXV0by9ydW50aW1lJztcbmlmICghc2hpbXMua2luZCkgc2hpbXMuc2V0U2hpbXMoYXV0by5nZXRSdW50aW1lKCksIHsgYXV0bzogdHJ1ZSB9KTtcbmV4cG9ydCAqIGZyb20gJy4vcmVnaXN0cnkubWpzJztcbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLlxuXG5pbXBvcnQgeyBjYXN0VG9FcnJvciwgSGVhZGVycyB9IGZyb20gJy4vY29yZSc7XG5cbmV4cG9ydCBjbGFzcyBHcm9xRXJyb3IgZXh0ZW5kcyBFcnJvciB7fVxuXG5leHBvcnQgY2xhc3MgQVBJRXJyb3IgZXh0ZW5kcyBHcm9xRXJyb3Ige1xuICByZWFkb25seSBzdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZDtcbiAgcmVhZG9ubHkgaGVhZGVyczogSGVhZGVycyB8IHVuZGVmaW5lZDtcbiAgcmVhZG9ubHkgZXJyb3I6IE9iamVjdCB8IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3RvcihcbiAgICBzdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgICBlcnJvcjogT2JqZWN0IHwgdW5kZWZpbmVkLFxuICAgIG1lc3NhZ2U6IHN0cmluZyB8IHVuZGVmaW5lZCxcbiAgICBoZWFkZXJzOiBIZWFkZXJzIHwgdW5kZWZpbmVkLFxuICApIHtcbiAgICBzdXBlcihgJHtBUElFcnJvci5tYWtlTWVzc2FnZShzdGF0dXMsIGVycm9yLCBtZXNzYWdlKX1gKTtcbiAgICB0aGlzLnN0YXR1cyA9IHN0YXR1cztcbiAgICB0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuICAgIHRoaXMuZXJyb3IgPSBlcnJvcjtcbiAgfVxuXG4gIHByaXZhdGUgc3RhdGljIG1ha2VNZXNzYWdlKHN0YXR1czogbnVtYmVyIHwgdW5kZWZpbmVkLCBlcnJvcjogYW55LCBtZXNzYWdlOiBzdHJpbmcgfCB1bmRlZmluZWQpIHtcbiAgICBjb25zdCBtc2cgPVxuICAgICAgZXJyb3I/Lm1lc3NhZ2UgP1xuICAgICAgICB0eXBlb2YgZXJyb3IubWVzc2FnZSA9PT0gJ3N0cmluZycgP1xuICAgICAgICAgIGVycm9yLm1lc3NhZ2VcbiAgICAgICAgOiBKU09OLnN0cmluZ2lmeShlcnJvci5tZXNzYWdlKVxuICAgICAgOiBlcnJvciA/IEpTT04uc3RyaW5naWZ5KGVycm9yKVxuICAgICAgOiBtZXNzYWdlO1xuXG4gICAgaWYgKHN0YXR1cyAmJiBtc2cpIHtcbiAgICAgIHJldHVybiBgJHtzdGF0dXN9ICR7bXNnfWA7XG4gICAgfVxuICAgIGlmIChzdGF0dXMpIHtcbiAgICAgIHJldHVybiBgJHtzdGF0dXN9IHN0YXR1cyBjb2RlIChubyBib2R5KWA7XG4gICAgfVxuICAgIGlmIChtc2cpIHtcbiAgICAgIHJldHVybiBtc2c7XG4gICAgfVxuICAgIHJldHVybiAnKG5vIHN0YXR1cyBjb2RlIG9yIGJvZHkpJztcbiAgfVxuXG4gIHN0YXRpYyBnZW5lcmF0ZShcbiAgICBzdGF0dXM6IG51bWJlciB8IHVuZGVmaW5lZCxcbiAgICBlcnJvclJlc3BvbnNlOiBPYmplY3QgfCB1bmRlZmluZWQsXG4gICAgbWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIGhlYWRlcnM6IEhlYWRlcnMgfCB1bmRlZmluZWQsXG4gICkge1xuICAgIGlmICghc3RhdHVzKSB7XG4gICAgICByZXR1cm4gbmV3IEFQSUNvbm5lY3Rpb25FcnJvcih7IGNhdXNlOiBjYXN0VG9FcnJvcihlcnJvclJlc3BvbnNlKSB9KTtcbiAgICB9XG5cbiAgICBjb25zdCBlcnJvciA9IGVycm9yUmVzcG9uc2UgYXMgUmVjb3JkPHN0cmluZywgYW55PjtcblxuICAgIGlmIChzdGF0dXMgPT09IDQwMCkge1xuICAgICAgcmV0dXJuIG5ldyBCYWRSZXF1ZXN0RXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gNDAxKSB7XG4gICAgICByZXR1cm4gbmV3IEF1dGhlbnRpY2F0aW9uRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gICAgfVxuXG4gICAgaWYgKHN0YXR1cyA9PT0gNDAzKSB7XG4gICAgICByZXR1cm4gbmV3IFBlcm1pc3Npb25EZW5pZWRFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSA0MDQpIHtcbiAgICAgIHJldHVybiBuZXcgTm90Rm91bmRFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSA0MDkpIHtcbiAgICAgIHJldHVybiBuZXcgQ29uZmxpY3RFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID09PSA0MjIpIHtcbiAgICAgIHJldHVybiBuZXcgVW5wcm9jZXNzYWJsZUVudGl0eUVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgIH1cblxuICAgIGlmIChzdGF0dXMgPT09IDQyOSkge1xuICAgICAgcmV0dXJuIG5ldyBSYXRlTGltaXRFcnJvcihzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgICB9XG5cbiAgICBpZiAoc3RhdHVzID49IDUwMCkge1xuICAgICAgcmV0dXJuIG5ldyBJbnRlcm5hbFNlcnZlckVycm9yKHN0YXR1cywgZXJyb3IsIG1lc3NhZ2UsIGhlYWRlcnMpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQVBJRXJyb3Ioc3RhdHVzLCBlcnJvciwgbWVzc2FnZSwgaGVhZGVycyk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFQSVVzZXJBYm9ydEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xuICBvdmVycmlkZSByZWFkb25seSBzdGF0dXM6IHVuZGVmaW5lZCA9IHVuZGVmaW5lZDtcblxuICBjb25zdHJ1Y3Rvcih7IG1lc3NhZ2UgfTogeyBtZXNzYWdlPzogc3RyaW5nIH0gPSB7fSkge1xuICAgIHN1cGVyKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBtZXNzYWdlIHx8ICdSZXF1ZXN0IHdhcyBhYm9ydGVkLicsIHVuZGVmaW5lZCk7XG4gIH1cbn1cblxuZXhwb3J0IGNsYXNzIEFQSUNvbm5lY3Rpb25FcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbiAgb3ZlcnJpZGUgcmVhZG9ubHkgc3RhdHVzOiB1bmRlZmluZWQgPSB1bmRlZmluZWQ7XG5cbiAgY29uc3RydWN0b3IoeyBtZXNzYWdlLCBjYXVzZSB9OiB7IG1lc3NhZ2U/OiBzdHJpbmc7IGNhdXNlPzogRXJyb3IgfCB1bmRlZmluZWQgfSkge1xuICAgIHN1cGVyKHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBtZXNzYWdlIHx8ICdDb25uZWN0aW9uIGVycm9yLicsIHVuZGVmaW5lZCk7XG4gICAgLy8gaW4gc29tZSBlbnZpcm9ubWVudHMgdGhlICdjYXVzZScgcHJvcGVydHkgaXMgYWxyZWFkeSBkZWNsYXJlZFxuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBpZiAoY2F1c2UpIHRoaXMuY2F1c2UgPSBjYXVzZTtcbiAgfVxufVxuXG5leHBvcnQgY2xhc3MgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvciBleHRlbmRzIEFQSUNvbm5lY3Rpb25FcnJvciB7XG4gIGNvbnN0cnVjdG9yKHsgbWVzc2FnZSB9OiB7IG1lc3NhZ2U/OiBzdHJpbmcgfSA9IHt9KSB7XG4gICAgc3VwZXIoeyBtZXNzYWdlOiBtZXNzYWdlID8/ICdSZXF1ZXN0IHRpbWVkIG91dC4nIH0pO1xuICB9XG59XG5cbmV4cG9ydCBjbGFzcyBCYWRSZXF1ZXN0RXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gIG92ZXJyaWRlIHJlYWRvbmx5IHN0YXR1czogNDAwID0gNDAwO1xufVxuXG5leHBvcnQgY2xhc3MgQXV0aGVudGljYXRpb25FcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbiAgb3ZlcnJpZGUgcmVhZG9ubHkgc3RhdHVzOiA0MDEgPSA0MDE7XG59XG5cbmV4cG9ydCBjbGFzcyBQZXJtaXNzaW9uRGVuaWVkRXJyb3IgZXh0ZW5kcyBBUElFcnJvciB7XG4gIG92ZXJyaWRlIHJlYWRvbmx5IHN0YXR1czogNDAzID0gNDAzO1xufVxuXG5leHBvcnQgY2xhc3MgTm90Rm91bmRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbiAgb3ZlcnJpZGUgcmVhZG9ubHkgc3RhdHVzOiA0MDQgPSA0MDQ7XG59XG5cbmV4cG9ydCBjbGFzcyBDb25mbGljdEVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige1xuICBvdmVycmlkZSByZWFkb25seSBzdGF0dXM6IDQwOSA9IDQwOTtcbn1cblxuZXhwb3J0IGNsYXNzIFVucHJvY2Vzc2FibGVFbnRpdHlFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbiAgb3ZlcnJpZGUgcmVhZG9ubHkgc3RhdHVzOiA0MjIgPSA0MjI7XG59XG5cbmV4cG9ydCBjbGFzcyBSYXRlTGltaXRFcnJvciBleHRlbmRzIEFQSUVycm9yIHtcbiAgb3ZlcnJpZGUgcmVhZG9ubHkgc3RhdHVzOiA0MjkgPSA0Mjk7XG59XG5cbmV4cG9ydCBjbGFzcyBJbnRlcm5hbFNlcnZlckVycm9yIGV4dGVuZHMgQVBJRXJyb3Ige31cbiIsICJpbXBvcnQgeyBSZWFkYWJsZVN0cmVhbSwgdHlwZSBSZXNwb25zZSB9IGZyb20gXCIuLi9fc2hpbXMvaW5kZXhcIjtcbmltcG9ydCB7IEdyb3FFcnJvciB9IGZyb20gXCIuLi9lcnJvclwiO1xuXG5pbXBvcnQgeyBBUElFcnJvciB9IGZyb20gXCIuLi9lcnJvclwiO1xuXG50eXBlIEJ5dGVzID0gc3RyaW5nIHwgQXJyYXlCdWZmZXIgfCBVaW50OEFycmF5IHwgQnVmZmVyIHwgbnVsbCB8IHVuZGVmaW5lZDtcblxuZXhwb3J0IHR5cGUgU2VydmVyU2VudEV2ZW50ID0ge1xuICBldmVudDogc3RyaW5nIHwgbnVsbDtcbiAgZGF0YTogc3RyaW5nO1xuICByYXc6IHN0cmluZ1tdO1xufTtcblxuZXhwb3J0IGNsYXNzIFN0cmVhbTxJdGVtPiBpbXBsZW1lbnRzIEFzeW5jSXRlcmFibGU8SXRlbT4ge1xuICBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXI7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgcHJpdmF0ZSBpdGVyYXRvcjogKCkgPT4gQXN5bmNJdGVyYXRvcjxJdGVtPixcbiAgICBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIsXG4gICkge1xuICAgIHRoaXMuY29udHJvbGxlciA9IGNvbnRyb2xsZXI7XG4gIH1cblxuICBzdGF0aWMgZnJvbVNTRVJlc3BvbnNlPEl0ZW0+KHJlc3BvbnNlOiBSZXNwb25zZSwgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyKSB7XG4gICAgbGV0IGNvbnN1bWVkID0gZmFsc2U7XG4gICAgY29uc3QgZGVjb2RlciA9IG5ldyBTU0VEZWNvZGVyKCk7XG5cbiAgICBhc3luYyBmdW5jdGlvbiogaXRlck1lc3NhZ2VzKCk6IEFzeW5jR2VuZXJhdG9yPFNlcnZlclNlbnRFdmVudCwgdm9pZCwgdW5rbm93bj4ge1xuICAgICAgaWYgKCFyZXNwb25zZS5ib2R5KSB7XG4gICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgdGhyb3cgbmV3IEdyb3FFcnJvcihgQXR0ZW1wdGVkIHRvIGl0ZXJhdGUgb3ZlciBhIHJlc3BvbnNlIHdpdGggbm8gYm9keWApO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBsaW5lRGVjb2RlciA9IG5ldyBMaW5lRGVjb2RlcigpO1xuXG4gICAgICBjb25zdCBpdGVyID0gcmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhYmxlPEJ5dGVzPihyZXNwb25zZS5ib2R5KTtcbiAgICAgIGZvciBhd2FpdCAoY29uc3QgY2h1bmsgb2YgaXRlcikge1xuICAgICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZURlY29kZXIuZGVjb2RlKGNodW5rKSkge1xuICAgICAgICAgIGNvbnN0IHNzZSA9IGRlY29kZXIuZGVjb2RlKGxpbmUpO1xuICAgICAgICAgIGlmIChzc2UpIHlpZWxkIHNzZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZURlY29kZXIuZmx1c2goKSkge1xuICAgICAgICBjb25zdCBzc2UgPSBkZWNvZGVyLmRlY29kZShsaW5lKTtcbiAgICAgICAgaWYgKHNzZSkgeWllbGQgc3NlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uKiBpdGVyYXRvcigpOiBBc3luY0l0ZXJhdG9yPEl0ZW0sIGFueSwgdW5kZWZpbmVkPiB7XG4gICAgICBpZiAoY29uc3VtZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaXRlcmF0ZSBvdmVyIGEgY29uc3VtZWQgc3RyZWFtLCB1c2UgYC50ZWUoKWAgdG8gc3BsaXQgdGhlIHN0cmVhbS4nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN1bWVkID0gdHJ1ZTtcbiAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IHNzZSBvZiBpdGVyTWVzc2FnZXMoKSkge1xuICAgICAgICAgIGlmIChkb25lKSBjb250aW51ZTtcblxuICAgICAgICAgIGlmIChzc2UuZGF0YS5zdGFydHNXaXRoKCdbRE9ORV0nKSkge1xuICAgICAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoc3NlLmV2ZW50ID09PSBudWxsKSB7XG4gICAgICAgICAgICBsZXQgZGF0YTtcblxuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgZGF0YSA9IEpTT04ucGFyc2Uoc3NlLmRhdGEpO1xuICAgICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBDb3VsZCBub3QgcGFyc2UgbWVzc2FnZSBpbnRvIEpTT046YCwgc3NlLmRhdGEpO1xuICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGBGcm9tIGNodW5rOmAsIHNzZS5yYXcpO1xuICAgICAgICAgICAgICB0aHJvdyBlO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoZGF0YSAmJiBkYXRhLmVycm9yKSB7XG4gICAgICAgICAgICAgIHRocm93IG5ldyBBUElFcnJvcih1bmRlZmluZWQsIGRhdGEuZXJyb3IsIHVuZGVmaW5lZCwgdW5kZWZpbmVkKTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgeWllbGQgZGF0YTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGNhbGxzIGBzdHJlYW0uY29udHJvbGxlci5hYm9ydCgpYCwgd2Ugc2hvdWxkIGV4aXQgd2l0aG91dCB0aHJvd2luZy5cbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm5hbWUgPT09ICdBYm9ydEVycm9yJykgcmV0dXJuO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgYGJyZWFrYHMsIGFib3J0IHRoZSBvbmdvaW5nIHJlcXVlc3QuXG4gICAgICAgIGlmICghZG9uZSkgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3RyZWFtKGl0ZXJhdG9yLCBjb250cm9sbGVyKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZXMgYSBTdHJlYW0gZnJvbSBhIG5ld2xpbmUtc2VwYXJhdGVkIFJlYWRhYmxlU3RyZWFtXG4gICAqIHdoZXJlIGVhY2ggaXRlbSBpcyBhIEpTT04gdmFsdWUuXG4gICAqL1xuICBzdGF0aWMgZnJvbVJlYWRhYmxlU3RyZWFtPEl0ZW0+KHJlYWRhYmxlU3RyZWFtOiBSZWFkYWJsZVN0cmVhbSwgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyKSB7XG4gICAgbGV0IGNvbnN1bWVkID0gZmFsc2U7XG5cbiAgICBhc3luYyBmdW5jdGlvbiogaXRlckxpbmVzKCk6IEFzeW5jR2VuZXJhdG9yPHN0cmluZywgdm9pZCwgdW5rbm93bj4ge1xuICAgICAgY29uc3QgbGluZURlY29kZXIgPSBuZXcgTGluZURlY29kZXIoKTtcblxuICAgICAgY29uc3QgaXRlciA9IHJlYWRhYmxlU3RyZWFtQXN5bmNJdGVyYWJsZTxCeXRlcz4ocmVhZGFibGVTdHJlYW0pO1xuICAgICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiBpdGVyKSB7XG4gICAgICAgIGZvciAoY29uc3QgbGluZSBvZiBsaW5lRGVjb2Rlci5kZWNvZGUoY2h1bmspKSB7XG4gICAgICAgICAgeWllbGQgbGluZTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICBmb3IgKGNvbnN0IGxpbmUgb2YgbGluZURlY29kZXIuZmx1c2goKSkge1xuICAgICAgICB5aWVsZCBsaW5lO1xuICAgICAgfVxuICAgIH1cblxuICAgIGFzeW5jIGZ1bmN0aW9uKiBpdGVyYXRvcigpOiBBc3luY0l0ZXJhdG9yPEl0ZW0sIGFueSwgdW5kZWZpbmVkPiB7XG4gICAgICBpZiAoY29uc3VtZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdDYW5ub3QgaXRlcmF0ZSBvdmVyIGEgY29uc3VtZWQgc3RyZWFtLCB1c2UgYC50ZWUoKWAgdG8gc3BsaXQgdGhlIHN0cmVhbS4nKTtcbiAgICAgIH1cbiAgICAgIGNvbnN1bWVkID0gdHJ1ZTtcbiAgICAgIGxldCBkb25lID0gZmFsc2U7XG4gICAgICB0cnkge1xuICAgICAgICBmb3IgYXdhaXQgKGNvbnN0IGxpbmUgb2YgaXRlckxpbmVzKCkpIHtcbiAgICAgICAgICBpZiAoZG9uZSkgY29udGludWU7XG4gICAgICAgICAgaWYgKGxpbmUpIHlpZWxkIEpTT04ucGFyc2UobGluZSk7XG4gICAgICAgIH1cbiAgICAgICAgZG9uZSA9IHRydWU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIElmIHRoZSB1c2VyIGNhbGxzIGBzdHJlYW0uY29udHJvbGxlci5hYm9ydCgpYCwgd2Ugc2hvdWxkIGV4aXQgd2l0aG91dCB0aHJvd2luZy5cbiAgICAgICAgaWYgKGUgaW5zdGFuY2VvZiBFcnJvciAmJiBlLm5hbWUgPT09ICdBYm9ydEVycm9yJykgcmV0dXJuO1xuICAgICAgICB0aHJvdyBlO1xuICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgLy8gSWYgdGhlIHVzZXIgYGJyZWFrYHMsIGFib3J0IHRoZSBvbmdvaW5nIHJlcXVlc3QuXG4gICAgICAgIGlmICghZG9uZSkgY29udHJvbGxlci5hYm9ydCgpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBuZXcgU3RyZWFtKGl0ZXJhdG9yLCBjb250cm9sbGVyKTtcbiAgfVxuXG4gIFtTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKTogQXN5bmNJdGVyYXRvcjxJdGVtPiB7XG4gICAgcmV0dXJuIHRoaXMuaXRlcmF0b3IoKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBTcGxpdHMgdGhlIHN0cmVhbSBpbnRvIHR3byBzdHJlYW1zIHdoaWNoIGNhbiBiZVxuICAgKiBpbmRlcGVuZGVudGx5IHJlYWQgZnJvbSBhdCBkaWZmZXJlbnQgc3BlZWRzLlxuICAgKi9cbiAgdGVlKCk6IFtTdHJlYW08SXRlbT4sIFN0cmVhbTxJdGVtPl0ge1xuICAgIGNvbnN0IGxlZnQ6IEFycmF5PFByb21pc2U8SXRlcmF0b3JSZXN1bHQ8SXRlbT4+PiA9IFtdO1xuICAgIGNvbnN0IHJpZ2h0OiBBcnJheTxQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PEl0ZW0+Pj4gPSBbXTtcbiAgICBjb25zdCBpdGVyYXRvciA9IHRoaXMuaXRlcmF0b3IoKTtcblxuICAgIGNvbnN0IHRlZUl0ZXJhdG9yID0gKHF1ZXVlOiBBcnJheTxQcm9taXNlPEl0ZXJhdG9yUmVzdWx0PEl0ZW0+Pj4pOiBBc3luY0l0ZXJhdG9yPEl0ZW0+ID0+IHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIG5leHQ6ICgpID0+IHtcbiAgICAgICAgICBpZiAocXVldWUubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBpdGVyYXRvci5uZXh0KCk7XG4gICAgICAgICAgICBsZWZ0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgICAgIHJpZ2h0LnB1c2gocmVzdWx0KTtcbiAgICAgICAgICB9XG4gICAgICAgICAgcmV0dXJuIHF1ZXVlLnNoaWZ0KCkhO1xuICAgICAgICB9LFxuICAgICAgfTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFtcbiAgICAgIG5ldyBTdHJlYW0oKCkgPT4gdGVlSXRlcmF0b3IobGVmdCksIHRoaXMuY29udHJvbGxlciksXG4gICAgICBuZXcgU3RyZWFtKCgpID0+IHRlZUl0ZXJhdG9yKHJpZ2h0KSwgdGhpcy5jb250cm9sbGVyKSxcbiAgICBdO1xuICB9XG5cbiAgLyoqXG4gICAqIENvbnZlcnRzIHRoaXMgc3RyZWFtIHRvIGEgbmV3bGluZS1zZXBhcmF0ZWQgUmVhZGFibGVTdHJlYW0gb2ZcbiAgICogSlNPTiBzdHJpbmdpZmllZCB2YWx1ZXMgaW4gdGhlIHN0cmVhbVxuICAgKiB3aGljaCBjYW4gYmUgdHVybmVkIGJhY2sgaW50byBhIFN0cmVhbSB3aXRoIGBTdHJlYW0uZnJvbVJlYWRhYmxlU3RyZWFtKClgLlxuICAgKi9cbiAgdG9SZWFkYWJsZVN0cmVhbSgpOiBSZWFkYWJsZVN0cmVhbSB7XG4gICAgY29uc3Qgc2VsZiA9IHRoaXM7XG4gICAgbGV0IGl0ZXI6IEFzeW5jSXRlcmF0b3I8SXRlbT47XG4gICAgY29uc3QgZW5jb2RlciA9IG5ldyBUZXh0RW5jb2RlcigpO1xuXG4gICAgcmV0dXJuIG5ldyBSZWFkYWJsZVN0cmVhbSh7XG4gICAgICBhc3luYyBzdGFydCgpIHtcbiAgICAgICAgaXRlciA9IHNlbGZbU3ltYm9sLmFzeW5jSXRlcmF0b3JdKCk7XG4gICAgICB9LFxuICAgICAgYXN5bmMgcHVsbChjdHJsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgY29uc3QgeyB2YWx1ZSwgZG9uZSB9ID0gYXdhaXQgaXRlci5uZXh0KCk7XG4gICAgICAgICAgaWYgKGRvbmUpIHJldHVybiBjdHJsLmNsb3NlKCk7XG5cbiAgICAgICAgICBjb25zdCBieXRlcyA9IGVuY29kZXIuZW5jb2RlKEpTT04uc3RyaW5naWZ5KHZhbHVlKSArICdcXG4nKTtcblxuICAgICAgICAgIGN0cmwuZW5xdWV1ZShieXRlcyk7XG4gICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgIGN0cmwuZXJyb3IoZXJyKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIGFzeW5jIGNhbmNlbCgpIHtcbiAgICAgICAgYXdhaXQgaXRlci5yZXR1cm4/LigpO1xuICAgICAgfSxcbiAgICB9KTtcbiAgfVxufVxuXG5jbGFzcyBTU0VEZWNvZGVyIHtcbiAgcHJpdmF0ZSBkYXRhOiBzdHJpbmdbXTtcbiAgcHJpdmF0ZSBldmVudDogc3RyaW5nIHwgbnVsbDtcbiAgcHJpdmF0ZSBjaHVua3M6IHN0cmluZ1tdO1xuXG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHRoaXMuZXZlbnQgPSBudWxsO1xuICAgIHRoaXMuZGF0YSA9IFtdO1xuICAgIHRoaXMuY2h1bmtzID0gW107XG4gIH1cblxuICBkZWNvZGUobGluZTogc3RyaW5nKSB7XG4gICAgaWYgKGxpbmUuZW5kc1dpdGgoJ1xccicpKSB7XG4gICAgICBsaW5lID0gbGluZS5zdWJzdHJpbmcoMCwgbGluZS5sZW5ndGggLSAxKTtcbiAgICB9XG5cbiAgICBpZiAoIWxpbmUpIHtcbiAgICAgIC8vIGVtcHR5IGxpbmUgYW5kIHdlIGRpZG4ndCBwcmV2aW91c2x5IGVuY291bnRlciBhbnkgbWVzc2FnZXNcbiAgICAgIGlmICghdGhpcy5ldmVudCAmJiAhdGhpcy5kYXRhLmxlbmd0aCkgcmV0dXJuIG51bGw7XG5cbiAgICAgIGNvbnN0IHNzZTogU2VydmVyU2VudEV2ZW50ID0ge1xuICAgICAgICBldmVudDogdGhpcy5ldmVudCxcbiAgICAgICAgZGF0YTogdGhpcy5kYXRhLmpvaW4oJ1xcbicpLFxuICAgICAgICByYXc6IHRoaXMuY2h1bmtzLFxuICAgICAgfTtcblxuICAgICAgdGhpcy5ldmVudCA9IG51bGw7XG4gICAgICB0aGlzLmRhdGEgPSBbXTtcbiAgICAgIHRoaXMuY2h1bmtzID0gW107XG5cbiAgICAgIHJldHVybiBzc2U7XG4gICAgfVxuXG4gICAgdGhpcy5jaHVua3MucHVzaChsaW5lKTtcblxuICAgIGlmIChsaW5lLnN0YXJ0c1dpdGgoJzonKSkge1xuICAgICAgcmV0dXJuIG51bGw7XG4gICAgfVxuXG4gICAgbGV0IFtmaWVsZG5hbWUsIF8sIHZhbHVlXSA9IHBhcnRpdGlvbihsaW5lLCAnOicpO1xuXG4gICAgaWYgKHZhbHVlLnN0YXJ0c1dpdGgoJyAnKSkge1xuICAgICAgdmFsdWUgPSB2YWx1ZS5zdWJzdHJpbmcoMSk7XG4gICAgfVxuXG4gICAgaWYgKGZpZWxkbmFtZSA9PT0gJ2V2ZW50Jykge1xuICAgICAgdGhpcy5ldmVudCA9IHZhbHVlO1xuICAgIH0gZWxzZSBpZiAoZmllbGRuYW1lID09PSAnZGF0YScpIHtcbiAgICAgIHRoaXMuZGF0YS5wdXNoKHZhbHVlKTtcbiAgICB9XG5cbiAgICByZXR1cm4gbnVsbDtcbiAgfVxufVxuXG4vKipcbiAqIEEgcmUtaW1wbGVtZW50YXRpb24gb2YgaHR0cHgncyBgTGluZURlY29kZXJgIGluIFB5dGhvbiB0aGF0IGhhbmRsZXMgaW5jcmVtZW50YWxseVxuICogcmVhZGluZyBsaW5lcyBmcm9tIHRleHQuXG4gKlxuICogaHR0cHM6Ly9naXRodWIuY29tL2VuY29kZS9odHRweC9ibG9iLzkyMDMzM2VhOTgxMThlOWNmNjE3ZjI0NjkwNWQ3YjIwMjUxMDk0MWMvaHR0cHgvX2RlY29kZXJzLnB5I0wyNThcbiAqL1xuY2xhc3MgTGluZURlY29kZXIge1xuICAvLyBwcmV0dGllci1pZ25vcmVcbiAgc3RhdGljIE5FV0xJTkVfQ0hBUlMgPSBuZXcgU2V0KFsnXFxuJywgJ1xccicsICdcXHgwYicsICdcXHgwYycsICdcXHgxYycsICdcXHgxZCcsICdcXHgxZScsICdcXHg4NScsICdcXHUyMDI4JywgJ1xcdTIwMjknXSk7XG4gIHN0YXRpYyBORVdMSU5FX1JFR0VYUCA9IC9cXHJcXG58W1xcblxcclxceDBiXFx4MGNcXHgxY1xceDFkXFx4MWVcXHg4NVxcdTIwMjhcXHUyMDI5XS9nO1xuXG4gIGJ1ZmZlcjogc3RyaW5nW107XG4gIHRyYWlsaW5nQ1I6IGJvb2xlYW47XG4gIHRleHREZWNvZGVyOiBhbnk7IC8vIFRleHREZWNvZGVyIGZvdW5kIGluIGJyb3dzZXJzOyBub3QgdHlwZWQgdG8gYXZvaWQgcHVsbGluZyBpbiBlaXRoZXIgXCJkb21cIiBvciBcIm5vZGVcIiB0eXBlcy5cblxuICBjb25zdHJ1Y3RvcigpIHtcbiAgICB0aGlzLmJ1ZmZlciA9IFtdO1xuICAgIHRoaXMudHJhaWxpbmdDUiA9IGZhbHNlO1xuICB9XG5cbiAgZGVjb2RlKGNodW5rOiBCeXRlcyk6IHN0cmluZ1tdIHtcbiAgICBsZXQgdGV4dCA9IHRoaXMuZGVjb2RlVGV4dChjaHVuayk7XG5cbiAgICBpZiAodGhpcy50cmFpbGluZ0NSKSB7XG4gICAgICB0ZXh0ID0gJ1xccicgKyB0ZXh0O1xuICAgICAgdGhpcy50cmFpbGluZ0NSID0gZmFsc2U7XG4gICAgfVxuICAgIGlmICh0ZXh0LmVuZHNXaXRoKCdcXHInKSkge1xuICAgICAgdGhpcy50cmFpbGluZ0NSID0gdHJ1ZTtcbiAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDAsIC0xKTtcbiAgICB9XG5cbiAgICBpZiAoIXRleHQpIHtcbiAgICAgIHJldHVybiBbXTtcbiAgICB9XG5cbiAgICBjb25zdCB0cmFpbGluZ05ld2xpbmUgPSBMaW5lRGVjb2Rlci5ORVdMSU5FX0NIQVJTLmhhcyh0ZXh0W3RleHQubGVuZ3RoIC0gMV0gfHwgJycpO1xuICAgIGxldCBsaW5lcyA9IHRleHQuc3BsaXQoTGluZURlY29kZXIuTkVXTElORV9SRUdFWFApO1xuXG4gICAgaWYgKGxpbmVzLmxlbmd0aCA9PT0gMSAmJiAhdHJhaWxpbmdOZXdsaW5lKSB7XG4gICAgICB0aGlzLmJ1ZmZlci5wdXNoKGxpbmVzWzBdISk7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgaWYgKHRoaXMuYnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgIGxpbmVzID0gW3RoaXMuYnVmZmVyLmpvaW4oJycpICsgbGluZXNbMF0sIC4uLmxpbmVzLnNsaWNlKDEpXTtcbiAgICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgfVxuXG4gICAgaWYgKCF0cmFpbGluZ05ld2xpbmUpIHtcbiAgICAgIHRoaXMuYnVmZmVyID0gW2xpbmVzLnBvcCgpIHx8ICcnXTtcbiAgICB9XG5cbiAgICByZXR1cm4gbGluZXM7XG4gIH1cblxuICBkZWNvZGVUZXh0KGJ5dGVzOiBCeXRlcyk6IHN0cmluZyB7XG4gICAgaWYgKGJ5dGVzID09IG51bGwpIHJldHVybiAnJztcbiAgICBpZiAodHlwZW9mIGJ5dGVzID09PSAnc3RyaW5nJykgcmV0dXJuIGJ5dGVzO1xuXG4gICAgLy8gTm9kZTpcbiAgICBpZiAodHlwZW9mIEJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGlmIChieXRlcyBpbnN0YW5jZW9mIEJ1ZmZlcikge1xuICAgICAgICByZXR1cm4gYnl0ZXMudG9TdHJpbmcoKTtcbiAgICAgIH1cbiAgICAgIGlmIChieXRlcyBpbnN0YW5jZW9mIFVpbnQ4QXJyYXkpIHtcbiAgICAgICAgcmV0dXJuIEJ1ZmZlci5mcm9tKGJ5dGVzKS50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgR3JvcUVycm9yKFxuICAgICAgICBgVW5leHBlY3RlZDogcmVjZWl2ZWQgbm9uLVVpbnQ4QXJyYXkgKCR7Ynl0ZXMuY29uc3RydWN0b3IubmFtZX0pIHN0cmVhbSBjaHVuayBpbiBhbiBlbnZpcm9ubWVudCB3aXRoIGEgZ2xvYmFsIFwiQnVmZmVyXCIgZGVmaW5lZCwgd2hpY2ggdGhpcyBsaWJyYXJ5IGFzc3VtZXMgdG8gYmUgTm9kZS4gUGxlYXNlIHJlcG9ydCB0aGlzIGVycm9yLmAsXG4gICAgICApO1xuICAgIH1cblxuICAgIC8vIEJyb3dzZXJcbiAgICBpZiAodHlwZW9mIFRleHREZWNvZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgaWYgKGJ5dGVzIGluc3RhbmNlb2YgVWludDhBcnJheSB8fCBieXRlcyBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG4gICAgICAgIHRoaXMudGV4dERlY29kZXIgPz89IG5ldyBUZXh0RGVjb2RlcigndXRmOCcpO1xuICAgICAgICByZXR1cm4gdGhpcy50ZXh0RGVjb2Rlci5kZWNvZGUoYnl0ZXMpO1xuICAgICAgfVxuXG4gICAgICB0aHJvdyBuZXcgR3JvcUVycm9yKFxuICAgICAgICBgVW5leHBlY3RlZDogcmVjZWl2ZWQgbm9uLVVpbnQ4QXJyYXkvQXJyYXlCdWZmZXIgKCR7XG4gICAgICAgICAgKGJ5dGVzIGFzIGFueSkuY29uc3RydWN0b3IubmFtZVxuICAgICAgICB9KSBpbiBhIHdlYiBwbGF0Zm9ybS4gUGxlYXNlIHJlcG9ydCB0aGlzIGVycm9yLmAsXG4gICAgICApO1xuICAgIH1cblxuICAgIHRocm93IG5ldyBHcm9xRXJyb3IoXG4gICAgICBgVW5leHBlY3RlZDogbmVpdGhlciBCdWZmZXIgbm9yIFRleHREZWNvZGVyIGFyZSBhdmFpbGFibGUgYXMgZ2xvYmFscy4gUGxlYXNlIHJlcG9ydCB0aGlzIGVycm9yLmAsXG4gICAgKTtcbiAgfVxuXG4gIGZsdXNoKCk6IHN0cmluZ1tdIHtcbiAgICBpZiAoIXRoaXMuYnVmZmVyLmxlbmd0aCAmJiAhdGhpcy50cmFpbGluZ0NSKSB7XG4gICAgICByZXR1cm4gW107XG4gICAgfVxuXG4gICAgY29uc3QgbGluZXMgPSBbdGhpcy5idWZmZXIuam9pbignJyldO1xuICAgIHRoaXMuYnVmZmVyID0gW107XG4gICAgdGhpcy50cmFpbGluZ0NSID0gZmFsc2U7XG4gICAgcmV0dXJuIGxpbmVzO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnRpdGlvbihzdHI6IHN0cmluZywgZGVsaW1pdGVyOiBzdHJpbmcpOiBbc3RyaW5nLCBzdHJpbmcsIHN0cmluZ10ge1xuICBjb25zdCBpbmRleCA9IHN0ci5pbmRleE9mKGRlbGltaXRlcik7XG4gIGlmIChpbmRleCAhPT0gLTEpIHtcbiAgICByZXR1cm4gW3N0ci5zdWJzdHJpbmcoMCwgaW5kZXgpLCBkZWxpbWl0ZXIsIHN0ci5zdWJzdHJpbmcoaW5kZXggKyBkZWxpbWl0ZXIubGVuZ3RoKV07XG4gIH1cblxuICByZXR1cm4gW3N0ciwgJycsICcnXTtcbn1cblxuLyoqXG4gKiBNb3N0IGJyb3dzZXJzIGRvbid0IHlldCBoYXZlIGFzeW5jIGl0ZXJhYmxlIHN1cHBvcnQgZm9yIFJlYWRhYmxlU3RyZWFtLFxuICogYW5kIE5vZGUgaGFzIGEgdmVyeSBkaWZmZXJlbnQgd2F5IG9mIHJlYWRpbmcgYnl0ZXMgZnJvbSBpdHMgXCJSZWFkYWJsZVN0cmVhbVwiLlxuICpcbiAqIFRoaXMgcG9seWZpbGwgd2FzIHB1bGxlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9NYXR0aWFzQnVlbGVucy93ZWItc3RyZWFtcy1wb2x5ZmlsbC9wdWxsLzEyMiNpc3N1ZWNvbW1lbnQtMTYyNzM1NDQ5MFxuICovXG5leHBvcnQgZnVuY3Rpb24gcmVhZGFibGVTdHJlYW1Bc3luY0l0ZXJhYmxlPFQ+KHN0cmVhbTogYW55KTogQXN5bmNJdGVyYWJsZUl0ZXJhdG9yPFQ+IHtcbiAgaWYgKHN0cmVhbVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0pIHJldHVybiBzdHJlYW07XG5cbiAgY29uc3QgcmVhZGVyID0gc3RyZWFtLmdldFJlYWRlcigpO1xuICByZXR1cm4ge1xuICAgIGFzeW5jIG5leHQoKSB7XG4gICAgICB0cnkge1xuICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCByZWFkZXIucmVhZCgpO1xuICAgICAgICBpZiAocmVzdWx0Py5kb25lKSByZWFkZXIucmVsZWFzZUxvY2soKTsgLy8gcmVsZWFzZSBsb2NrIHdoZW4gc3RyZWFtIGJlY29tZXMgY2xvc2VkXG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIHJlYWRlci5yZWxlYXNlTG9jaygpOyAvLyByZWxlYXNlIGxvY2sgd2hlbiBzdHJlYW0gYmVjb21lcyBlcnJvcmVkXG4gICAgICAgIHRocm93IGU7XG4gICAgICB9XG4gICAgfSxcbiAgICBhc3luYyByZXR1cm4oKSB7XG4gICAgICBjb25zdCBjYW5jZWxQcm9taXNlID0gcmVhZGVyLmNhbmNlbCgpO1xuICAgICAgcmVhZGVyLnJlbGVhc2VMb2NrKCk7XG4gICAgICBhd2FpdCBjYW5jZWxQcm9taXNlO1xuICAgICAgcmV0dXJuIHsgZG9uZTogdHJ1ZSwgdmFsdWU6IHVuZGVmaW5lZCB9O1xuICAgIH0sXG4gICAgW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH0sXG4gIH07XG59XG4iLCAiaW1wb3J0IHsgdHlwZSBSZXF1ZXN0T3B0aW9ucyB9IGZyb20gJy4vY29yZSc7XG5pbXBvcnQge1xuICBGb3JtRGF0YSxcbiAgRmlsZSxcbiAgdHlwZSBCbG9iLFxuICB0eXBlIEZpbGVQcm9wZXJ0eUJhZyxcbiAgZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnMsXG4gIHR5cGUgRnNSZWFkU3RyZWFtLFxuICBpc0ZzUmVhZFN0cmVhbSxcbn0gZnJvbSAnLi9fc2hpbXMvaW5kZXgnO1xuaW1wb3J0IHsgTXVsdGlwYXJ0Qm9keSB9IGZyb20gJy4vX3NoaW1zL011bHRpcGFydEJvZHknO1xuZXhwb3J0IHsgZmlsZUZyb21QYXRoIH0gZnJvbSAnLi9fc2hpbXMvaW5kZXgnO1xuXG50eXBlIEJsb2JMaWtlUGFydCA9IHN0cmluZyB8IEFycmF5QnVmZmVyIHwgQXJyYXlCdWZmZXJWaWV3IHwgQmxvYkxpa2UgfCBVaW50OEFycmF5IHwgRGF0YVZpZXc7XG5leHBvcnQgdHlwZSBCbG9iUGFydCA9IHN0cmluZyB8IEFycmF5QnVmZmVyIHwgQXJyYXlCdWZmZXJWaWV3IHwgQmxvYiB8IFVpbnQ4QXJyYXkgfCBEYXRhVmlldztcblxuLyoqXG4gKiBUeXBpY2FsbHksIHRoaXMgaXMgYSBuYXRpdmUgXCJGaWxlXCIgY2xhc3MuXG4gKlxuICogV2UgcHJvdmlkZSB0aGUge0BsaW5rIHRvRmlsZX0gdXRpbGl0eSB0byBjb252ZXJ0IGEgdmFyaWV0eSBvZiBvYmplY3RzXG4gKiBpbnRvIHRoZSBGaWxlIGNsYXNzLlxuICpcbiAqIEZvciBjb252ZW5pZW5jZSwgeW91IGNhbiBhbHNvIHBhc3MgYSBmZXRjaCBSZXNwb25zZSwgb3IgaW4gTm9kZSxcbiAqIHRoZSByZXN1bHQgb2YgZnMuY3JlYXRlUmVhZFN0cmVhbSgpLlxuICovXG5leHBvcnQgdHlwZSBVcGxvYWRhYmxlID0gRmlsZUxpa2UgfCBSZXNwb25zZUxpa2UgfCBGc1JlYWRTdHJlYW07XG5cbi8qKlxuICogSW50ZW5kZWQgdG8gbWF0Y2ggd2ViLkJsb2IsIG5vZGUuQmxvYiwgbm9kZS1mZXRjaC5CbG9iLCBldGMuXG4gKi9cbmV4cG9ydCBpbnRlcmZhY2UgQmxvYkxpa2Uge1xuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9CbG9iL3NpemUpICovXG4gIHJlYWRvbmx5IHNpemU6IG51bWJlcjtcbiAgLyoqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvQmxvYi90eXBlKSAqL1xuICByZWFkb25seSB0eXBlOiBzdHJpbmc7XG4gIC8qKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0Jsb2IvdGV4dCkgKi9cbiAgdGV4dCgpOiBQcm9taXNlPHN0cmluZz47XG4gIC8qKiBbTUROIFJlZmVyZW5jZV0oaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZG9jcy9XZWIvQVBJL0Jsb2Ivc2xpY2UpICovXG4gIHNsaWNlKHN0YXJ0PzogbnVtYmVyLCBlbmQ/OiBudW1iZXIpOiBCbG9iTGlrZTtcbiAgLy8gdW5mb3J0dW5hdGVseSBAdHlwZXMvbm9kZS1mZXRjaEBeMi42LjQgZG9lc24ndCB0eXBlIHRoZSBhcnJheUJ1ZmZlciBtZXRob2Rcbn1cblxuLyoqXG4gKiBJbnRlbmRlZCB0byBtYXRjaCB3ZWIuRmlsZSwgbm9kZS5GaWxlLCBub2RlLWZldGNoLkZpbGUsIGV0Yy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBGaWxlTGlrZSBleHRlbmRzIEJsb2JMaWtlIHtcbiAgLyoqIFtNRE4gUmVmZXJlbmNlXShodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9kb2NzL1dlYi9BUEkvRmlsZS9sYXN0TW9kaWZpZWQpICovXG4gIHJlYWRvbmx5IGxhc3RNb2RpZmllZDogbnVtYmVyO1xuICAvKiogW01ETiBSZWZlcmVuY2VdKGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2RvY3MvV2ViL0FQSS9GaWxlL25hbWUpICovXG4gIHJlYWRvbmx5IG5hbWU6IHN0cmluZztcbn1cblxuLyoqXG4gKiBJbnRlbmRlZCB0byBtYXRjaCB3ZWIuUmVzcG9uc2UsIG5vZGUuUmVzcG9uc2UsIG5vZGUtZmV0Y2guUmVzcG9uc2UsIGV0Yy5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBSZXNwb25zZUxpa2Uge1xuICB1cmw6IHN0cmluZztcbiAgYmxvYigpOiBQcm9taXNlPEJsb2JMaWtlPjtcbn1cblxuZXhwb3J0IGNvbnN0IGlzUmVzcG9uc2VMaWtlID0gKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBSZXNwb25zZUxpa2UgPT5cbiAgdmFsdWUgIT0gbnVsbCAmJlxuICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gIHR5cGVvZiB2YWx1ZS51cmwgPT09ICdzdHJpbmcnICYmXG4gIHR5cGVvZiB2YWx1ZS5ibG9iID09PSAnZnVuY3Rpb24nO1xuXG5leHBvcnQgY29uc3QgaXNGaWxlTGlrZSA9ICh2YWx1ZTogYW55KTogdmFsdWUgaXMgRmlsZUxpa2UgPT5cbiAgdmFsdWUgIT0gbnVsbCAmJlxuICB0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnICYmXG4gIHR5cGVvZiB2YWx1ZS5uYW1lID09PSAnc3RyaW5nJyAmJlxuICB0eXBlb2YgdmFsdWUubGFzdE1vZGlmaWVkID09PSAnbnVtYmVyJyAmJlxuICBpc0Jsb2JMaWtlKHZhbHVlKTtcblxuLyoqXG4gKiBUaGUgQmxvYkxpa2UgdHlwZSBvbWl0cyBhcnJheUJ1ZmZlcigpIGJlY2F1c2UgQHR5cGVzL25vZGUtZmV0Y2hAXjIuNi40IGxhY2tzIGl0OyBidXQgdGhpcyBjaGVja1xuICogYWRkcyB0aGUgYXJyYXlCdWZmZXIoKSBtZXRob2QgdHlwZSBiZWNhdXNlIGl0IGlzIGF2YWlsYWJsZSBhbmQgdXNlZCBhdCBydW50aW1lXG4gKi9cbmV4cG9ydCBjb25zdCBpc0Jsb2JMaWtlID0gKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBCbG9iTGlrZSAmIHsgYXJyYXlCdWZmZXIoKTogUHJvbWlzZTxBcnJheUJ1ZmZlcj4gfSA9PlxuICB2YWx1ZSAhPSBudWxsICYmXG4gIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiZcbiAgdHlwZW9mIHZhbHVlLnNpemUgPT09ICdudW1iZXInICYmXG4gIHR5cGVvZiB2YWx1ZS50eXBlID09PSAnc3RyaW5nJyAmJlxuICB0eXBlb2YgdmFsdWUudGV4dCA9PT0gJ2Z1bmN0aW9uJyAmJlxuICB0eXBlb2YgdmFsdWUuc2xpY2UgPT09ICdmdW5jdGlvbicgJiZcbiAgdHlwZW9mIHZhbHVlLmFycmF5QnVmZmVyID09PSAnZnVuY3Rpb24nO1xuXG5leHBvcnQgY29uc3QgaXNVcGxvYWRhYmxlID0gKHZhbHVlOiBhbnkpOiB2YWx1ZSBpcyBVcGxvYWRhYmxlID0+IHtcbiAgcmV0dXJuIGlzRmlsZUxpa2UodmFsdWUpIHx8IGlzUmVzcG9uc2VMaWtlKHZhbHVlKSB8fCBpc0ZzUmVhZFN0cmVhbSh2YWx1ZSk7XG59O1xuXG5leHBvcnQgdHlwZSBUb0ZpbGVJbnB1dCA9IFVwbG9hZGFibGUgfCBFeGNsdWRlPEJsb2JMaWtlUGFydCwgc3RyaW5nPiB8IEFzeW5jSXRlcmFibGU8QmxvYkxpa2VQYXJ0PjtcblxuLyoqXG4gKiBIZWxwZXIgZm9yIGNyZWF0aW5nIGEge0BsaW5rIEZpbGV9IHRvIHBhc3MgdG8gYW4gU0RLIHVwbG9hZCBtZXRob2QgZnJvbSBhIHZhcmlldHkgb2YgZGlmZmVyZW50IGRhdGEgZm9ybWF0c1xuICogQHBhcmFtIHZhbHVlIHRoZSByYXcgY29udGVudCBvZiB0aGUgZmlsZS4gIENhbiBiZSBhbiB7QGxpbmsgVXBsb2FkYWJsZX0sIHtAbGluayBCbG9iTGlrZVBhcnR9LCBvciB7QGxpbmsgQXN5bmNJdGVyYWJsZX0gb2Yge0BsaW5rIEJsb2JMaWtlUGFydH1zXG4gKiBAcGFyYW0ge3N0cmluZz19IG5hbWUgdGhlIG5hbWUgb2YgdGhlIGZpbGUuIElmIG9taXR0ZWQsIHRvRmlsZSB3aWxsIHRyeSB0byBkZXRlcm1pbmUgYSBmaWxlIG5hbWUgZnJvbSBiaXRzIGlmIHBvc3NpYmxlXG4gKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMgYWRkaXRpb25hbCBwcm9wZXJ0aWVzXG4gKiBAcGFyYW0ge3N0cmluZz19IG9wdGlvbnMudHlwZSB0aGUgTUlNRSB0eXBlIG9mIHRoZSBjb250ZW50XG4gKiBAcGFyYW0ge251bWJlcj19IG9wdGlvbnMubGFzdE1vZGlmaWVkIHRoZSBsYXN0IG1vZGlmaWVkIHRpbWVzdGFtcFxuICogQHJldHVybnMgYSB7QGxpbmsgRmlsZX0gd2l0aCB0aGUgZ2l2ZW4gcHJvcGVydGllc1xuICovXG5leHBvcnQgYXN5bmMgZnVuY3Rpb24gdG9GaWxlKFxuICB2YWx1ZTogVG9GaWxlSW5wdXQgfCBQcm9taXNlTGlrZTxUb0ZpbGVJbnB1dD4sXG4gIG5hbWU/OiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkLFxuICBvcHRpb25zOiBGaWxlUHJvcGVydHlCYWcgfCB1bmRlZmluZWQgPSB7fSxcbik6IFByb21pc2U8RmlsZUxpa2U+IHtcbiAgLy8gSWYgaXQncyBhIHByb21pc2UsIHJlc29sdmUgaXQuXG4gIHZhbHVlID0gYXdhaXQgdmFsdWU7XG5cbiAgaWYgKGlzUmVzcG9uc2VMaWtlKHZhbHVlKSkge1xuICAgIGNvbnN0IGJsb2IgPSBhd2FpdCB2YWx1ZS5ibG9iKCk7XG4gICAgbmFtZSB8fD0gbmV3IFVSTCh2YWx1ZS51cmwpLnBhdGhuYW1lLnNwbGl0KC9bXFxcXC9dLykucG9wKCkgPz8gJ3Vua25vd25fZmlsZSc7XG5cbiAgICByZXR1cm4gbmV3IEZpbGUoW2Jsb2IgYXMgYW55XSwgbmFtZSwgb3B0aW9ucyk7XG4gIH1cblxuICBjb25zdCBiaXRzID0gYXdhaXQgZ2V0Qnl0ZXModmFsdWUpO1xuXG4gIG5hbWUgfHw9IGdldE5hbWUodmFsdWUpID8/ICd1bmtub3duX2ZpbGUnO1xuXG4gIGlmICghb3B0aW9ucy50eXBlKSB7XG4gICAgY29uc3QgdHlwZSA9IChiaXRzWzBdIGFzIGFueSk/LnR5cGU7XG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgb3B0aW9ucyA9IHsgLi4ub3B0aW9ucywgdHlwZSB9O1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBuZXcgRmlsZShiaXRzLCBuYW1lLCBvcHRpb25zKTtcbn1cblxuYXN5bmMgZnVuY3Rpb24gZ2V0Qnl0ZXModmFsdWU6IFRvRmlsZUlucHV0KTogUHJvbWlzZTxBcnJheTxCbG9iUGFydD4+IHtcbiAgbGV0IHBhcnRzOiBBcnJheTxCbG9iUGFydD4gPSBbXTtcbiAgaWYgKFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHxcbiAgICBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsdWUpIHx8IC8vIGluY2x1ZGVzIFVpbnQ4QXJyYXksIEJ1ZmZlciwgZXRjLlxuICAgIHZhbHVlIGluc3RhbmNlb2YgQXJyYXlCdWZmZXJcbiAgKSB7XG4gICAgcGFydHMucHVzaCh2YWx1ZSk7XG4gIH0gZWxzZSBpZiAoaXNCbG9iTGlrZSh2YWx1ZSkpIHtcbiAgICBwYXJ0cy5wdXNoKGF3YWl0IHZhbHVlLmFycmF5QnVmZmVyKCkpO1xuICB9IGVsc2UgaWYgKFxuICAgIGlzQXN5bmNJdGVyYWJsZUl0ZXJhdG9yKHZhbHVlKSAvLyBpbmNsdWRlcyBSZWFkYWJsZSwgUmVhZGFibGVTdHJlYW0sIGV0Yy5cbiAgKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBjaHVuayBvZiB2YWx1ZSkge1xuICAgICAgcGFydHMucHVzaChjaHVuayBhcyBCbG9iUGFydCk7IC8vIFRPRE8sIGNvbnNpZGVyIHZhbGlkYXRpbmc/XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAgIGBVbmV4cGVjdGVkIGRhdGEgdHlwZTogJHt0eXBlb2YgdmFsdWV9OyBjb25zdHJ1Y3RvcjogJHt2YWx1ZT8uY29uc3RydWN0b3JcbiAgICAgICAgPy5uYW1lfTsgcHJvcHM6ICR7cHJvcHNGb3JFcnJvcih2YWx1ZSl9YCxcbiAgICApO1xuICB9XG5cbiAgcmV0dXJuIHBhcnRzO1xufVxuXG5mdW5jdGlvbiBwcm9wc0ZvckVycm9yKHZhbHVlOiBhbnkpOiBzdHJpbmcge1xuICBjb25zdCBwcm9wcyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKHZhbHVlKTtcbiAgcmV0dXJuIGBbJHtwcm9wcy5tYXAoKHApID0+IGBcIiR7cH1cImApLmpvaW4oJywgJyl9XWA7XG59XG5cbmZ1bmN0aW9uIGdldE5hbWUodmFsdWU6IGFueSk6IHN0cmluZyB8IHVuZGVmaW5lZCB7XG4gIHJldHVybiAoXG4gICAgZ2V0U3RyaW5nRnJvbU1heWJlQnVmZmVyKHZhbHVlLm5hbWUpIHx8XG4gICAgZ2V0U3RyaW5nRnJvbU1heWJlQnVmZmVyKHZhbHVlLmZpbGVuYW1lKSB8fFxuICAgIC8vIEZvciBmcy5SZWFkU3RyZWFtXG4gICAgZ2V0U3RyaW5nRnJvbU1heWJlQnVmZmVyKHZhbHVlLnBhdGgpPy5zcGxpdCgvW1xcXFwvXS8pLnBvcCgpXG4gICk7XG59XG5cbmNvbnN0IGdldFN0cmluZ0Zyb21NYXliZUJ1ZmZlciA9ICh4OiBzdHJpbmcgfCBCdWZmZXIgfCB1bmtub3duKTogc3RyaW5nIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHR5cGVvZiB4ID09PSAnc3RyaW5nJykgcmV0dXJuIHg7XG4gIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJyAmJiB4IGluc3RhbmNlb2YgQnVmZmVyKSByZXR1cm4gU3RyaW5nKHgpO1xuICByZXR1cm4gdW5kZWZpbmVkO1xufTtcblxuY29uc3QgaXNBc3luY0l0ZXJhYmxlSXRlcmF0b3IgPSAodmFsdWU6IGFueSk6IHZhbHVlIGlzIEFzeW5jSXRlcmFibGVJdGVyYXRvcjx1bmtub3duPiA9PlxuICB2YWx1ZSAhPSBudWxsICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIHZhbHVlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9PT0gJ2Z1bmN0aW9uJztcblxuZXhwb3J0IGNvbnN0IGlzTXVsdGlwYXJ0Qm9keSA9IChib2R5OiBhbnkpOiBib2R5IGlzIE11bHRpcGFydEJvZHkgPT5cbiAgYm9keSAmJiB0eXBlb2YgYm9keSA9PT0gJ29iamVjdCcgJiYgYm9keS5ib2R5ICYmIGJvZHlbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ011bHRpcGFydEJvZHknO1xuXG4vKipcbiAqIFJldHVybnMgYSBtdWx0aXBhcnQvZm9ybS1kYXRhIHJlcXVlc3QgaWYgYW55IHBhcnQgb2YgdGhlIGdpdmVuIHJlcXVlc3QgYm9keSBjb250YWlucyBhIEZpbGUgLyBCbG9iIHZhbHVlLlxuICogT3RoZXJ3aXNlIHJldHVybnMgdGhlIHJlcXVlc3QgYXMgaXMuXG4gKi9cbmV4cG9ydCBjb25zdCBtYXliZU11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyA9IGFzeW5jIDxUID0gUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KFxuICBvcHRzOiBSZXF1ZXN0T3B0aW9uczxUPixcbik6IFByb21pc2U8UmVxdWVzdE9wdGlvbnM8VCB8IE11bHRpcGFydEJvZHk+PiA9PiB7XG4gIGlmICghaGFzVXBsb2FkYWJsZVZhbHVlKG9wdHMuYm9keSkpIHJldHVybiBvcHRzO1xuXG4gIGNvbnN0IGZvcm0gPSBhd2FpdCBjcmVhdGVGb3JtKG9wdHMuYm9keSk7XG4gIHJldHVybiBnZXRNdWx0aXBhcnRSZXF1ZXN0T3B0aW9ucyhmb3JtLCBvcHRzKTtcbn07XG5cbmV4cG9ydCBjb25zdCBtdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMgPSBhc3luYyA8VCA9IFJlY29yZDxzdHJpbmcsIHVua25vd24+PihcbiAgb3B0czogUmVxdWVzdE9wdGlvbnM8VD4sXG4pOiBQcm9taXNlPFJlcXVlc3RPcHRpb25zPFQgfCBNdWx0aXBhcnRCb2R5Pj4gPT4ge1xuICBjb25zdCBmb3JtID0gYXdhaXQgY3JlYXRlRm9ybShvcHRzLmJvZHkpO1xuICByZXR1cm4gZ2V0TXVsdGlwYXJ0UmVxdWVzdE9wdGlvbnMoZm9ybSwgb3B0cyk7XG59O1xuXG5leHBvcnQgY29uc3QgY3JlYXRlRm9ybSA9IGFzeW5jIDxUID0gUmVjb3JkPHN0cmluZywgdW5rbm93bj4+KGJvZHk6IFQgfCB1bmRlZmluZWQpOiBQcm9taXNlPEZvcm1EYXRhPiA9PiB7XG4gIGNvbnN0IGZvcm0gPSBuZXcgRm9ybURhdGEoKTtcbiAgYXdhaXQgUHJvbWlzZS5hbGwoT2JqZWN0LmVudHJpZXMoYm9keSB8fCB7fSkubWFwKChba2V5LCB2YWx1ZV0pID0+IGFkZEZvcm1WYWx1ZShmb3JtLCBrZXksIHZhbHVlKSkpO1xuICByZXR1cm4gZm9ybTtcbn07XG5cbmNvbnN0IGhhc1VwbG9hZGFibGVWYWx1ZSA9ICh2YWx1ZTogdW5rbm93bik6IGJvb2xlYW4gPT4ge1xuICBpZiAoaXNVcGxvYWRhYmxlKHZhbHVlKSkgcmV0dXJuIHRydWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkgcmV0dXJuIHZhbHVlLnNvbWUoaGFzVXBsb2FkYWJsZVZhbHVlKTtcbiAgaWYgKHZhbHVlICYmIHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcpIHtcbiAgICBmb3IgKGNvbnN0IGsgaW4gdmFsdWUpIHtcbiAgICAgIGlmIChoYXNVcGxvYWRhYmxlVmFsdWUoKHZhbHVlIGFzIGFueSlba10pKSByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlO1xufTtcblxuY29uc3QgYWRkRm9ybVZhbHVlID0gYXN5bmMgKGZvcm06IEZvcm1EYXRhLCBrZXk6IHN0cmluZywgdmFsdWU6IHVua25vd24pOiBQcm9taXNlPHZvaWQ+ID0+IHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHJldHVybjtcbiAgaWYgKHZhbHVlID09IG51bGwpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFxuICAgICAgYFJlY2VpdmVkIG51bGwgZm9yIFwiJHtrZXl9XCI7IHRvIHBhc3MgbnVsbCBpbiBGb3JtRGF0YSwgeW91IG11c3QgdXNlIHRoZSBzdHJpbmcgJ251bGwnYCxcbiAgICApO1xuICB9XG5cbiAgLy8gVE9ETzogbWFrZSBuZXN0ZWQgZm9ybWF0cyBjb25maWd1cmFibGVcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycgfHwgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fCB0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykge1xuICAgIGZvcm0uYXBwZW5kKGtleSwgU3RyaW5nKHZhbHVlKSk7XG4gIH0gZWxzZSBpZiAoaXNVcGxvYWRhYmxlKHZhbHVlKSkge1xuICAgIGNvbnN0IGZpbGUgPSBhd2FpdCB0b0ZpbGUodmFsdWUpO1xuICAgIGZvcm0uYXBwZW5kKGtleSwgZmlsZSBhcyBGaWxlKTtcbiAgfSBlbHNlIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIGF3YWl0IFByb21pc2UuYWxsKHZhbHVlLm1hcCgoZW50cnkpID0+IGFkZEZvcm1WYWx1ZShmb3JtLCBrZXkgKyAnW10nLCBlbnRyeSkpKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgdmFsdWUgPT09ICdvYmplY3QnKSB7XG4gICAgYXdhaXQgUHJvbWlzZS5hbGwoXG4gICAgICBPYmplY3QuZW50cmllcyh2YWx1ZSkubWFwKChbbmFtZSwgcHJvcF0pID0+IGFkZEZvcm1WYWx1ZShmb3JtLCBgJHtrZXl9WyR7bmFtZX1dYCwgcHJvcCkpLFxuICAgICk7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcbiAgICAgIGBJbnZhbGlkIHZhbHVlIGdpdmVuIHRvIGZvcm0sIGV4cGVjdGVkIGEgc3RyaW5nLCBudW1iZXIsIGJvb2xlYW4sIG9iamVjdCwgQXJyYXksIEZpbGUgb3IgQmxvYiBidXQgZ290ICR7dmFsdWV9IGluc3RlYWRgLFxuICAgICk7XG4gIH1cbn07XG4iLCAiaW1wb3J0IHsgVkVSU0lPTiB9IGZyb20gJy4vdmVyc2lvbic7XG5pbXBvcnQgeyBTdHJlYW0gfSBmcm9tICcuL2xpYi9zdHJlYW1pbmcnO1xuaW1wb3J0IHtcbiAgR3JvcUVycm9yLFxuICBBUElFcnJvcixcbiAgQVBJQ29ubmVjdGlvbkVycm9yLFxuICBBUElDb25uZWN0aW9uVGltZW91dEVycm9yLFxuICBBUElVc2VyQWJvcnRFcnJvcixcbn0gZnJvbSAnLi9lcnJvcic7XG5pbXBvcnQge1xuICBraW5kIGFzIHNoaW1zS2luZCxcbiAgdHlwZSBSZWFkYWJsZSxcbiAgZ2V0RGVmYXVsdEFnZW50LFxuICB0eXBlIEFnZW50LFxuICBmZXRjaCxcbiAgdHlwZSBSZXF1ZXN0SW5mbyxcbiAgdHlwZSBSZXF1ZXN0SW5pdCxcbiAgdHlwZSBSZXNwb25zZSxcbiAgdHlwZSBIZWFkZXJzSW5pdCxcbn0gZnJvbSAnLi9fc2hpbXMvaW5kZXgnO1xuZXhwb3J0IHsgdHlwZSBSZXNwb25zZSB9O1xuaW1wb3J0IHsgaXNNdWx0aXBhcnRCb2R5IH0gZnJvbSAnLi91cGxvYWRzJztcbmV4cG9ydCB7XG4gIG1heWJlTXVsdGlwYXJ0Rm9ybVJlcXVlc3RPcHRpb25zLFxuICBtdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMsXG4gIGNyZWF0ZUZvcm0sXG4gIHR5cGUgVXBsb2FkYWJsZSxcbn0gZnJvbSAnLi91cGxvYWRzJztcblxuZXhwb3J0IHR5cGUgRmV0Y2ggPSAodXJsOiBSZXF1ZXN0SW5mbywgaW5pdD86IFJlcXVlc3RJbml0KSA9PiBQcm9taXNlPFJlc3BvbnNlPjtcblxudHlwZSBQcm9taXNlT3JWYWx1ZTxUPiA9IFQgfCBQcm9taXNlPFQ+O1xuXG50eXBlIEFQSVJlc3BvbnNlUHJvcHMgPSB7XG4gIHJlc3BvbnNlOiBSZXNwb25zZTtcbiAgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucztcbiAgY29udHJvbGxlcjogQWJvcnRDb250cm9sbGVyO1xufTtcblxuYXN5bmMgZnVuY3Rpb24gZGVmYXVsdFBhcnNlUmVzcG9uc2U8VD4ocHJvcHM6IEFQSVJlc3BvbnNlUHJvcHMpOiBQcm9taXNlPFQ+IHtcbiAgY29uc3QgeyByZXNwb25zZSB9ID0gcHJvcHM7XG4gIGlmIChwcm9wcy5vcHRpb25zLnN0cmVhbSkge1xuICAgIGRlYnVnKCdyZXNwb25zZScsIHJlc3BvbnNlLnN0YXR1cywgcmVzcG9uc2UudXJsLCByZXNwb25zZS5oZWFkZXJzLCByZXNwb25zZS5ib2R5KTtcblxuICAgIC8vIE5vdGU6IHRoZXJlIGlzIGFuIGludmFyaWFudCBoZXJlIHRoYXQgaXNuJ3QgcmVwcmVzZW50ZWQgaW4gdGhlIHR5cGUgc3lzdGVtXG4gICAgLy8gdGhhdCBpZiB5b3Ugc2V0IGBzdHJlYW06IHRydWVgIHRoZSByZXNwb25zZSB0eXBlIG11c3QgYWxzbyBiZSBgU3RyZWFtPFQ+YFxuXG4gICAgaWYgKHByb3BzLm9wdGlvbnMuX19zdHJlYW1DbGFzcykge1xuICAgICAgcmV0dXJuIHByb3BzLm9wdGlvbnMuX19zdHJlYW1DbGFzcy5mcm9tU1NFUmVzcG9uc2UocmVzcG9uc2UsIHByb3BzLmNvbnRyb2xsZXIpIGFzIGFueTtcbiAgICB9XG5cbiAgICByZXR1cm4gU3RyZWFtLmZyb21TU0VSZXNwb25zZShyZXNwb25zZSwgcHJvcHMuY29udHJvbGxlcikgYXMgYW55O1xuICB9XG5cbiAgLy8gZmV0Y2ggcmVmdXNlcyB0byByZWFkIHRoZSBib2R5IHdoZW4gdGhlIHN0YXR1cyBjb2RlIGlzIDIwNC5cbiAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gMjA0KSB7XG4gICAgcmV0dXJuIG51bGwgYXMgVDtcbiAgfVxuXG4gIGlmIChwcm9wcy5vcHRpb25zLl9fYmluYXJ5UmVzcG9uc2UpIHtcbiAgICByZXR1cm4gcmVzcG9uc2UgYXMgdW5rbm93biBhcyBUO1xuICB9XG5cbiAgY29uc3QgY29udGVudFR5cGUgPSByZXNwb25zZS5oZWFkZXJzLmdldCgnY29udGVudC10eXBlJyk7XG4gIGNvbnN0IGlzSlNPTiA9XG4gICAgY29udGVudFR5cGU/LmluY2x1ZGVzKCdhcHBsaWNhdGlvbi9qc29uJykgfHwgY29udGVudFR5cGU/LmluY2x1ZGVzKCdhcHBsaWNhdGlvbi92bmQuYXBpK2pzb24nKTtcbiAgaWYgKGlzSlNPTikge1xuICAgIGNvbnN0IGpzb24gPSBhd2FpdCByZXNwb25zZS5qc29uKCk7XG5cbiAgICBkZWJ1ZygncmVzcG9uc2UnLCByZXNwb25zZS5zdGF0dXMsIHJlc3BvbnNlLnVybCwgcmVzcG9uc2UuaGVhZGVycywganNvbik7XG5cbiAgICByZXR1cm4ganNvbiBhcyBUO1xuICB9XG5cbiAgY29uc3QgdGV4dCA9IGF3YWl0IHJlc3BvbnNlLnRleHQoKTtcbiAgZGVidWcoJ3Jlc3BvbnNlJywgcmVzcG9uc2Uuc3RhdHVzLCByZXNwb25zZS51cmwsIHJlc3BvbnNlLmhlYWRlcnMsIHRleHQpO1xuXG4gIC8vIFRPRE8gaGFuZGxlIGJsb2IsIGFycmF5YnVmZmVyLCBvdGhlciBjb250ZW50IHR5cGVzLCBldGMuXG4gIHJldHVybiB0ZXh0IGFzIHVua25vd24gYXMgVDtcbn1cblxuLyoqXG4gKiBBIHN1YmNsYXNzIG9mIGBQcm9taXNlYCBwcm92aWRpbmcgYWRkaXRpb25hbCBoZWxwZXIgbWV0aG9kc1xuICogZm9yIGludGVyYWN0aW5nIHdpdGggdGhlIFNESy5cbiAqL1xuZXhwb3J0IGNsYXNzIEFQSVByb21pc2U8VD4gZXh0ZW5kcyBQcm9taXNlPFQ+IHtcbiAgcHJpdmF0ZSBwYXJzZWRQcm9taXNlOiBQcm9taXNlPFQ+IHwgdW5kZWZpbmVkO1xuXG4gIGNvbnN0cnVjdG9yKFxuICAgIHByaXZhdGUgcmVzcG9uc2VQcm9taXNlOiBQcm9taXNlPEFQSVJlc3BvbnNlUHJvcHM+LFxuICAgIHByaXZhdGUgcGFyc2VSZXNwb25zZTogKHByb3BzOiBBUElSZXNwb25zZVByb3BzKSA9PiBQcm9taXNlT3JWYWx1ZTxUPiA9IGRlZmF1bHRQYXJzZVJlc3BvbnNlLFxuICApIHtcbiAgICBzdXBlcigocmVzb2x2ZSkgPT4ge1xuICAgICAgLy8gdGhpcyBpcyBtYXliZSBhIGJpdCB3ZWlyZCBidXQgdGhpcyBoYXMgdG8gYmUgYSBuby1vcCB0byBub3QgaW1wbGljaXRseVxuICAgICAgLy8gcGFyc2UgdGhlIHJlc3BvbnNlIGJvZHk7IGluc3RlYWQgLnRoZW4sIC5jYXRjaCwgLmZpbmFsbHkgYXJlIG92ZXJyaWRkZW5cbiAgICAgIC8vIHRvIHBhcnNlIHRoZSByZXNwb25zZVxuICAgICAgcmVzb2x2ZShudWxsIGFzIGFueSk7XG4gICAgfSk7XG4gIH1cblxuICBfdGhlblVud3JhcDxVPih0cmFuc2Zvcm06IChkYXRhOiBUKSA9PiBVKTogQVBJUHJvbWlzZTxVPiB7XG4gICAgcmV0dXJuIG5ldyBBUElQcm9taXNlKHRoaXMucmVzcG9uc2VQcm9taXNlLCBhc3luYyAocHJvcHMpID0+IHRyYW5zZm9ybShhd2FpdCB0aGlzLnBhcnNlUmVzcG9uc2UocHJvcHMpKSk7XG4gIH1cblxuICAvKipcbiAgICogR2V0cyB0aGUgcmF3IGBSZXNwb25zZWAgaW5zdGFuY2UgaW5zdGVhZCBvZiBwYXJzaW5nIHRoZSByZXNwb25zZVxuICAgKiBkYXRhLlxuICAgKlxuICAgKiBJZiB5b3Ugd2FudCB0byBwYXJzZSB0aGUgcmVzcG9uc2UgYm9keSBidXQgc3RpbGwgZ2V0IHRoZSBgUmVzcG9uc2VgXG4gICAqIGluc3RhbmNlLCB5b3UgY2FuIHVzZSB7QGxpbmsgd2l0aFJlc3BvbnNlKCl9LlxuICAgKlxuICAgKiBcdUQ4M0RcdURDNEIgR2V0dGluZyB0aGUgd3JvbmcgVHlwZVNjcmlwdCB0eXBlIGZvciBgUmVzcG9uc2VgP1xuICAgKiBUcnkgc2V0dGluZyBgXCJtb2R1bGVSZXNvbHV0aW9uXCI6IFwiTm9kZU5leHRcImAgaWYgeW91IGNhbixcbiAgICogb3IgYWRkIG9uZSBvZiB0aGVzZSBpbXBvcnRzIGJlZm9yZSB5b3VyIGZpcnN0IGBpbXBvcnQgXHUyMDI2IGZyb20gJ2dyb3Etc2RrJ2A6XG4gICAqIC0gYGltcG9ydCAnZ3JvcS1zZGsvc2hpbXMvbm9kZSdgIChpZiB5b3UncmUgcnVubmluZyBvbiBOb2RlKVxuICAgKiAtIGBpbXBvcnQgJ2dyb3Etc2RrL3NoaW1zL3dlYidgIChvdGhlcndpc2UpXG4gICAqL1xuICBhc1Jlc3BvbnNlKCk6IFByb21pc2U8UmVzcG9uc2U+IHtcbiAgICByZXR1cm4gdGhpcy5yZXNwb25zZVByb21pc2UudGhlbigocCkgPT4gcC5yZXNwb25zZSk7XG4gIH1cbiAgLyoqXG4gICAqIEdldHMgdGhlIHBhcnNlZCByZXNwb25zZSBkYXRhIGFuZCB0aGUgcmF3IGBSZXNwb25zZWAgaW5zdGFuY2UuXG4gICAqXG4gICAqIElmIHlvdSBqdXN0IHdhbnQgdG8gZ2V0IHRoZSByYXcgYFJlc3BvbnNlYCBpbnN0YW5jZSB3aXRob3V0IHBhcnNpbmcgaXQsXG4gICAqIHlvdSBjYW4gdXNlIHtAbGluayBhc1Jlc3BvbnNlKCl9LlxuICAgKlxuICAgKlxuICAgKiBcdUQ4M0RcdURDNEIgR2V0dGluZyB0aGUgd3JvbmcgVHlwZVNjcmlwdCB0eXBlIGZvciBgUmVzcG9uc2VgP1xuICAgKiBUcnkgc2V0dGluZyBgXCJtb2R1bGVSZXNvbHV0aW9uXCI6IFwiTm9kZU5leHRcImAgaWYgeW91IGNhbixcbiAgICogb3IgYWRkIG9uZSBvZiB0aGVzZSBpbXBvcnRzIGJlZm9yZSB5b3VyIGZpcnN0IGBpbXBvcnQgXHUyMDI2IGZyb20gJ2dyb3Etc2RrJ2A6XG4gICAqIC0gYGltcG9ydCAnZ3JvcS1zZGsvc2hpbXMvbm9kZSdgIChpZiB5b3UncmUgcnVubmluZyBvbiBOb2RlKVxuICAgKiAtIGBpbXBvcnQgJ2dyb3Etc2RrL3NoaW1zL3dlYidgIChvdGhlcndpc2UpXG4gICAqL1xuICBhc3luYyB3aXRoUmVzcG9uc2UoKTogUHJvbWlzZTx7IGRhdGE6IFQ7IHJlc3BvbnNlOiBSZXNwb25zZSB9PiB7XG4gICAgY29uc3QgW2RhdGEsIHJlc3BvbnNlXSA9IGF3YWl0IFByb21pc2UuYWxsKFt0aGlzLnBhcnNlKCksIHRoaXMuYXNSZXNwb25zZSgpXSk7XG4gICAgcmV0dXJuIHsgZGF0YSwgcmVzcG9uc2UgfTtcbiAgfVxuXG4gIHByaXZhdGUgcGFyc2UoKTogUHJvbWlzZTxUPiB7XG4gICAgaWYgKCF0aGlzLnBhcnNlZFByb21pc2UpIHtcbiAgICAgIHRoaXMucGFyc2VkUHJvbWlzZSA9IHRoaXMucmVzcG9uc2VQcm9taXNlLnRoZW4odGhpcy5wYXJzZVJlc3BvbnNlKTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGFyc2VkUHJvbWlzZTtcbiAgfVxuXG4gIG92ZXJyaWRlIHRoZW48VFJlc3VsdDEgPSBULCBUUmVzdWx0MiA9IG5ldmVyPihcbiAgICBvbmZ1bGZpbGxlZD86ICgodmFsdWU6IFQpID0+IFRSZXN1bHQxIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDE+KSB8IHVuZGVmaW5lZCB8IG51bGwsXG4gICAgb25yZWplY3RlZD86ICgocmVhc29uOiBhbnkpID0+IFRSZXN1bHQyIHwgUHJvbWlzZUxpa2U8VFJlc3VsdDI+KSB8IHVuZGVmaW5lZCB8IG51bGwsXG4gICk6IFByb21pc2U8VFJlc3VsdDEgfCBUUmVzdWx0Mj4ge1xuICAgIHJldHVybiB0aGlzLnBhcnNlKCkudGhlbihvbmZ1bGZpbGxlZCwgb25yZWplY3RlZCk7XG4gIH1cblxuICBvdmVycmlkZSBjYXRjaDxUUmVzdWx0ID0gbmV2ZXI+KFxuICAgIG9ucmVqZWN0ZWQ/OiAoKHJlYXNvbjogYW55KSA9PiBUUmVzdWx0IHwgUHJvbWlzZUxpa2U8VFJlc3VsdD4pIHwgdW5kZWZpbmVkIHwgbnVsbCxcbiAgKTogUHJvbWlzZTxUIHwgVFJlc3VsdD4ge1xuICAgIHJldHVybiB0aGlzLnBhcnNlKCkuY2F0Y2gob25yZWplY3RlZCk7XG4gIH1cblxuICBvdmVycmlkZSBmaW5hbGx5KG9uZmluYWxseT86ICgoKSA9PiB2b2lkKSB8IHVuZGVmaW5lZCB8IG51bGwpOiBQcm9taXNlPFQ+IHtcbiAgICByZXR1cm4gdGhpcy5wYXJzZSgpLmZpbmFsbHkob25maW5hbGx5KTtcbiAgfVxufVxuXG5leHBvcnQgYWJzdHJhY3QgY2xhc3MgQVBJQ2xpZW50IHtcbiAgYmFzZVVSTDogc3RyaW5nO1xuICBtYXhSZXRyaWVzOiBudW1iZXI7XG4gIHRpbWVvdXQ6IG51bWJlcjtcbiAgaHR0cEFnZW50OiBBZ2VudCB8IHVuZGVmaW5lZDtcblxuICBwcml2YXRlIGZldGNoOiBGZXRjaDtcbiAgcHJvdGVjdGVkIGlkZW1wb3RlbmN5SGVhZGVyPzogc3RyaW5nO1xuXG4gIGNvbnN0cnVjdG9yKHtcbiAgICBiYXNlVVJMLFxuICAgIG1heFJldHJpZXMgPSAyLFxuICAgIHRpbWVvdXQgPSA2MDAwMCwgLy8gMSBtaW51dGVcbiAgICBodHRwQWdlbnQsXG4gICAgZmV0Y2g6IG92ZXJyaWRlbkZldGNoLFxuICB9OiB7XG4gICAgYmFzZVVSTDogc3RyaW5nO1xuICAgIG1heFJldHJpZXM/OiBudW1iZXIgfCB1bmRlZmluZWQ7XG4gICAgdGltZW91dDogbnVtYmVyIHwgdW5kZWZpbmVkO1xuICAgIGh0dHBBZ2VudDogQWdlbnQgfCB1bmRlZmluZWQ7XG4gICAgZmV0Y2g6IEZldGNoIHwgdW5kZWZpbmVkO1xuICB9KSB7XG4gICAgdGhpcy5iYXNlVVJMID0gYmFzZVVSTDtcbiAgICB0aGlzLm1heFJldHJpZXMgPSB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcignbWF4UmV0cmllcycsIG1heFJldHJpZXMpO1xuICAgIHRoaXMudGltZW91dCA9IHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyKCd0aW1lb3V0JywgdGltZW91dCk7XG4gICAgdGhpcy5odHRwQWdlbnQgPSBodHRwQWdlbnQ7XG5cbiAgICB0aGlzLmZldGNoID0gb3ZlcnJpZGVuRmV0Y2ggPz8gZmV0Y2g7XG4gIH1cblxuICBwcm90ZWN0ZWQgYXV0aEhlYWRlcnMob3B0czogRmluYWxSZXF1ZXN0T3B0aW9ucyk6IEhlYWRlcnMge1xuICAgIHJldHVybiB7fTtcbiAgfVxuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGlzIHRvIGFkZCB5b3VyIG93biBkZWZhdWx0IGhlYWRlcnMsIGZvciBleGFtcGxlOlxuICAgKlxuICAgKiAge1xuICAgKiAgICAuLi5zdXBlci5kZWZhdWx0SGVhZGVycygpLFxuICAgKiAgICBBdXRob3JpemF0aW9uOiAnQmVhcmVyIDEyMycsXG4gICAqICB9XG4gICAqL1xuICBwcm90ZWN0ZWQgZGVmYXVsdEhlYWRlcnMob3B0czogRmluYWxSZXF1ZXN0T3B0aW9ucyk6IEhlYWRlcnMge1xuICAgIHJldHVybiB7XG4gICAgICBBY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uJyxcbiAgICAgICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAgICAnVXNlci1BZ2VudCc6IHRoaXMuZ2V0VXNlckFnZW50KCksXG4gICAgICAuLi5nZXRQbGF0Zm9ybUhlYWRlcnMoKSxcbiAgICAgIC4uLnRoaXMuYXV0aEhlYWRlcnMob3B0cyksXG4gICAgfTtcbiAgfVxuXG4gIHByb3RlY3RlZCBhYnN0cmFjdCBkZWZhdWx0UXVlcnkoKTogRGVmYXVsdFF1ZXJ5IHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGlzIHRvIGFkZCB5b3VyIG93biBoZWFkZXJzIHZhbGlkYXRpb246XG4gICAqL1xuICBwcm90ZWN0ZWQgdmFsaWRhdGVIZWFkZXJzKGhlYWRlcnM6IEhlYWRlcnMsIGN1c3RvbUhlYWRlcnM6IEhlYWRlcnMpIHt9XG5cbiAgcHJvdGVjdGVkIGRlZmF1bHRJZGVtcG90ZW5jeUtleSgpOiBzdHJpbmcge1xuICAgIHJldHVybiBgc3RhaW5sZXNzLW5vZGUtcmV0cnktJHt1dWlkNCgpfWA7XG4gIH1cblxuICBnZXQ8UmVxLCBSc3A+KHBhdGg6IHN0cmluZywgb3B0cz86IFByb21pc2VPclZhbHVlPFJlcXVlc3RPcHRpb25zPFJlcT4+KTogQVBJUHJvbWlzZTxSc3A+IHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdnZXQnLCBwYXRoLCBvcHRzKTtcbiAgfVxuXG4gIHBvc3Q8UmVxLCBSc3A+KHBhdGg6IHN0cmluZywgb3B0cz86IFByb21pc2VPclZhbHVlPFJlcXVlc3RPcHRpb25zPFJlcT4+KTogQVBJUHJvbWlzZTxSc3A+IHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdwb3N0JywgcGF0aCwgb3B0cyk7XG4gIH1cblxuICBwYXRjaDxSZXEsIFJzcD4ocGF0aDogc3RyaW5nLCBvcHRzPzogUHJvbWlzZU9yVmFsdWU8UmVxdWVzdE9wdGlvbnM8UmVxPj4pOiBBUElQcm9taXNlPFJzcD4ge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZFJlcXVlc3QoJ3BhdGNoJywgcGF0aCwgb3B0cyk7XG4gIH1cblxuICBwdXQ8UmVxLCBSc3A+KHBhdGg6IHN0cmluZywgb3B0cz86IFByb21pc2VPclZhbHVlPFJlcXVlc3RPcHRpb25zPFJlcT4+KTogQVBJUHJvbWlzZTxSc3A+IHtcbiAgICByZXR1cm4gdGhpcy5tZXRob2RSZXF1ZXN0KCdwdXQnLCBwYXRoLCBvcHRzKTtcbiAgfVxuXG4gIGRlbGV0ZTxSZXEsIFJzcD4ocGF0aDogc3RyaW5nLCBvcHRzPzogUHJvbWlzZU9yVmFsdWU8UmVxdWVzdE9wdGlvbnM8UmVxPj4pOiBBUElQcm9taXNlPFJzcD4ge1xuICAgIHJldHVybiB0aGlzLm1ldGhvZFJlcXVlc3QoJ2RlbGV0ZScsIHBhdGgsIG9wdHMpO1xuICB9XG5cbiAgcHJpdmF0ZSBtZXRob2RSZXF1ZXN0PFJlcSwgUnNwPihcbiAgICBtZXRob2Q6IEhUVFBNZXRob2QsXG4gICAgcGF0aDogc3RyaW5nLFxuICAgIG9wdHM/OiBQcm9taXNlT3JWYWx1ZTxSZXF1ZXN0T3B0aW9uczxSZXE+PixcbiAgKTogQVBJUHJvbWlzZTxSc3A+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KFByb21pc2UucmVzb2x2ZShvcHRzKS50aGVuKChvcHRzKSA9PiAoeyBtZXRob2QsIHBhdGgsIC4uLm9wdHMgfSkpKTtcbiAgfVxuXG4gIGdldEFQSUxpc3Q8SXRlbSwgUGFnZUNsYXNzIGV4dGVuZHMgQWJzdHJhY3RQYWdlPEl0ZW0+ID0gQWJzdHJhY3RQYWdlPEl0ZW0+PihcbiAgICBwYXRoOiBzdHJpbmcsXG4gICAgUGFnZTogbmV3ICguLi5hcmdzOiBhbnlbXSkgPT4gUGFnZUNsYXNzLFxuICAgIG9wdHM/OiBSZXF1ZXN0T3B0aW9uczxhbnk+LFxuICApOiBQYWdlUHJvbWlzZTxQYWdlQ2xhc3MsIEl0ZW0+IHtcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0QVBJTGlzdChQYWdlLCB7IG1ldGhvZDogJ2dldCcsIHBhdGgsIC4uLm9wdHMgfSk7XG4gIH1cblxuICBwcml2YXRlIGNhbGN1bGF0ZUNvbnRlbnRMZW5ndGgoYm9keTogdW5rbm93bik6IHN0cmluZyB8IG51bGwge1xuICAgIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmJ5dGVMZW5ndGgoYm9keSwgJ3V0ZjgnKS50b1N0cmluZygpO1xuICAgICAgfVxuXG4gICAgICBpZiAodHlwZW9mIFRleHRFbmNvZGVyICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICBjb25zdCBlbmNvZGVyID0gbmV3IFRleHRFbmNvZGVyKCk7XG4gICAgICAgIGNvbnN0IGVuY29kZWQgPSBlbmNvZGVyLmVuY29kZShib2R5KTtcbiAgICAgICAgcmV0dXJuIGVuY29kZWQubGVuZ3RoLnRvU3RyaW5nKCk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIG51bGw7XG4gIH1cblxuICBidWlsZFJlcXVlc3Q8UmVxPihvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zPFJlcT4pOiB7IHJlcTogUmVxdWVzdEluaXQ7IHVybDogc3RyaW5nOyB0aW1lb3V0OiBudW1iZXIgfSB7XG4gICAgY29uc3QgeyBtZXRob2QsIHBhdGgsIHF1ZXJ5LCBoZWFkZXJzOiBoZWFkZXJzID0ge30gfSA9IG9wdGlvbnM7XG5cbiAgICBjb25zdCBib2R5ID1cbiAgICAgIGlzTXVsdGlwYXJ0Qm9keShvcHRpb25zLmJvZHkpID8gb3B0aW9ucy5ib2R5LmJvZHlcbiAgICAgIDogb3B0aW9ucy5ib2R5ID8gSlNPTi5zdHJpbmdpZnkob3B0aW9ucy5ib2R5LCBudWxsLCAyKVxuICAgICAgOiBudWxsO1xuICAgIGNvbnN0IGNvbnRlbnRMZW5ndGggPSB0aGlzLmNhbGN1bGF0ZUNvbnRlbnRMZW5ndGgoYm9keSk7XG5cbiAgICBjb25zdCB1cmwgPSB0aGlzLmJ1aWxkVVJMKHBhdGghLCBxdWVyeSk7XG4gICAgaWYgKCd0aW1lb3V0JyBpbiBvcHRpb25zKSB2YWxpZGF0ZVBvc2l0aXZlSW50ZWdlcigndGltZW91dCcsIG9wdGlvbnMudGltZW91dCk7XG4gICAgY29uc3QgdGltZW91dCA9IG9wdGlvbnMudGltZW91dCA/PyB0aGlzLnRpbWVvdXQ7XG4gICAgY29uc3QgaHR0cEFnZW50ID0gb3B0aW9ucy5odHRwQWdlbnQgPz8gdGhpcy5odHRwQWdlbnQgPz8gZ2V0RGVmYXVsdEFnZW50KHVybCk7XG4gICAgY29uc3QgbWluQWdlbnRUaW1lb3V0ID0gdGltZW91dCArIDEwMDA7XG4gICAgaWYgKFxuICAgICAgdHlwZW9mIChodHRwQWdlbnQgYXMgYW55KT8ub3B0aW9ucz8udGltZW91dCA9PT0gJ251bWJlcicgJiZcbiAgICAgIG1pbkFnZW50VGltZW91dCA+ICgoaHR0cEFnZW50IGFzIGFueSkub3B0aW9ucy50aW1lb3V0ID8/IDApXG4gICAgKSB7XG4gICAgICAvLyBBbGxvdyBhbnkgZ2l2ZW4gcmVxdWVzdCB0byBidW1wIG91ciBhZ2VudCBhY3RpdmUgc29ja2V0IHRpbWVvdXQuXG4gICAgICAvLyBUaGlzIG1heSBzZWVtIHN0cmFuZ2UsIGJ1dCBsZWFraW5nIGFjdGl2ZSBzb2NrZXRzIHNob3VsZCBiZSByYXJlIGFuZCBub3QgcGFydGljdWxhcmx5IHByb2JsZW1hdGljLFxuICAgICAgLy8gYW5kIHdpdGhvdXQgbXV0YXRpbmcgYWdlbnQgd2Ugd291bGQgbmVlZCB0byBjcmVhdGUgbW9yZSBvZiB0aGVtLlxuICAgICAgLy8gVGhpcyB0cmFkZW9mZiBvcHRpbWl6ZXMgZm9yIHBlcmZvcm1hbmNlLlxuICAgICAgKGh0dHBBZ2VudCBhcyBhbnkpLm9wdGlvbnMudGltZW91dCA9IG1pbkFnZW50VGltZW91dDtcbiAgICB9XG5cbiAgICBpZiAodGhpcy5pZGVtcG90ZW5jeUhlYWRlciAmJiBtZXRob2QgIT09ICdnZXQnKSB7XG4gICAgICBpZiAoIW9wdGlvbnMuaWRlbXBvdGVuY3lLZXkpIG9wdGlvbnMuaWRlbXBvdGVuY3lLZXkgPSB0aGlzLmRlZmF1bHRJZGVtcG90ZW5jeUtleSgpO1xuICAgICAgaGVhZGVyc1t0aGlzLmlkZW1wb3RlbmN5SGVhZGVyXSA9IG9wdGlvbnMuaWRlbXBvdGVuY3lLZXk7XG4gICAgfVxuXG4gICAgY29uc3QgcmVxSGVhZGVycyA9IHRoaXMuYnVpbGRIZWFkZXJzKHsgb3B0aW9ucywgaGVhZGVycywgY29udGVudExlbmd0aCB9KTtcblxuICAgIGNvbnN0IHJlcTogUmVxdWVzdEluaXQgPSB7XG4gICAgICBtZXRob2QsXG4gICAgICAuLi4oYm9keSAmJiB7IGJvZHk6IGJvZHkgYXMgYW55IH0pLFxuICAgICAgaGVhZGVyczogcmVxSGVhZGVycyxcbiAgICAgIC4uLihodHRwQWdlbnQgJiYgeyBhZ2VudDogaHR0cEFnZW50IH0pLFxuICAgICAgLy8gQHRzLWlnbm9yZSBub2RlLWZldGNoIHVzZXMgYSBjdXN0b20gQWJvcnRTaWduYWwgdHlwZSB0aGF0IGlzXG4gICAgICAvLyBub3QgY29tcGF0aWJsZSB3aXRoIHN0YW5kYXJkIHdlYiB0eXBlc1xuICAgICAgc2lnbmFsOiBvcHRpb25zLnNpZ25hbCA/PyBudWxsLFxuICAgIH07XG5cbiAgICByZXR1cm4geyByZXEsIHVybCwgdGltZW91dCB9O1xuICB9XG5cbiAgcHJpdmF0ZSBidWlsZEhlYWRlcnMoe1xuICAgIG9wdGlvbnMsXG4gICAgaGVhZGVycyxcbiAgICBjb250ZW50TGVuZ3RoLFxuICB9OiB7XG4gICAgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucztcbiAgICBoZWFkZXJzOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkPjtcbiAgICBjb250ZW50TGVuZ3RoOiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xuICB9KTogUmVjb3JkPHN0cmluZywgc3RyaW5nPiB7XG4gICAgY29uc3QgcmVxSGVhZGVyczogUmVjb3JkPHN0cmluZywgc3RyaW5nPiA9IHt9O1xuICAgIGlmIChjb250ZW50TGVuZ3RoKSB7XG4gICAgICByZXFIZWFkZXJzWydjb250ZW50LWxlbmd0aCddID0gY29udGVudExlbmd0aDtcbiAgICB9XG5cbiAgICBjb25zdCBkZWZhdWx0SGVhZGVycyA9IHRoaXMuZGVmYXVsdEhlYWRlcnMob3B0aW9ucyk7XG4gICAgYXBwbHlIZWFkZXJzTXV0KHJlcUhlYWRlcnMsIGRlZmF1bHRIZWFkZXJzKTtcbiAgICBhcHBseUhlYWRlcnNNdXQocmVxSGVhZGVycywgaGVhZGVycyk7XG5cbiAgICAvLyBsZXQgYnVpbHRpbiBmZXRjaCBzZXQgdGhlIENvbnRlbnQtVHlwZSBmb3IgbXVsdGlwYXJ0IGJvZGllc1xuICAgIGlmIChpc011bHRpcGFydEJvZHkob3B0aW9ucy5ib2R5KSAmJiBzaGltc0tpbmQgIT09ICdub2RlJykge1xuICAgICAgZGVsZXRlIHJlcUhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddO1xuICAgIH1cblxuICAgIHRoaXMudmFsaWRhdGVIZWFkZXJzKHJlcUhlYWRlcnMsIGhlYWRlcnMpO1xuXG4gICAgcmV0dXJuIHJlcUhlYWRlcnM7XG4gIH1cblxuICAvKipcbiAgICogVXNlZCBhcyBhIGNhbGxiYWNrIGZvciBtdXRhdGluZyB0aGUgZ2l2ZW4gYEZpbmFsUmVxdWVzdE9wdGlvbnNgIG9iamVjdC5cbiAgICovXG4gIHByb3RlY3RlZCBhc3luYyBwcmVwYXJlT3B0aW9ucyhvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zKTogUHJvbWlzZTx2b2lkPiB7fVxuXG4gIC8qKlxuICAgKiBVc2VkIGFzIGEgY2FsbGJhY2sgZm9yIG11dGF0aW5nIHRoZSBnaXZlbiBgUmVxdWVzdEluaXRgIG9iamVjdC5cbiAgICpcbiAgICogVGhpcyBpcyB1c2VmdWwgZm9yIGNhc2VzIHdoZXJlIHlvdSB3YW50IHRvIGFkZCBjZXJ0YWluIGhlYWRlcnMgYmFzZWQgb2ZmIG9mXG4gICAqIHRoZSByZXF1ZXN0IHByb3BlcnRpZXMsIGUuZy4gYG1ldGhvZGAgb3IgYHVybGAuXG4gICAqL1xuICBwcm90ZWN0ZWQgYXN5bmMgcHJlcGFyZVJlcXVlc3QoXG4gICAgcmVxdWVzdDogUmVxdWVzdEluaXQsXG4gICAgeyB1cmwsIG9wdGlvbnMgfTogeyB1cmw6IHN0cmluZzsgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucyB9LFxuICApOiBQcm9taXNlPHZvaWQ+IHt9XG5cbiAgcHJvdGVjdGVkIHBhcnNlSGVhZGVycyhoZWFkZXJzOiBIZWFkZXJzSW5pdCB8IG51bGwgfCB1bmRlZmluZWQpOiBSZWNvcmQ8c3RyaW5nLCBzdHJpbmc+IHtcbiAgICByZXR1cm4gKFxuICAgICAgIWhlYWRlcnMgPyB7fVxuICAgICAgOiBTeW1ib2wuaXRlcmF0b3IgaW4gaGVhZGVycyA/XG4gICAgICAgIE9iamVjdC5mcm9tRW50cmllcyhBcnJheS5mcm9tKGhlYWRlcnMgYXMgSXRlcmFibGU8c3RyaW5nW10+KS5tYXAoKGhlYWRlcikgPT4gWy4uLmhlYWRlcl0pKVxuICAgICAgOiB7IC4uLmhlYWRlcnMgfVxuICAgICk7XG4gIH1cblxuICBwcm90ZWN0ZWQgbWFrZVN0YXR1c0Vycm9yKFxuICAgIHN0YXR1czogbnVtYmVyIHwgdW5kZWZpbmVkLFxuICAgIGVycm9yOiBPYmplY3QgfCB1bmRlZmluZWQsXG4gICAgbWVzc2FnZTogc3RyaW5nIHwgdW5kZWZpbmVkLFxuICAgIGhlYWRlcnM6IEhlYWRlcnMgfCB1bmRlZmluZWQsXG4gICkge1xuICAgIHJldHVybiBBUElFcnJvci5nZW5lcmF0ZShzdGF0dXMsIGVycm9yLCBtZXNzYWdlLCBoZWFkZXJzKTtcbiAgfVxuXG4gIHJlcXVlc3Q8UmVxLCBSc3A+KFxuICAgIG9wdGlvbnM6IFByb21pc2VPclZhbHVlPEZpbmFsUmVxdWVzdE9wdGlvbnM8UmVxPj4sXG4gICAgcmVtYWluaW5nUmV0cmllczogbnVtYmVyIHwgbnVsbCA9IG51bGwsXG4gICk6IEFQSVByb21pc2U8UnNwPiB7XG4gICAgcmV0dXJuIG5ldyBBUElQcm9taXNlKHRoaXMubWFrZVJlcXVlc3Qob3B0aW9ucywgcmVtYWluaW5nUmV0cmllcykpO1xuICB9XG5cbiAgcHJpdmF0ZSBhc3luYyBtYWtlUmVxdWVzdDxSZXE+KFxuICAgIG9wdGlvbnNJbnB1dDogUHJvbWlzZU9yVmFsdWU8RmluYWxSZXF1ZXN0T3B0aW9uczxSZXE+PixcbiAgICByZXRyaWVzUmVtYWluaW5nOiBudW1iZXIgfCBudWxsLFxuICApOiBQcm9taXNlPEFQSVJlc3BvbnNlUHJvcHM+IHtcbiAgICBjb25zdCBvcHRpb25zID0gYXdhaXQgb3B0aW9uc0lucHV0O1xuICAgIGlmIChyZXRyaWVzUmVtYWluaW5nID09IG51bGwpIHtcbiAgICAgIHJldHJpZXNSZW1haW5pbmcgPSBvcHRpb25zLm1heFJldHJpZXMgPz8gdGhpcy5tYXhSZXRyaWVzO1xuICAgIH1cblxuICAgIGF3YWl0IHRoaXMucHJlcGFyZU9wdGlvbnMob3B0aW9ucyk7XG5cbiAgICBjb25zdCB7IHJlcSwgdXJsLCB0aW1lb3V0IH0gPSB0aGlzLmJ1aWxkUmVxdWVzdChvcHRpb25zKTtcblxuICAgIGF3YWl0IHRoaXMucHJlcGFyZVJlcXVlc3QocmVxLCB7IHVybCwgb3B0aW9ucyB9KTtcblxuICAgIGRlYnVnKCdyZXF1ZXN0JywgdXJsLCBvcHRpb25zLCByZXEuaGVhZGVycyk7XG5cbiAgICBpZiAob3B0aW9ucy5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgIHRocm93IG5ldyBBUElVc2VyQWJvcnRFcnJvcigpO1xuICAgIH1cblxuICAgIGNvbnN0IGNvbnRyb2xsZXIgPSBuZXcgQWJvcnRDb250cm9sbGVyKCk7XG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCB0aGlzLmZldGNoV2l0aFRpbWVvdXQodXJsLCByZXEsIHRpbWVvdXQsIGNvbnRyb2xsZXIpLmNhdGNoKGNhc3RUb0Vycm9yKTtcblxuICAgIGlmIChyZXNwb25zZSBpbnN0YW5jZW9mIEVycm9yKSB7XG4gICAgICBpZiAob3B0aW9ucy5zaWduYWw/LmFib3J0ZWQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEFQSVVzZXJBYm9ydEVycm9yKCk7XG4gICAgICB9XG4gICAgICBpZiAocmV0cmllc1JlbWFpbmluZykge1xuICAgICAgICByZXR1cm4gdGhpcy5yZXRyeVJlcXVlc3Qob3B0aW9ucywgcmV0cmllc1JlbWFpbmluZyk7XG4gICAgICB9XG4gICAgICBpZiAocmVzcG9uc2UubmFtZSA9PT0gJ0Fib3J0RXJyb3InKSB7XG4gICAgICAgIHRocm93IG5ldyBBUElDb25uZWN0aW9uVGltZW91dEVycm9yKCk7XG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgQVBJQ29ubmVjdGlvbkVycm9yKHsgY2F1c2U6IHJlc3BvbnNlIH0pO1xuICAgIH1cblxuICAgIGNvbnN0IHJlc3BvbnNlSGVhZGVycyA9IGNyZWF0ZVJlc3BvbnNlSGVhZGVycyhyZXNwb25zZS5oZWFkZXJzKTtcblxuICAgIGlmICghcmVzcG9uc2Uub2spIHtcbiAgICAgIGlmIChyZXRyaWVzUmVtYWluaW5nICYmIHRoaXMuc2hvdWxkUmV0cnkocmVzcG9uc2UpKSB7XG4gICAgICAgIGNvbnN0IHJldHJ5TWVzc2FnZSA9IGByZXRyeWluZywgJHtyZXRyaWVzUmVtYWluaW5nfSBhdHRlbXB0cyByZW1haW5pbmdgO1xuICAgICAgICBkZWJ1ZyhgcmVzcG9uc2UgKGVycm9yOyAke3JldHJ5TWVzc2FnZX0pYCwgcmVzcG9uc2Uuc3RhdHVzLCB1cmwsIHJlc3BvbnNlSGVhZGVycyk7XG4gICAgICAgIHJldHVybiB0aGlzLnJldHJ5UmVxdWVzdChvcHRpb25zLCByZXRyaWVzUmVtYWluaW5nLCByZXNwb25zZUhlYWRlcnMpO1xuICAgICAgfVxuXG4gICAgICBjb25zdCBlcnJUZXh0ID0gYXdhaXQgcmVzcG9uc2UudGV4dCgpLmNhdGNoKChlKSA9PiBjYXN0VG9FcnJvcihlKS5tZXNzYWdlKTtcbiAgICAgIGNvbnN0IGVyckpTT04gPSBzYWZlSlNPTihlcnJUZXh0KTtcbiAgICAgIGNvbnN0IGVyck1lc3NhZ2UgPSBlcnJKU09OID8gdW5kZWZpbmVkIDogZXJyVGV4dDtcbiAgICAgIGNvbnN0IHJldHJ5TWVzc2FnZSA9IHJldHJpZXNSZW1haW5pbmcgPyBgKGVycm9yOyBubyBtb3JlIHJldHJpZXMgbGVmdClgIDogYChlcnJvcjsgbm90IHJldHJ5YWJsZSlgO1xuXG4gICAgICBkZWJ1ZyhgcmVzcG9uc2UgKGVycm9yOyAke3JldHJ5TWVzc2FnZX0pYCwgcmVzcG9uc2Uuc3RhdHVzLCB1cmwsIHJlc3BvbnNlSGVhZGVycywgZXJyTWVzc2FnZSk7XG5cbiAgICAgIGNvbnN0IGVyciA9IHRoaXMubWFrZVN0YXR1c0Vycm9yKHJlc3BvbnNlLnN0YXR1cywgZXJySlNPTiwgZXJyTWVzc2FnZSwgcmVzcG9uc2VIZWFkZXJzKTtcbiAgICAgIHRocm93IGVycjtcbiAgICB9XG5cbiAgICByZXR1cm4geyByZXNwb25zZSwgb3B0aW9ucywgY29udHJvbGxlciB9O1xuICB9XG5cbiAgcmVxdWVzdEFQSUxpc3Q8SXRlbSA9IHVua25vd24sIFBhZ2VDbGFzcyBleHRlbmRzIEFic3RyYWN0UGFnZTxJdGVtPiA9IEFic3RyYWN0UGFnZTxJdGVtPj4oXG4gICAgUGFnZTogbmV3ICguLi5hcmdzOiBDb25zdHJ1Y3RvclBhcmFtZXRlcnM8dHlwZW9mIEFic3RyYWN0UGFnZT4pID0+IFBhZ2VDbGFzcyxcbiAgICBvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zLFxuICApOiBQYWdlUHJvbWlzZTxQYWdlQ2xhc3MsIEl0ZW0+IHtcbiAgICBjb25zdCByZXF1ZXN0ID0gdGhpcy5tYWtlUmVxdWVzdChvcHRpb25zLCBudWxsKTtcbiAgICByZXR1cm4gbmV3IFBhZ2VQcm9taXNlPFBhZ2VDbGFzcywgSXRlbT4odGhpcywgcmVxdWVzdCwgUGFnZSk7XG4gIH1cblxuICBidWlsZFVSTDxSZXE+KHBhdGg6IHN0cmluZywgcXVlcnk6IFJlcSB8IG51bGwgfCB1bmRlZmluZWQpOiBzdHJpbmcge1xuICAgIGNvbnN0IHVybCA9XG4gICAgICBpc0Fic29sdXRlVVJMKHBhdGgpID9cbiAgICAgICAgbmV3IFVSTChwYXRoKVxuICAgICAgOiBuZXcgVVJMKHRoaXMuYmFzZVVSTCArICh0aGlzLmJhc2VVUkwuZW5kc1dpdGgoJy8nKSAmJiBwYXRoLnN0YXJ0c1dpdGgoJy8nKSA/IHBhdGguc2xpY2UoMSkgOiBwYXRoKSk7XG5cbiAgICBjb25zdCBkZWZhdWx0UXVlcnkgPSB0aGlzLmRlZmF1bHRRdWVyeSgpO1xuICAgIGlmICghaXNFbXB0eU9iaihkZWZhdWx0UXVlcnkpKSB7XG4gICAgICBxdWVyeSA9IHsgLi4uZGVmYXVsdFF1ZXJ5LCAuLi5xdWVyeSB9IGFzIFJlcTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHF1ZXJ5ID09PSAnb2JqZWN0JyAmJiBxdWVyeSAmJiAhQXJyYXkuaXNBcnJheShxdWVyeSkpIHtcbiAgICAgIHVybC5zZWFyY2ggPSB0aGlzLnN0cmluZ2lmeVF1ZXJ5KHF1ZXJ5IGFzIFJlY29yZDxzdHJpbmcsIHVua25vd24+KTtcbiAgICB9XG5cbiAgICByZXR1cm4gdXJsLnRvU3RyaW5nKCk7XG4gIH1cblxuICBwcm90ZWN0ZWQgc3RyaW5naWZ5UXVlcnkocXVlcnk6IFJlY29yZDxzdHJpbmcsIHVua25vd24+KTogc3RyaW5nIHtcbiAgICByZXR1cm4gT2JqZWN0LmVudHJpZXMocXVlcnkpXG4gICAgICAuZmlsdGVyKChbXywgdmFsdWVdKSA9PiB0eXBlb2YgdmFsdWUgIT09ICd1bmRlZmluZWQnKVxuICAgICAgLm1hcCgoW2tleSwgdmFsdWVdKSA9PiB7XG4gICAgICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgfHwgdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbicpIHtcbiAgICAgICAgICByZXR1cm4gYCR7ZW5jb2RlVVJJQ29tcG9uZW50KGtleSl9PSR7ZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKX1gO1xuICAgICAgICB9XG4gICAgICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBgJHtlbmNvZGVVUklDb21wb25lbnQoa2V5KX09YDtcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgR3JvcUVycm9yKFxuICAgICAgICAgIGBDYW5ub3Qgc3RyaW5naWZ5IHR5cGUgJHt0eXBlb2YgdmFsdWV9OyBFeHBlY3RlZCBzdHJpbmcsIG51bWJlciwgYm9vbGVhbiwgb3IgbnVsbC4gSWYgeW91IG5lZWQgdG8gcGFzcyBuZXN0ZWQgcXVlcnkgcGFyYW1ldGVycywgeW91IGNhbiBtYW51YWxseSBlbmNvZGUgdGhlbSwgZS5nLiB7IHF1ZXJ5OiB7ICdmb29ba2V5MV0nOiB2YWx1ZTEsICdmb29ba2V5Ml0nOiB2YWx1ZTIgfSB9LCBhbmQgcGxlYXNlIG9wZW4gYSBHaXRIdWIgaXNzdWUgcmVxdWVzdGluZyBiZXR0ZXIgc3VwcG9ydCBmb3IgeW91ciB1c2UgY2FzZS5gLFxuICAgICAgICApO1xuICAgICAgfSlcbiAgICAgIC5qb2luKCcmJyk7XG4gIH1cblxuICBhc3luYyBmZXRjaFdpdGhUaW1lb3V0KFxuICAgIHVybDogUmVxdWVzdEluZm8sXG4gICAgaW5pdDogUmVxdWVzdEluaXQgfCB1bmRlZmluZWQsXG4gICAgbXM6IG51bWJlcixcbiAgICBjb250cm9sbGVyOiBBYm9ydENvbnRyb2xsZXIsXG4gICk6IFByb21pc2U8UmVzcG9uc2U+IHtcbiAgICBjb25zdCB7IHNpZ25hbCwgLi4ub3B0aW9ucyB9ID0gaW5pdCB8fCB7fTtcbiAgICBpZiAoc2lnbmFsKSBzaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCAoKSA9PiBjb250cm9sbGVyLmFib3J0KCkpO1xuXG4gICAgY29uc3QgdGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gY29udHJvbGxlci5hYm9ydCgpLCBtcyk7XG5cbiAgICByZXR1cm4gKFxuICAgICAgdGhpcy5nZXRSZXF1ZXN0Q2xpZW50KClcbiAgICAgICAgLy8gdXNlIHVuZGVmaW5lZCB0aGlzIGJpbmRpbmc7IGZldGNoIGVycm9ycyBpZiBib3VuZCB0byBzb21ldGhpbmcgZWxzZSBpbiBicm93c2VyL2Nsb3VkZmxhcmVcbiAgICAgICAgLmZldGNoLmNhbGwodW5kZWZpbmVkLCB1cmwsIHsgc2lnbmFsOiBjb250cm9sbGVyLnNpZ25hbCBhcyBhbnksIC4uLm9wdGlvbnMgfSlcbiAgICAgICAgLmZpbmFsbHkoKCkgPT4ge1xuICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgfSlcbiAgICApO1xuICB9XG5cbiAgcHJvdGVjdGVkIGdldFJlcXVlc3RDbGllbnQoKTogUmVxdWVzdENsaWVudCB7XG4gICAgcmV0dXJuIHsgZmV0Y2g6IHRoaXMuZmV0Y2ggfTtcbiAgfVxuXG4gIHByaXZhdGUgc2hvdWxkUmV0cnkocmVzcG9uc2U6IFJlc3BvbnNlKTogYm9vbGVhbiB7XG4gICAgLy8gTm90ZSB0aGlzIGlzIG5vdCBhIHN0YW5kYXJkIGhlYWRlci5cbiAgICBjb25zdCBzaG91bGRSZXRyeUhlYWRlciA9IHJlc3BvbnNlLmhlYWRlcnMuZ2V0KCd4LXNob3VsZC1yZXRyeScpO1xuXG4gICAgLy8gSWYgdGhlIHNlcnZlciBleHBsaWNpdGx5IHNheXMgd2hldGhlciBvciBub3QgdG8gcmV0cnksIG9iZXkuXG4gICAgaWYgKHNob3VsZFJldHJ5SGVhZGVyID09PSAndHJ1ZScpIHJldHVybiB0cnVlO1xuICAgIGlmIChzaG91bGRSZXRyeUhlYWRlciA9PT0gJ2ZhbHNlJykgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gUmV0cnkgb24gcmVxdWVzdCB0aW1lb3V0cy5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDgpIHJldHVybiB0cnVlO1xuXG4gICAgLy8gUmV0cnkgb24gbG9jayB0aW1lb3V0cy5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID09PSA0MDkpIHJldHVybiB0cnVlO1xuXG4gICAgLy8gUmV0cnkgb24gcmF0ZSBsaW1pdHMuXG4gICAgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5KSByZXR1cm4gdHJ1ZTtcblxuICAgIC8vIFJldHJ5IGludGVybmFsIGVycm9ycy5cbiAgICBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDUwMCkgcmV0dXJuIHRydWU7XG5cbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBwcml2YXRlIGFzeW5jIHJldHJ5UmVxdWVzdChcbiAgICBvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zLFxuICAgIHJldHJpZXNSZW1haW5pbmc6IG51bWJlcixcbiAgICByZXNwb25zZUhlYWRlcnM/OiBIZWFkZXJzIHwgdW5kZWZpbmVkLFxuICApOiBQcm9taXNlPEFQSVJlc3BvbnNlUHJvcHM+IHtcbiAgICBsZXQgdGltZW91dE1pbGxpczogbnVtYmVyIHwgdW5kZWZpbmVkO1xuXG4gICAgLy8gTm90ZSB0aGUgYHJldHJ5LWFmdGVyLW1zYCBoZWFkZXIgbWF5IG5vdCBiZSBzdGFuZGFyZCwgYnV0IGlzIGEgZ29vZCBpZGVhIGFuZCB3ZSdkIGxpa2UgcHJvYWN0aXZlIHN1cHBvcnQgZm9yIGl0LlxuICAgIGNvbnN0IHJldHJ5QWZ0ZXJNaWxsaXNIZWFkZXIgPSByZXNwb25zZUhlYWRlcnM/LlsncmV0cnktYWZ0ZXItbXMnXTtcbiAgICBpZiAocmV0cnlBZnRlck1pbGxpc0hlYWRlcikge1xuICAgICAgY29uc3QgdGltZW91dE1zID0gcGFyc2VGbG9hdChyZXRyeUFmdGVyTWlsbGlzSGVhZGVyKTtcbiAgICAgIGlmICghTnVtYmVyLmlzTmFOKHRpbWVvdXRNcykpIHtcbiAgICAgICAgdGltZW91dE1pbGxpcyA9IHRpbWVvdXRNcztcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBBYm91dCB0aGUgUmV0cnktQWZ0ZXIgaGVhZGVyOiBodHRwczovL2RldmVsb3Blci5tb3ppbGxhLm9yZy9lbi1VUy9kb2NzL1dlYi9IVFRQL0hlYWRlcnMvUmV0cnktQWZ0ZXJcbiAgICBjb25zdCByZXRyeUFmdGVySGVhZGVyID0gcmVzcG9uc2VIZWFkZXJzPy5bJ3JldHJ5LWFmdGVyJ107XG4gICAgaWYgKHJldHJ5QWZ0ZXJIZWFkZXIgJiYgIXRpbWVvdXRNaWxsaXMpIHtcbiAgICAgIGNvbnN0IHRpbWVvdXRTZWNvbmRzID0gcGFyc2VGbG9hdChyZXRyeUFmdGVySGVhZGVyKTtcbiAgICAgIGlmICghTnVtYmVyLmlzTmFOKHRpbWVvdXRTZWNvbmRzKSkge1xuICAgICAgICB0aW1lb3V0TWlsbGlzID0gdGltZW91dFNlY29uZHMgKiAxMDAwO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGltZW91dE1pbGxpcyA9IERhdGUucGFyc2UocmV0cnlBZnRlckhlYWRlcikgLSBEYXRlLm5vdygpO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIElmIHRoZSBBUEkgYXNrcyB1cyB0byB3YWl0IGEgY2VydGFpbiBhbW91bnQgb2YgdGltZSAoYW5kIGl0J3MgYSByZWFzb25hYmxlIGFtb3VudCksXG4gICAgLy8ganVzdCBkbyB3aGF0IGl0IHNheXMsIGJ1dCBvdGhlcndpc2UgY2FsY3VsYXRlIGEgZGVmYXVsdFxuICAgIGlmICghKHRpbWVvdXRNaWxsaXMgJiYgMCA8PSB0aW1lb3V0TWlsbGlzICYmIHRpbWVvdXRNaWxsaXMgPCA2MCAqIDEwMDApKSB7XG4gICAgICBjb25zdCBtYXhSZXRyaWVzID0gb3B0aW9ucy5tYXhSZXRyaWVzID8/IHRoaXMubWF4UmV0cmllcztcbiAgICAgIHRpbWVvdXRNaWxsaXMgPSB0aGlzLmNhbGN1bGF0ZURlZmF1bHRSZXRyeVRpbWVvdXRNaWxsaXMocmV0cmllc1JlbWFpbmluZywgbWF4UmV0cmllcyk7XG4gICAgfVxuICAgIGF3YWl0IHNsZWVwKHRpbWVvdXRNaWxsaXMpO1xuXG4gICAgcmV0dXJuIHRoaXMubWFrZVJlcXVlc3Qob3B0aW9ucywgcmV0cmllc1JlbWFpbmluZyAtIDEpO1xuICB9XG5cbiAgcHJpdmF0ZSBjYWxjdWxhdGVEZWZhdWx0UmV0cnlUaW1lb3V0TWlsbGlzKHJldHJpZXNSZW1haW5pbmc6IG51bWJlciwgbWF4UmV0cmllczogbnVtYmVyKTogbnVtYmVyIHtcbiAgICBjb25zdCBpbml0aWFsUmV0cnlEZWxheSA9IDAuNTtcbiAgICBjb25zdCBtYXhSZXRyeURlbGF5ID0gOC4wO1xuXG4gICAgY29uc3QgbnVtUmV0cmllcyA9IG1heFJldHJpZXMgLSByZXRyaWVzUmVtYWluaW5nO1xuXG4gICAgLy8gQXBwbHkgZXhwb25lbnRpYWwgYmFja29mZiwgYnV0IG5vdCBtb3JlIHRoYW4gdGhlIG1heC5cbiAgICBjb25zdCBzbGVlcFNlY29uZHMgPSBNYXRoLm1pbihpbml0aWFsUmV0cnlEZWxheSAqIE1hdGgucG93KDIsIG51bVJldHJpZXMpLCBtYXhSZXRyeURlbGF5KTtcblxuICAgIC8vIEFwcGx5IHNvbWUgaml0dGVyLCB0YWtlIHVwIHRvIGF0IG1vc3QgMjUgcGVyY2VudCBvZiB0aGUgcmV0cnkgdGltZS5cbiAgICBjb25zdCBqaXR0ZXIgPSAxIC0gTWF0aC5yYW5kb20oKSAqIDAuMjU7XG5cbiAgICByZXR1cm4gc2xlZXBTZWNvbmRzICogaml0dGVyICogMTAwMDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0VXNlckFnZW50KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIGAke3RoaXMuY29uc3RydWN0b3IubmFtZX0vSlMgJHtWRVJTSU9OfWA7XG4gIH1cbn1cblxuZXhwb3J0IHR5cGUgUGFnZUluZm8gPSB7IHVybDogVVJMIH0gfCB7IHBhcmFtczogUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCBudWxsIH07XG5cbmV4cG9ydCBhYnN0cmFjdCBjbGFzcyBBYnN0cmFjdFBhZ2U8SXRlbT4gaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlPEl0ZW0+IHtcbiAgI2NsaWVudDogQVBJQ2xpZW50O1xuICBwcm90ZWN0ZWQgb3B0aW9uczogRmluYWxSZXF1ZXN0T3B0aW9ucztcblxuICBwcm90ZWN0ZWQgcmVzcG9uc2U6IFJlc3BvbnNlO1xuICBwcm90ZWN0ZWQgYm9keTogdW5rbm93bjtcblxuICBjb25zdHJ1Y3RvcihjbGllbnQ6IEFQSUNsaWVudCwgcmVzcG9uc2U6IFJlc3BvbnNlLCBib2R5OiB1bmtub3duLCBvcHRpb25zOiBGaW5hbFJlcXVlc3RPcHRpb25zKSB7XG4gICAgdGhpcy4jY2xpZW50ID0gY2xpZW50O1xuICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgdGhpcy5yZXNwb25zZSA9IHJlc3BvbnNlO1xuICAgIHRoaXMuYm9keSA9IGJvZHk7XG4gIH1cblxuICAvKipcbiAgICogQGRlcHJlY2F0ZWQgVXNlIG5leHRQYWdlSW5mbyBpbnN0ZWFkXG4gICAqL1xuICBhYnN0cmFjdCBuZXh0UGFnZVBhcmFtcygpOiBQYXJ0aWFsPFJlY29yZDxzdHJpbmcsIHVua25vd24+PiB8IG51bGw7XG4gIGFic3RyYWN0IG5leHRQYWdlSW5mbygpOiBQYWdlSW5mbyB8IG51bGw7XG5cbiAgYWJzdHJhY3QgZ2V0UGFnaW5hdGVkSXRlbXMoKTogSXRlbVtdO1xuXG4gIGhhc05leHRQYWdlKCk6IGJvb2xlYW4ge1xuICAgIGNvbnN0IGl0ZW1zID0gdGhpcy5nZXRQYWdpbmF0ZWRJdGVtcygpO1xuICAgIGlmICghaXRlbXMubGVuZ3RoKSByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRoaXMubmV4dFBhZ2VJbmZvKCkgIT0gbnVsbDtcbiAgfVxuXG4gIGFzeW5jIGdldE5leHRQYWdlKCk6IFByb21pc2U8dGhpcz4ge1xuICAgIGNvbnN0IG5leHRJbmZvID0gdGhpcy5uZXh0UGFnZUluZm8oKTtcbiAgICBpZiAoIW5leHRJbmZvKSB7XG4gICAgICB0aHJvdyBuZXcgR3JvcUVycm9yKFxuICAgICAgICAnTm8gbmV4dCBwYWdlIGV4cGVjdGVkOyBwbGVhc2UgY2hlY2sgYC5oYXNOZXh0UGFnZSgpYCBiZWZvcmUgY2FsbGluZyBgLmdldE5leHRQYWdlKClgLicsXG4gICAgICApO1xuICAgIH1cbiAgICBjb25zdCBuZXh0T3B0aW9ucyA9IHsgLi4udGhpcy5vcHRpb25zIH07XG4gICAgaWYgKCdwYXJhbXMnIGluIG5leHRJbmZvICYmIHR5cGVvZiBuZXh0T3B0aW9ucy5xdWVyeSA9PT0gJ29iamVjdCcpIHtcbiAgICAgIG5leHRPcHRpb25zLnF1ZXJ5ID0geyAuLi5uZXh0T3B0aW9ucy5xdWVyeSwgLi4ubmV4dEluZm8ucGFyYW1zIH07XG4gICAgfSBlbHNlIGlmICgndXJsJyBpbiBuZXh0SW5mbykge1xuICAgICAgY29uc3QgcGFyYW1zID0gWy4uLk9iamVjdC5lbnRyaWVzKG5leHRPcHRpb25zLnF1ZXJ5IHx8IHt9KSwgLi4ubmV4dEluZm8udXJsLnNlYXJjaFBhcmFtcy5lbnRyaWVzKCldO1xuICAgICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgcGFyYW1zKSB7XG4gICAgICAgIG5leHRJbmZvLnVybC5zZWFyY2hQYXJhbXMuc2V0KGtleSwgdmFsdWUgYXMgYW55KTtcbiAgICAgIH1cbiAgICAgIG5leHRPcHRpb25zLnF1ZXJ5ID0gdW5kZWZpbmVkO1xuICAgICAgbmV4dE9wdGlvbnMucGF0aCA9IG5leHRJbmZvLnVybC50b1N0cmluZygpO1xuICAgIH1cbiAgICByZXR1cm4gYXdhaXQgdGhpcy4jY2xpZW50LnJlcXVlc3RBUElMaXN0KHRoaXMuY29uc3RydWN0b3IgYXMgYW55LCBuZXh0T3B0aW9ucyk7XG4gIH1cblxuICBhc3luYyAqaXRlclBhZ2VzKCkge1xuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdGhpcy1hbGlhc1xuICAgIGxldCBwYWdlOiBBYnN0cmFjdFBhZ2U8SXRlbT4gPSB0aGlzO1xuICAgIHlpZWxkIHBhZ2U7XG4gICAgd2hpbGUgKHBhZ2UuaGFzTmV4dFBhZ2UoKSkge1xuICAgICAgcGFnZSA9IGF3YWl0IHBhZ2UuZ2V0TmV4dFBhZ2UoKTtcbiAgICAgIHlpZWxkIHBhZ2U7XG4gICAgfVxuICB9XG5cbiAgYXN5bmMgKltTeW1ib2wuYXN5bmNJdGVyYXRvcl0oKSB7XG4gICAgZm9yIGF3YWl0IChjb25zdCBwYWdlIG9mIHRoaXMuaXRlclBhZ2VzKCkpIHtcbiAgICAgIGZvciAoY29uc3QgaXRlbSBvZiBwYWdlLmdldFBhZ2luYXRlZEl0ZW1zKCkpIHtcbiAgICAgICAgeWllbGQgaXRlbTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBUaGlzIHN1YmNsYXNzIG9mIFByb21pc2Ugd2lsbCByZXNvbHZlIHRvIGFuIGluc3RhbnRpYXRlZCBQYWdlIG9uY2UgdGhlIHJlcXVlc3QgY29tcGxldGVzLlxuICpcbiAqIEl0IGFsc28gaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlIHRvIGFsbG93IGF1dG8tcGFnaW5hdGluZyBpdGVyYXRpb24gb24gYW4gdW5hd2FpdGVkIGxpc3QgY2FsbCwgZWc6XG4gKlxuICogICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGNsaWVudC5pdGVtcy5saXN0KCkpIHtcbiAqICAgICAgY29uc29sZS5sb2coaXRlbSlcbiAqICAgIH1cbiAqL1xuZXhwb3J0IGNsYXNzIFBhZ2VQcm9taXNlPFxuICAgIFBhZ2VDbGFzcyBleHRlbmRzIEFic3RyYWN0UGFnZTxJdGVtPixcbiAgICBJdGVtID0gUmV0dXJuVHlwZTxQYWdlQ2xhc3NbJ2dldFBhZ2luYXRlZEl0ZW1zJ10+W251bWJlcl0sXG4gID5cbiAgZXh0ZW5kcyBBUElQcm9taXNlPFBhZ2VDbGFzcz5cbiAgaW1wbGVtZW50cyBBc3luY0l0ZXJhYmxlPEl0ZW0+XG57XG4gIGNvbnN0cnVjdG9yKFxuICAgIGNsaWVudDogQVBJQ2xpZW50LFxuICAgIHJlcXVlc3Q6IFByb21pc2U8QVBJUmVzcG9uc2VQcm9wcz4sXG4gICAgUGFnZTogbmV3ICguLi5hcmdzOiBDb25zdHJ1Y3RvclBhcmFtZXRlcnM8dHlwZW9mIEFic3RyYWN0UGFnZT4pID0+IFBhZ2VDbGFzcyxcbiAgKSB7XG4gICAgc3VwZXIoXG4gICAgICByZXF1ZXN0LFxuICAgICAgYXN5bmMgKHByb3BzKSA9PiBuZXcgUGFnZShjbGllbnQsIHByb3BzLnJlc3BvbnNlLCBhd2FpdCBkZWZhdWx0UGFyc2VSZXNwb25zZShwcm9wcyksIHByb3BzLm9wdGlvbnMpLFxuICAgICk7XG4gIH1cblxuICAvKipcbiAgICogQWxsb3cgYXV0by1wYWdpbmF0aW5nIGl0ZXJhdGlvbiBvbiBhbiB1bmF3YWl0ZWQgbGlzdCBjYWxsLCBlZzpcbiAgICpcbiAgICogICAgZm9yIGF3YWl0IChjb25zdCBpdGVtIG9mIGNsaWVudC5pdGVtcy5saXN0KCkpIHtcbiAgICogICAgICBjb25zb2xlLmxvZyhpdGVtKVxuICAgKiAgICB9XG4gICAqL1xuICBhc3luYyAqW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSgpIHtcbiAgICBjb25zdCBwYWdlID0gYXdhaXQgdGhpcztcbiAgICBmb3IgYXdhaXQgKGNvbnN0IGl0ZW0gb2YgcGFnZSkge1xuICAgICAgeWllbGQgaXRlbTtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGNvbnN0IGNyZWF0ZVJlc3BvbnNlSGVhZGVycyA9IChcbiAgaGVhZGVyczogQXdhaXRlZDxSZXR1cm5UeXBlPEZldGNoPj5bJ2hlYWRlcnMnXSxcbik6IFJlY29yZDxzdHJpbmcsIHN0cmluZz4gPT4ge1xuICByZXR1cm4gbmV3IFByb3h5KFxuICAgIE9iamVjdC5mcm9tRW50cmllcyhcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGhlYWRlcnMuZW50cmllcygpLFxuICAgICksXG4gICAge1xuICAgICAgZ2V0KHRhcmdldCwgbmFtZSkge1xuICAgICAgICBjb25zdCBrZXkgPSBuYW1lLnRvU3RyaW5nKCk7XG4gICAgICAgIHJldHVybiB0YXJnZXRba2V5LnRvTG93ZXJDYXNlKCldIHx8IHRhcmdldFtrZXldO1xuICAgICAgfSxcbiAgICB9LFxuICApO1xufTtcblxudHlwZSBIVFRQTWV0aG9kID0gJ2dldCcgfCAncG9zdCcgfCAncHV0JyB8ICdwYXRjaCcgfCAnZGVsZXRlJztcblxuZXhwb3J0IHR5cGUgUmVxdWVzdENsaWVudCA9IHsgZmV0Y2g6IEZldGNoIH07XG5leHBvcnQgdHlwZSBIZWFkZXJzID0gUmVjb3JkPHN0cmluZywgc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZD47XG5leHBvcnQgdHlwZSBEZWZhdWx0UXVlcnkgPSBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCB1bmRlZmluZWQ+O1xuZXhwb3J0IHR5cGUgS2V5c0VudW08VD4gPSB7IFtQIGluIGtleW9mIFJlcXVpcmVkPFQ+XTogdHJ1ZSB9O1xuXG5leHBvcnQgdHlwZSBSZXF1ZXN0T3B0aW9uczxSZXEgPSB1bmtub3duIHwgUmVjb3JkPHN0cmluZywgdW5rbm93bj4gfCBSZWFkYWJsZT4gPSB7XG4gIG1ldGhvZD86IEhUVFBNZXRob2Q7XG4gIHBhdGg/OiBzdHJpbmc7XG4gIHF1ZXJ5PzogUmVxIHwgdW5kZWZpbmVkO1xuICBib2R5PzogUmVxIHwgbnVsbCB8IHVuZGVmaW5lZDtcbiAgaGVhZGVycz86IEhlYWRlcnMgfCB1bmRlZmluZWQ7XG5cbiAgbWF4UmV0cmllcz86IG51bWJlcjtcbiAgc3RyZWFtPzogYm9vbGVhbiB8IHVuZGVmaW5lZDtcbiAgdGltZW91dD86IG51bWJlcjtcbiAgaHR0cEFnZW50PzogQWdlbnQ7XG4gIHNpZ25hbD86IEFib3J0U2lnbmFsIHwgdW5kZWZpbmVkIHwgbnVsbDtcbiAgaWRlbXBvdGVuY3lLZXk/OiBzdHJpbmc7XG5cbiAgX19iaW5hcnlSZXNwb25zZT86IGJvb2xlYW4gfCB1bmRlZmluZWQ7XG4gIF9fc3RyZWFtQ2xhc3M/OiB0eXBlb2YgU3RyZWFtO1xufTtcblxuLy8gVGhpcyBpcyByZXF1aXJlZCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgaWYgYSBnaXZlbiBvYmplY3QgbWF0Y2hlcyB0aGUgUmVxdWVzdE9wdGlvbnNcbi8vIHR5cGUgYXQgcnVudGltZS4gV2hpbGUgdGhpcyByZXF1aXJlcyBkdXBsaWNhdGlvbiwgaXQgaXMgZW5mb3JjZWQgYnkgdGhlIFR5cGVTY3JpcHRcbi8vIGNvbXBpbGVyIHN1Y2ggdGhhdCBhbnkgbWlzc2luZyAvIGV4dHJhbmVvdXMga2V5cyB3aWxsIGNhdXNlIGFuIGVycm9yLlxuY29uc3QgcmVxdWVzdE9wdGlvbnNLZXlzOiBLZXlzRW51bTxSZXF1ZXN0T3B0aW9ucz4gPSB7XG4gIG1ldGhvZDogdHJ1ZSxcbiAgcGF0aDogdHJ1ZSxcbiAgcXVlcnk6IHRydWUsXG4gIGJvZHk6IHRydWUsXG4gIGhlYWRlcnM6IHRydWUsXG5cbiAgbWF4UmV0cmllczogdHJ1ZSxcbiAgc3RyZWFtOiB0cnVlLFxuICB0aW1lb3V0OiB0cnVlLFxuICBodHRwQWdlbnQ6IHRydWUsXG4gIHNpZ25hbDogdHJ1ZSxcbiAgaWRlbXBvdGVuY3lLZXk6IHRydWUsXG5cbiAgX19iaW5hcnlSZXNwb25zZTogdHJ1ZSxcbiAgX19zdHJlYW1DbGFzczogdHJ1ZSxcbn07XG5cbmV4cG9ydCBjb25zdCBpc1JlcXVlc3RPcHRpb25zID0gKG9iajogdW5rbm93bik6IG9iaiBpcyBSZXF1ZXN0T3B0aW9ucyA9PiB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiZcbiAgICBvYmogIT09IG51bGwgJiZcbiAgICAhaXNFbXB0eU9iaihvYmopICYmXG4gICAgT2JqZWN0LmtleXMob2JqKS5ldmVyeSgoaykgPT4gaGFzT3duKHJlcXVlc3RPcHRpb25zS2V5cywgaykpXG4gICk7XG59O1xuXG5leHBvcnQgdHlwZSBGaW5hbFJlcXVlc3RPcHRpb25zPFJlcSA9IHVua25vd24gfCBSZWNvcmQ8c3RyaW5nLCB1bmtub3duPiB8IFJlYWRhYmxlPiA9IFJlcXVlc3RPcHRpb25zPFJlcT4gJiB7XG4gIG1ldGhvZDogSFRUUE1ldGhvZDtcbiAgcGF0aDogc3RyaW5nO1xufTtcblxuZGVjbGFyZSBjb25zdCBEZW5vOiBhbnk7XG5kZWNsYXJlIGNvbnN0IEVkZ2VSdW50aW1lOiBhbnk7XG50eXBlIEFyY2ggPSAneDMyJyB8ICd4NjQnIHwgJ2FybScgfCAnYXJtNjQnIHwgYG90aGVyOiR7c3RyaW5nfWAgfCAndW5rbm93bic7XG50eXBlIFBsYXRmb3JtTmFtZSA9XG4gIHwgJ01hY09TJ1xuICB8ICdMaW51eCdcbiAgfCAnV2luZG93cydcbiAgfCAnRnJlZUJTRCdcbiAgfCAnT3BlbkJTRCdcbiAgfCAnaU9TJ1xuICB8ICdBbmRyb2lkJ1xuICB8IGBPdGhlcjoke3N0cmluZ31gXG4gIHwgJ1Vua25vd24nO1xudHlwZSBCcm93c2VyID0gJ2llJyB8ICdlZGdlJyB8ICdjaHJvbWUnIHwgJ2ZpcmVmb3gnIHwgJ3NhZmFyaSc7XG50eXBlIFBsYXRmb3JtUHJvcGVydGllcyA9IHtcbiAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnO1xuICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogc3RyaW5nO1xuICAnWC1TdGFpbmxlc3MtT1MnOiBQbGF0Zm9ybU5hbWU7XG4gICdYLVN0YWlubGVzcy1BcmNoJzogQXJjaDtcbiAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUnOiAnbm9kZScgfCAnZGVubycgfCAnZWRnZScgfCBgYnJvd3Nlcjoke0Jyb3dzZXJ9YCB8ICd1bmtub3duJztcbiAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUtVmVyc2lvbic6IHN0cmluZztcbn07XG5jb25zdCBnZXRQbGF0Zm9ybVByb3BlcnRpZXMgPSAoKTogUGxhdGZvcm1Qcm9wZXJ0aWVzID0+IHtcbiAgaWYgKHR5cGVvZiBEZW5vICE9PSAndW5kZWZpbmVkJyAmJiBEZW5vLmJ1aWxkICE9IG51bGwpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnLFxuICAgICAgJ1gtU3RhaW5sZXNzLVBhY2thZ2UtVmVyc2lvbic6IFZFUlNJT04sXG4gICAgICAnWC1TdGFpbmxlc3MtT1MnOiBub3JtYWxpemVQbGF0Zm9ybShEZW5vLmJ1aWxkLm9zKSxcbiAgICAgICdYLVN0YWlubGVzcy1BcmNoJzogbm9ybWFsaXplQXJjaChEZW5vLmJ1aWxkLmFyY2gpLFxuICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUnOiAnZGVubycsXG4gICAgICAnWC1TdGFpbmxlc3MtUnVudGltZS1WZXJzaW9uJzogRGVuby52ZXJzaW9uLFxuICAgIH07XG4gIH1cbiAgaWYgKHR5cGVvZiBFZGdlUnVudGltZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnLFxuICAgICAgJ1gtU3RhaW5sZXNzLVBhY2thZ2UtVmVyc2lvbic6IFZFUlNJT04sXG4gICAgICAnWC1TdGFpbmxlc3MtT1MnOiAnVW5rbm93bicsXG4gICAgICAnWC1TdGFpbmxlc3MtQXJjaCc6IGBvdGhlcjoke0VkZ2VSdW50aW1lfWAsXG4gICAgICAnWC1TdGFpbmxlc3MtUnVudGltZSc6ICdlZGdlJyxcbiAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiBwcm9jZXNzLnZlcnNpb24sXG4gICAgfTtcbiAgfVxuICAvLyBDaGVjayBpZiBOb2RlLmpzXG4gIGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnID8gcHJvY2VzcyA6IDApID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcbiAgICByZXR1cm4ge1xuICAgICAgJ1gtU3RhaW5sZXNzLUxhbmcnOiAnanMnLFxuICAgICAgJ1gtU3RhaW5sZXNzLVBhY2thZ2UtVmVyc2lvbic6IFZFUlNJT04sXG4gICAgICAnWC1TdGFpbmxlc3MtT1MnOiBub3JtYWxpemVQbGF0Zm9ybShwcm9jZXNzLnBsYXRmb3JtKSxcbiAgICAgICdYLVN0YWlubGVzcy1BcmNoJzogbm9ybWFsaXplQXJjaChwcm9jZXNzLmFyY2gpLFxuICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUnOiAnbm9kZScsXG4gICAgICAnWC1TdGFpbmxlc3MtUnVudGltZS1WZXJzaW9uJzogcHJvY2Vzcy52ZXJzaW9uLFxuICAgIH07XG4gIH1cblxuICBjb25zdCBicm93c2VySW5mbyA9IGdldEJyb3dzZXJJbmZvKCk7XG4gIGlmIChicm93c2VySW5mbykge1xuICAgIHJldHVybiB7XG4gICAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgICAnWC1TdGFpbmxlc3MtUGFja2FnZS1WZXJzaW9uJzogVkVSU0lPTixcbiAgICAgICdYLVN0YWlubGVzcy1PUyc6ICdVbmtub3duJyxcbiAgICAgICdYLVN0YWlubGVzcy1BcmNoJzogJ3Vua25vd24nLFxuICAgICAgJ1gtU3RhaW5sZXNzLVJ1bnRpbWUnOiBgYnJvd3Nlcjoke2Jyb3dzZXJJbmZvLmJyb3dzZXJ9YCxcbiAgICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiBicm93c2VySW5mby52ZXJzaW9uLFxuICAgIH07XG4gIH1cblxuICAvLyBUT0RPIGFkZCBzdXBwb3J0IGZvciBDbG91ZGZsYXJlIHdvcmtlcnMsIGV0Yy5cbiAgcmV0dXJuIHtcbiAgICAnWC1TdGFpbmxlc3MtTGFuZyc6ICdqcycsXG4gICAgJ1gtU3RhaW5sZXNzLVBhY2thZ2UtVmVyc2lvbic6IFZFUlNJT04sXG4gICAgJ1gtU3RhaW5sZXNzLU9TJzogJ1Vua25vd24nLFxuICAgICdYLVN0YWlubGVzcy1BcmNoJzogJ3Vua25vd24nLFxuICAgICdYLVN0YWlubGVzcy1SdW50aW1lJzogJ3Vua25vd24nLFxuICAgICdYLVN0YWlubGVzcy1SdW50aW1lLVZlcnNpb24nOiAndW5rbm93bicsXG4gIH07XG59O1xuXG50eXBlIEJyb3dzZXJJbmZvID0ge1xuICBicm93c2VyOiBCcm93c2VyO1xuICB2ZXJzaW9uOiBzdHJpbmc7XG59O1xuXG5kZWNsYXJlIGNvbnN0IG5hdmlnYXRvcjogeyB1c2VyQWdlbnQ6IHN0cmluZyB9IHwgdW5kZWZpbmVkO1xuXG4vLyBOb3RlOiBtb2RpZmllZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9KUy1EZXZUb29scy9ob3N0LWVudmlyb25tZW50L2Jsb2IvYjFhYjc5ZWNkZTM3ZGI1ZDZlMTYzYzA1MGU1NGZlN2QyODdkN2M5Mi9zcmMvaXNvbW9ycGhpYy5icm93c2VyLnRzXG5mdW5jdGlvbiBnZXRCcm93c2VySW5mbygpOiBCcm93c2VySW5mbyB8IG51bGwge1xuICBpZiAodHlwZW9mIG5hdmlnYXRvciA9PT0gJ3VuZGVmaW5lZCcgfHwgIW5hdmlnYXRvcikge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgLy8gTk9URTogVGhlIG9yZGVyIG1hdHRlcnMgaGVyZSFcbiAgY29uc3QgYnJvd3NlclBhdHRlcm5zID0gW1xuICAgIHsga2V5OiAnZWRnZScgYXMgY29uc3QsIHBhdHRlcm46IC9FZGdlKD86XFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgeyBrZXk6ICdpZScgYXMgY29uc3QsIHBhdHRlcm46IC9NU0lFKD86XFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgeyBrZXk6ICdpZScgYXMgY29uc3QsIHBhdHRlcm46IC9UcmlkZW50KD86LipydlxcOihcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgeyBrZXk6ICdjaHJvbWUnIGFzIGNvbnN0LCBwYXR0ZXJuOiAvQ2hyb21lKD86XFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8vIH0sXG4gICAgeyBrZXk6ICdmaXJlZm94JyBhcyBjb25zdCwgcGF0dGVybjogL0ZpcmVmb3goPzpcXFcrKFxcZCspXFwuKFxcZCspKD86XFwuKFxcZCspKT8pPy8gfSxcbiAgICB7IGtleTogJ3NhZmFyaScgYXMgY29uc3QsIHBhdHRlcm46IC8oPzpWZXJzaW9uXFxXKyhcXGQrKVxcLihcXGQrKSg/OlxcLihcXGQrKSk/KT8oPzpcXFcrTW9iaWxlXFxTKik/XFxXK1NhZmFyaS8gfSxcbiAgXTtcblxuICAvLyBGaW5kIHRoZSBGSVJTVCBtYXRjaGluZyBicm93c2VyXG4gIGZvciAoY29uc3QgeyBrZXksIHBhdHRlcm4gfSBvZiBicm93c2VyUGF0dGVybnMpIHtcbiAgICBjb25zdCBtYXRjaCA9IHBhdHRlcm4uZXhlYyhuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICBpZiAobWF0Y2gpIHtcbiAgICAgIGNvbnN0IG1ham9yID0gbWF0Y2hbMV0gfHwgMDtcbiAgICAgIGNvbnN0IG1pbm9yID0gbWF0Y2hbMl0gfHwgMDtcbiAgICAgIGNvbnN0IHBhdGNoID0gbWF0Y2hbM10gfHwgMDtcblxuICAgICAgcmV0dXJuIHsgYnJvd3Nlcjoga2V5LCB2ZXJzaW9uOiBgJHttYWpvcn0uJHttaW5vcn0uJHtwYXRjaH1gIH07XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbmNvbnN0IG5vcm1hbGl6ZUFyY2ggPSAoYXJjaDogc3RyaW5nKTogQXJjaCA9PiB7XG4gIC8vIE5vZGUgZG9jczpcbiAgLy8gLSBodHRwczovL25vZGVqcy5vcmcvYXBpL3Byb2Nlc3MuaHRtbCNwcm9jZXNzYXJjaFxuICAvLyBEZW5vIGRvY3M6XG4gIC8vIC0gaHR0cHM6Ly9kb2MuZGVuby5sYW5kL2Rlbm8vc3RhYmxlL34vRGVuby5idWlsZFxuICBpZiAoYXJjaCA9PT0gJ3gzMicpIHJldHVybiAneDMyJztcbiAgaWYgKGFyY2ggPT09ICd4ODZfNjQnIHx8IGFyY2ggPT09ICd4NjQnKSByZXR1cm4gJ3g2NCc7XG4gIGlmIChhcmNoID09PSAnYXJtJykgcmV0dXJuICdhcm0nO1xuICBpZiAoYXJjaCA9PT0gJ2FhcmNoNjQnIHx8IGFyY2ggPT09ICdhcm02NCcpIHJldHVybiAnYXJtNjQnO1xuICBpZiAoYXJjaCkgcmV0dXJuIGBvdGhlcjoke2FyY2h9YDtcbiAgcmV0dXJuICd1bmtub3duJztcbn07XG5cbmNvbnN0IG5vcm1hbGl6ZVBsYXRmb3JtID0gKHBsYXRmb3JtOiBzdHJpbmcpOiBQbGF0Zm9ybU5hbWUgPT4ge1xuICAvLyBOb2RlIHBsYXRmb3JtczpcbiAgLy8gLSBodHRwczovL25vZGVqcy5vcmcvYXBpL3Byb2Nlc3MuaHRtbCNwcm9jZXNzcGxhdGZvcm1cbiAgLy8gRGVubyBwbGF0Zm9ybXM6XG4gIC8vIC0gaHR0cHM6Ly9kb2MuZGVuby5sYW5kL2Rlbm8vc3RhYmxlL34vRGVuby5idWlsZFxuICAvLyAtIGh0dHBzOi8vZ2l0aHViLmNvbS9kZW5vbGFuZC9kZW5vL2lzc3Vlcy8xNDc5OVxuXG4gIHBsYXRmb3JtID0gcGxhdGZvcm0udG9Mb3dlckNhc2UoKTtcblxuICAvLyBOT1RFOiB0aGlzIGlPUyBjaGVjayBpcyB1bnRlc3RlZCBhbmQgbWF5IG5vdCB3b3JrXG4gIC8vIE5vZGUgZG9lcyBub3Qgd29yayBuYXRpdmVseSBvbiBJT1MsIHRoZXJlIGlzIGEgZm9yayBhdFxuICAvLyBodHRwczovL2dpdGh1Yi5jb20vbm9kZWpzLW1vYmlsZS9ub2RlanMtbW9iaWxlXG4gIC8vIGhvd2V2ZXIgaXQgaXMgdW5rbm93biBhdCB0aGUgdGltZSBvZiB3cml0aW5nIGhvdyB0byBkZXRlY3QgaWYgaXQgaXMgcnVubmluZ1xuICBpZiAocGxhdGZvcm0uaW5jbHVkZXMoJ2lvcycpKSByZXR1cm4gJ2lPUyc7XG4gIGlmIChwbGF0Zm9ybSA9PT0gJ2FuZHJvaWQnKSByZXR1cm4gJ0FuZHJvaWQnO1xuICBpZiAocGxhdGZvcm0gPT09ICdkYXJ3aW4nKSByZXR1cm4gJ01hY09TJztcbiAgaWYgKHBsYXRmb3JtID09PSAnd2luMzInKSByZXR1cm4gJ1dpbmRvd3MnO1xuICBpZiAocGxhdGZvcm0gPT09ICdmcmVlYnNkJykgcmV0dXJuICdGcmVlQlNEJztcbiAgaWYgKHBsYXRmb3JtID09PSAnb3BlbmJzZCcpIHJldHVybiAnT3BlbkJTRCc7XG4gIGlmIChwbGF0Zm9ybSA9PT0gJ2xpbnV4JykgcmV0dXJuICdMaW51eCc7XG4gIGlmIChwbGF0Zm9ybSkgcmV0dXJuIGBPdGhlcjoke3BsYXRmb3JtfWA7XG4gIHJldHVybiAnVW5rbm93bic7XG59O1xuXG5sZXQgX3BsYXRmb3JtSGVhZGVyczogUGxhdGZvcm1Qcm9wZXJ0aWVzO1xuY29uc3QgZ2V0UGxhdGZvcm1IZWFkZXJzID0gKCkgPT4ge1xuICByZXR1cm4gKF9wbGF0Zm9ybUhlYWRlcnMgPz89IGdldFBsYXRmb3JtUHJvcGVydGllcygpKTtcbn07XG5cbmV4cG9ydCBjb25zdCBzYWZlSlNPTiA9ICh0ZXh0OiBzdHJpbmcpID0+IHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gSlNPTi5wYXJzZSh0ZXh0KTtcbiAgfSBjYXRjaCAoZXJyKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgfVxufTtcblxuLy8gaHR0cHM6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE5NzA5ODQ2XG5jb25zdCBzdGFydHNXaXRoU2NoZW1lUmVnZXhwID0gbmV3IFJlZ0V4cCgnXig/OlthLXpdKzopPy8vJywgJ2knKTtcbmNvbnN0IGlzQWJzb2x1dGVVUkwgPSAodXJsOiBzdHJpbmcpOiBib29sZWFuID0+IHtcbiAgcmV0dXJuIHN0YXJ0c1dpdGhTY2hlbWVSZWdleHAudGVzdCh1cmwpO1xufTtcblxuZXhwb3J0IGNvbnN0IHNsZWVwID0gKG1zOiBudW1iZXIpID0+IG5ldyBQcm9taXNlKChyZXNvbHZlKSA9PiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKSk7XG5cbmNvbnN0IHZhbGlkYXRlUG9zaXRpdmVJbnRlZ2VyID0gKG5hbWU6IHN0cmluZywgbjogdW5rbm93bik6IG51bWJlciA9PiB7XG4gIGlmICh0eXBlb2YgbiAhPT0gJ251bWJlcicgfHwgIU51bWJlci5pc0ludGVnZXIobikpIHtcbiAgICB0aHJvdyBuZXcgR3JvcUVycm9yKGAke25hbWV9IG11c3QgYmUgYW4gaW50ZWdlcmApO1xuICB9XG4gIGlmIChuIDwgMCkge1xuICAgIHRocm93IG5ldyBHcm9xRXJyb3IoYCR7bmFtZX0gbXVzdCBiZSBhIHBvc2l0aXZlIGludGVnZXJgKTtcbiAgfVxuICByZXR1cm4gbjtcbn07XG5cbmV4cG9ydCBjb25zdCBjYXN0VG9FcnJvciA9IChlcnI6IGFueSk6IEVycm9yID0+IHtcbiAgaWYgKGVyciBpbnN0YW5jZW9mIEVycm9yKSByZXR1cm4gZXJyO1xuICByZXR1cm4gbmV3IEVycm9yKGVycik7XG59O1xuXG5leHBvcnQgY29uc3QgZW5zdXJlUHJlc2VudCA9IDxUPih2YWx1ZTogVCB8IG51bGwgfCB1bmRlZmluZWQpOiBUID0+IHtcbiAgaWYgKHZhbHVlID09IG51bGwpIHRocm93IG5ldyBHcm9xRXJyb3IoYEV4cGVjdGVkIGEgdmFsdWUgdG8gYmUgZ2l2ZW4gYnV0IHJlY2VpdmVkICR7dmFsdWV9IGluc3RlYWQuYCk7XG4gIHJldHVybiB2YWx1ZTtcbn07XG5cbi8qKlxuICogUmVhZCBhbiBlbnZpcm9ubWVudCB2YXJpYWJsZS5cbiAqXG4gKiBUcmltcyBiZWdpbm5pbmcgYW5kIHRyYWlsaW5nIHdoaXRlc3BhY2UuXG4gKlxuICogV2lsbCByZXR1cm4gdW5kZWZpbmVkIGlmIHRoZSBlbnZpcm9ubWVudCB2YXJpYWJsZSBkb2Vzbid0IGV4aXN0IG9yIGNhbm5vdCBiZSBhY2Nlc3NlZC5cbiAqL1xuZXhwb3J0IGNvbnN0IHJlYWRFbnYgPSAoZW52OiBzdHJpbmcpOiBzdHJpbmcgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIHByb2Nlc3MuZW52Py5bZW52XT8udHJpbSgpID8/IHVuZGVmaW5lZDtcbiAgfVxuICBpZiAodHlwZW9mIERlbm8gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIERlbm8uZW52Py5nZXQ/LihlbnYpPy50cmltKCk7XG4gIH1cbiAgcmV0dXJuIHVuZGVmaW5lZDtcbn07XG5cbmV4cG9ydCBjb25zdCBjb2VyY2VJbnRlZ2VyID0gKHZhbHVlOiB1bmtub3duKTogbnVtYmVyID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiBNYXRoLnJvdW5kKHZhbHVlKTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHJldHVybiBwYXJzZUludCh2YWx1ZSwgMTApO1xuXG4gIHRocm93IG5ldyBHcm9xRXJyb3IoYENvdWxkIG5vdCBjb2VyY2UgJHt2YWx1ZX0gKHR5cGU6ICR7dHlwZW9mIHZhbHVlfSkgaW50byBhIG51bWJlcmApO1xufTtcblxuZXhwb3J0IGNvbnN0IGNvZXJjZUZsb2F0ID0gKHZhbHVlOiB1bmtub3duKTogbnVtYmVyID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHJldHVybiB2YWx1ZTtcbiAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHJldHVybiBwYXJzZUZsb2F0KHZhbHVlKTtcblxuICB0aHJvdyBuZXcgR3JvcUVycm9yKGBDb3VsZCBub3QgY29lcmNlICR7dmFsdWV9ICh0eXBlOiAke3R5cGVvZiB2YWx1ZX0pIGludG8gYSBudW1iZXJgKTtcbn07XG5cbmV4cG9ydCBjb25zdCBjb2VyY2VCb29sZWFuID0gKHZhbHVlOiB1bmtub3duKTogYm9vbGVhbiA9PiB7XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdib29sZWFuJykgcmV0dXJuIHZhbHVlO1xuICBpZiAodHlwZW9mIHZhbHVlID09PSAnc3RyaW5nJykgcmV0dXJuIHZhbHVlID09PSAndHJ1ZSc7XG4gIHJldHVybiBCb29sZWFuKHZhbHVlKTtcbn07XG5cbmV4cG9ydCBjb25zdCBtYXliZUNvZXJjZUludGVnZXIgPSAodmFsdWU6IHVua25vd24pOiBudW1iZXIgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGNvZXJjZUludGVnZXIodmFsdWUpO1xufTtcblxuZXhwb3J0IGNvbnN0IG1heWJlQ29lcmNlRmxvYXQgPSAodmFsdWU6IHVua25vd24pOiBudW1iZXIgfCB1bmRlZmluZWQgPT4ge1xuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiB1bmRlZmluZWQ7XG4gIH1cbiAgcmV0dXJuIGNvZXJjZUZsb2F0KHZhbHVlKTtcbn07XG5cbmV4cG9ydCBjb25zdCBtYXliZUNvZXJjZUJvb2xlYW4gPSAodmFsdWU6IHVua25vd24pOiBib29sZWFuIHwgdW5kZWZpbmVkID0+IHtcbiAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICByZXR1cm4gdW5kZWZpbmVkO1xuICB9XG4gIHJldHVybiBjb2VyY2VCb29sZWFuKHZhbHVlKTtcbn07XG5cbi8vIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8zNDQ5MTI4N1xuZXhwb3J0IGZ1bmN0aW9uIGlzRW1wdHlPYmoob2JqOiBPYmplY3QgfCBudWxsIHwgdW5kZWZpbmVkKTogYm9vbGVhbiB7XG4gIGlmICghb2JqKSByZXR1cm4gdHJ1ZTtcbiAgZm9yIChjb25zdCBfayBpbiBvYmopIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbi8vIGh0dHBzOi8vZXNsaW50Lm9yZy9kb2NzL2xhdGVzdC9ydWxlcy9uby1wcm90b3R5cGUtYnVpbHRpbnNcbmV4cG9ydCBmdW5jdGlvbiBoYXNPd24ob2JqOiBPYmplY3QsIGtleTogc3RyaW5nKTogYm9vbGVhbiB7XG4gIHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqLCBrZXkpO1xufVxuXG4vKipcbiAqIENvcGllcyBoZWFkZXJzIGZyb20gXCJuZXdIZWFkZXJzXCIgb250byBcInRhcmdldEhlYWRlcnNcIixcbiAqIHVzaW5nIGxvd2VyLWNhc2UgZm9yIGFsbCBwcm9wZXJ0aWVzLFxuICogaWdub3JpbmcgYW55IGtleXMgd2l0aCB1bmRlZmluZWQgdmFsdWVzLFxuICogYW5kIGRlbGV0aW5nIGFueSBrZXlzIHdpdGggbnVsbCB2YWx1ZXMuXG4gKi9cbmZ1bmN0aW9uIGFwcGx5SGVhZGVyc011dCh0YXJnZXRIZWFkZXJzOiBIZWFkZXJzLCBuZXdIZWFkZXJzOiBIZWFkZXJzKTogdm9pZCB7XG4gIGZvciAoY29uc3QgayBpbiBuZXdIZWFkZXJzKSB7XG4gICAgaWYgKCFoYXNPd24obmV3SGVhZGVycywgaykpIGNvbnRpbnVlO1xuICAgIGNvbnN0IGxvd2VyS2V5ID0gay50b0xvd2VyQ2FzZSgpO1xuICAgIGlmICghbG93ZXJLZXkpIGNvbnRpbnVlO1xuXG4gICAgY29uc3QgdmFsID0gbmV3SGVhZGVyc1trXTtcblxuICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgIGRlbGV0ZSB0YXJnZXRIZWFkZXJzW2xvd2VyS2V5XTtcbiAgICB9IGVsc2UgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICB0YXJnZXRIZWFkZXJzW2xvd2VyS2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRlYnVnKGFjdGlvbjogc3RyaW5nLCAuLi5hcmdzOiBhbnlbXSkge1xuICBpZiAodHlwZW9mIHByb2Nlc3MgIT09ICd1bmRlZmluZWQnICYmIHByb2Nlc3MuZW52WydERUJVRyddID09PSAndHJ1ZScpIHtcbiAgICBjb25zb2xlLmxvZyhgR3JvcTpERUJVRzoke2FjdGlvbn1gLCAuLi5hcmdzKTtcbiAgfVxufVxuXG4vKipcbiAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yMTE3NTIzXG4gKi9cbmNvbnN0IHV1aWQ0ID0gKCkgPT4ge1xuICByZXR1cm4gJ3h4eHh4eHh4LXh4eHgtNHh4eC15eHh4LXh4eHh4eHh4eHh4eCcucmVwbGFjZSgvW3h5XS9nLCAoYykgPT4ge1xuICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2KSB8IDA7XG4gICAgY29uc3QgdiA9IGMgPT09ICd4JyA/IHIgOiAociAmIDB4MykgfCAweDg7XG4gICAgcmV0dXJuIHYudG9TdHJpbmcoMTYpO1xuICB9KTtcbn07XG5cbmV4cG9ydCBjb25zdCBpc1J1bm5pbmdJbkJyb3dzZXIgPSAoKSA9PiB7XG4gIHJldHVybiAoXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHR5cGVvZiB3aW5kb3cuZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgLy8gQHRzLWlnbm9yZVxuICAgIHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnXG4gICk7XG59O1xuXG5leHBvcnQgaW50ZXJmYWNlIEhlYWRlcnNQcm90b2NvbCB7XG4gIGdldDogKGhlYWRlcjogc3RyaW5nKSA9PiBzdHJpbmcgfCBudWxsIHwgdW5kZWZpbmVkO1xufVxuZXhwb3J0IHR5cGUgSGVhZGVyc0xpa2UgPSBSZWNvcmQ8c3RyaW5nLCBzdHJpbmcgfCBzdHJpbmdbXSB8IHVuZGVmaW5lZD4gfCBIZWFkZXJzUHJvdG9jb2w7XG5cbmV4cG9ydCBjb25zdCBpc0hlYWRlcnNQcm90b2NvbCA9IChoZWFkZXJzOiBhbnkpOiBoZWFkZXJzIGlzIEhlYWRlcnNQcm90b2NvbCA9PiB7XG4gIHJldHVybiB0eXBlb2YgaGVhZGVycz8uZ2V0ID09PSAnZnVuY3Rpb24nO1xufTtcblxuZXhwb3J0IGNvbnN0IGdldFJlcXVpcmVkSGVhZGVyID0gKGhlYWRlcnM6IEhlYWRlcnNMaWtlLCBoZWFkZXI6IHN0cmluZyk6IHN0cmluZyA9PiB7XG4gIGNvbnN0IGxvd2VyQ2FzZWRIZWFkZXIgPSBoZWFkZXIudG9Mb3dlckNhc2UoKTtcbiAgaWYgKGlzSGVhZGVyc1Byb3RvY29sKGhlYWRlcnMpKSB7XG4gICAgLy8gdG8gZGVhbCB3aXRoIHRoZSBjYXNlIHdoZXJlIHRoZSBoZWFkZXIgbG9va3MgbGlrZSBTdGFpbmxlc3MtRXZlbnQtSWRcbiAgICBjb25zdCBpbnRlcmNhcHNIZWFkZXIgPVxuICAgICAgaGVhZGVyWzBdPy50b1VwcGVyQ2FzZSgpICtcbiAgICAgIGhlYWRlci5zdWJzdHJpbmcoMSkucmVwbGFjZSgvKFteXFx3XSkoXFx3KS9nLCAoX20sIGcxLCBnMikgPT4gZzEgKyBnMi50b1VwcGVyQ2FzZSgpKTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBbaGVhZGVyLCBsb3dlckNhc2VkSGVhZGVyLCBoZWFkZXIudG9VcHBlckNhc2UoKSwgaW50ZXJjYXBzSGVhZGVyXSkge1xuICAgICAgY29uc3QgdmFsdWUgPSBoZWFkZXJzLmdldChrZXkpO1xuICAgICAgaWYgKHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBPYmplY3QuZW50cmllcyhoZWFkZXJzKSkge1xuICAgIGlmIChrZXkudG9Mb3dlckNhc2UoKSA9PT0gbG93ZXJDYXNlZEhlYWRlcikge1xuICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgIGlmICh2YWx1ZS5sZW5ndGggPD0gMSkgcmV0dXJuIHZhbHVlWzBdO1xuICAgICAgICBjb25zb2xlLndhcm4oYFJlY2VpdmVkICR7dmFsdWUubGVuZ3RofSBlbnRyaWVzIGZvciB0aGUgJHtoZWFkZXJ9IGhlYWRlciwgdXNpbmcgdGhlIGZpcnN0IGVudHJ5LmApO1xuICAgICAgICByZXR1cm4gdmFsdWVbMF07XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWU7XG4gICAgfVxuICB9XG5cbiAgdGhyb3cgbmV3IEVycm9yKGBDb3VsZCBub3QgZmluZCAke2hlYWRlcn0gaGVhZGVyYCk7XG59O1xuXG4vKipcbiAqIEVuY29kZXMgYSBzdHJpbmcgdG8gQmFzZTY0IGZvcm1hdC5cbiAqL1xuZXhwb3J0IGNvbnN0IHRvQmFzZTY0ID0gKHN0cjogc3RyaW5nIHwgbnVsbCB8IHVuZGVmaW5lZCk6IHN0cmluZyA9PiB7XG4gIGlmICghc3RyKSByZXR1cm4gJyc7XG4gIGlmICh0eXBlb2YgQnVmZmVyICE9PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybiBCdWZmZXIuZnJvbShzdHIpLnRvU3RyaW5nKCdiYXNlNjQnKTtcbiAgfVxuXG4gIGlmICh0eXBlb2YgYnRvYSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICByZXR1cm4gYnRvYShzdHIpO1xuICB9XG5cbiAgdGhyb3cgbmV3IEdyb3FFcnJvcignQ2Fubm90IGdlbmVyYXRlIGI2NCBzdHJpbmc7IEV4cGVjdGVkIGBCdWZmZXJgIG9yIGBidG9hYCB0byBiZSBkZWZpbmVkJyk7XG59O1xuXG5leHBvcnQgZnVuY3Rpb24gaXNPYmoob2JqOiB1bmtub3duKTogb2JqIGlzIFJlY29yZDxzdHJpbmcsIHVua25vd24+IHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmICFBcnJheS5pc0FycmF5KG9iaik7XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy5cblxuaW1wb3J0IHR5cGUgeyBHcm9xIH0gZnJvbSAnLi9pbmRleCc7XG5cbmV4cG9ydCBjbGFzcyBBUElSZXNvdXJjZSB7XG4gIHByb3RlY3RlZCBfY2xpZW50OiBHcm9xO1xuXG4gIGNvbnN0cnVjdG9yKGNsaWVudDogR3JvcSkge1xuICAgIHRoaXMuX2NsaWVudCA9IGNsaWVudDtcbiAgfVxufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuXG5cbmltcG9ydCAqIGFzIENvcmUgZnJvbSBcIi4uLy4uL2NvcmVcIjtcbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uL3Jlc291cmNlXCI7XG5pbXBvcnQgKiBhcyBDb21wbGV0aW9uc0FQSSBmcm9tIFwiLi9jb21wbGV0aW9uc1wiO1xuaW1wb3J0IHsgU3RyZWFtIH0gZnJvbSBcIi4uLy4uL2xpYi9zdHJlYW1pbmdcIjtcbmltcG9ydCB7IENoYXRDb21wbGV0aW9uQ2h1bmsgfSBmcm9tIFwiLi4vLi4vbGliL2NoYXRfY29tcGxldGlvbnNfZXh0XCI7XG5cbmV4cG9ydCBjbGFzcyBDb21wbGV0aW9ucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIENyZWF0ZXMgYSBjb21wbGV0aW9uIGZvciBhIGNoYXQgcHJvbXB0XG4gICAqL1xuICBjcmVhdGUoXG4gICAgYm9keTogQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNOb25TdHJlYW1pbmcsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxDaGF0Q29tcGxldGlvbj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc1N0cmVhbWluZyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPFN0cmVhbTxDaGF0Q29tcGxldGlvbkNodW5rPj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc0Jhc2UsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxTdHJlYW08Q2hhdENvbXBsZXRpb25DaHVuaz4gfCBDaGF0Q29tcGxldGlvbj47XG4gIGNyZWF0ZShcbiAgICBib2R5OiBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtcyxcbiAgICBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyxcbiAgKTogQ29yZS5BUElQcm9taXNlPENoYXRDb21wbGV0aW9uPiB8IENvcmUuQVBJUHJvbWlzZTxTdHJlYW08Q2hhdENvbXBsZXRpb25DaHVuaz4+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoJy9vcGVuYWkvdjEvY2hhdC9jb21wbGV0aW9ucycsIHsgYm9keSwgLi4ub3B0aW9ucywgc3RyZWFtOiBib2R5LnN0cmVhbSA/PyBmYWxzZSB9KSBhc1xuICAgICAgfCBDb3JlLkFQSVByb21pc2U8Q2hhdENvbXBsZXRpb24+XG4gICAgICB8IENvcmUuQVBJUHJvbWlzZTxTdHJlYW08Q2hhdENvbXBsZXRpb25DaHVuaz4+O1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb24ge1xuICBjaG9pY2VzOiBBcnJheTxDaGF0Q29tcGxldGlvbi5DaG9pY2U+O1xuXG4gIGlkPzogc3RyaW5nO1xuXG4gIGNyZWF0ZWQ/OiBudW1iZXI7XG5cbiAgbW9kZWw/OiBzdHJpbmc7XG5cbiAgb2JqZWN0Pzogc3RyaW5nO1xuXG4gIHN5c3RlbV9maW5nZXJwcmludD86IHN0cmluZztcblxuICB1c2FnZT86IENoYXRDb21wbGV0aW9uLlVzYWdlO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIENoYXRDb21wbGV0aW9uIHtcbiAgZXhwb3J0IGludGVyZmFjZSBDaG9pY2Uge1xuICAgIGZpbmlzaF9yZWFzb246IHN0cmluZztcblxuICAgIGluZGV4OiBudW1iZXI7XG5cbiAgICBsb2dwcm9iczogQ2hvaWNlLkxvZ3Byb2JzO1xuXG4gICAgbWVzc2FnZTogQ2hvaWNlLk1lc3NhZ2U7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIENob2ljZSB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBMb2dwcm9icyB7XG4gICAgICBjb250ZW50PzogQXJyYXk8TG9ncHJvYnMuQ29udGVudD47XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBMb2dwcm9icyB7XG4gICAgICBleHBvcnQgaW50ZXJmYWNlIENvbnRlbnQge1xuICAgICAgICB0b2tlbj86IHN0cmluZztcblxuICAgICAgICBieXRlcz86IEFycmF5PG51bWJlcj47XG5cbiAgICAgICAgbG9ncHJvYj86IG51bWJlcjtcblxuICAgICAgICB0b3BfbG9ncHJvYnM/OiBBcnJheTxDb250ZW50LlRvcExvZ3Byb2I+O1xuICAgICAgfVxuXG4gICAgICBleHBvcnQgbmFtZXNwYWNlIENvbnRlbnQge1xuICAgICAgICBleHBvcnQgaW50ZXJmYWNlIFRvcExvZ3Byb2Ige1xuICAgICAgICAgIHRva2VuPzogc3RyaW5nO1xuXG4gICAgICAgICAgYnl0ZXM/OiBBcnJheTxudW1iZXI+O1xuXG4gICAgICAgICAgbG9ncHJvYj86IG51bWJlcjtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZSB7XG4gICAgICBjb250ZW50OiBzdHJpbmc7XG5cbiAgICAgIHJvbGU6IHN0cmluZztcblxuICAgICAgdG9vbF9jYWxscz86IEFycmF5PE1lc3NhZ2UuVG9vbENhbGw+O1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgTWVzc2FnZSB7XG4gICAgICBleHBvcnQgaW50ZXJmYWNlIFRvb2xDYWxsIHtcbiAgICAgICAgaWQ/OiBzdHJpbmc7XG5cbiAgICAgICAgZnVuY3Rpb24/OiBUb29sQ2FsbC5GdW5jdGlvbjtcblxuICAgICAgICB0eXBlPzogc3RyaW5nO1xuICAgICAgfVxuXG4gICAgICBleHBvcnQgbmFtZXNwYWNlIFRvb2xDYWxsIHtcbiAgICAgICAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbiB7XG4gICAgICAgICAgYXJndW1lbnRzPzogc3RyaW5nO1xuXG4gICAgICAgICAgbmFtZT86IHN0cmluZztcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgVXNhZ2Uge1xuICAgIGNvbXBsZXRpb25fdGltZT86IG51bWJlcjtcblxuICAgIGNvbXBsZXRpb25fdG9rZW5zPzogbnVtYmVyO1xuXG4gICAgcHJvbXB0X3RpbWU/OiBudW1iZXI7XG5cbiAgICBwcm9tcHRfdG9rZW5zPzogbnVtYmVyO1xuXG4gICAgcXVldWVfdGltZT86IG51bWJlcjtcblxuICAgIHRvdGFsX3RpbWU/OiBudW1iZXI7XG5cbiAgICB0b3RhbF90b2tlbnM/OiBudW1iZXI7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc0Jhc2Uge1xuICBtZXNzYWdlczogQXJyYXk8Q29tcGxldGlvbkNyZWF0ZVBhcmFtcy5NZXNzYWdlPjtcblxuICBtb2RlbDogc3RyaW5nO1xuXG4gIGZyZXF1ZW5jeV9wZW5hbHR5PzogbnVtYmVyO1xuXG4gIGxvZ2l0X2JpYXM/OiBSZWNvcmQ8c3RyaW5nLCBudW1iZXI+O1xuXG4gIGxvZ3Byb2JzPzogYm9vbGVhbjtcblxuICBtYXhfdG9rZW5zPzogbnVtYmVyO1xuXG4gIG4/OiBudW1iZXI7XG5cbiAgcHJlc2VuY2VfcGVuYWx0eT86IG51bWJlcjtcblxuICByZXNwb25zZV9mb3JtYXQ/OiBDb21wbGV0aW9uQ3JlYXRlUGFyYW1zLlJlc3BvbnNlRm9ybWF0O1xuXG4gIHNlZWQ/OiBudW1iZXI7XG5cbiAgLyoqXG4gICAqIFVwIHRvIDQgc2VxdWVuY2VzIHdoZXJlIHRoZSBBUEkgd2lsbCBzdG9wIGdlbmVyYXRpbmcgZnVydGhlciB0b2tlbnMuIFRoZVxuICAgKiByZXR1cm5lZCB0ZXh0IHdpbGwgbm90IGNvbnRhaW4gdGhlIHN0b3Agc2VxdWVuY2UuXG4gICAqL1xuICBzdG9wPzogc3RyaW5nIHwgbnVsbCB8IEFycmF5PHN0cmluZz47XG5cbiAgc3RyZWFtPzogYm9vbGVhbjtcblxuICB0ZW1wZXJhdHVyZT86IG51bWJlcjtcblxuICB0b29sX2Nob2ljZT86IENvbXBsZXRpb25DcmVhdGVQYXJhbXMuVG9vbENob2ljZTtcblxuICB0b29scz86IEFycmF5PENvbXBsZXRpb25DcmVhdGVQYXJhbXMuVG9vbD47XG5cbiAgdG9wX2xvZ3Byb2JzPzogbnVtYmVyO1xuXG4gIHRvcF9wPzogbnVtYmVyO1xuXG4gIHVzZXI/OiBzdHJpbmc7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ29tcGxldGlvbkNyZWF0ZVBhcmFtcyB7XG4gIGV4cG9ydCBpbnRlcmZhY2UgTWVzc2FnZSB7XG4gICAgY29udGVudDogc3RyaW5nO1xuXG4gICAgcm9sZTogc3RyaW5nO1xuXG4gICAgbmFtZT86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIFRvb2xNZXNzYWdlIEZpZWxkc1xuICAgICAqL1xuICAgIHRvb2xfY2FsbF9pZD86IHN0cmluZztcblxuICAgIC8qKlxuICAgICAqIEFzc2lzdGFudE1lc3NhZ2UgRmllbGRzXG4gICAgICovXG4gICAgdG9vbF9jYWxscz86IEFycmF5PE1lc3NhZ2UuVG9vbENhbGw+O1xuICB9XG5cbiAgZXhwb3J0IG5hbWVzcGFjZSBNZXNzYWdlIHtcbiAgICBleHBvcnQgaW50ZXJmYWNlIFRvb2xDYWxsIHtcbiAgICAgIGlkPzogc3RyaW5nO1xuXG4gICAgICBmdW5jdGlvbj86IFRvb2xDYWxsLkZ1bmN0aW9uO1xuXG4gICAgICB0eXBlPzogc3RyaW5nO1xuICAgIH1cblxuICAgIGV4cG9ydCBuYW1lc3BhY2UgVG9vbENhbGwge1xuICAgICAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbiB7XG4gICAgICAgIGFyZ3VtZW50cz86IHN0cmluZztcblxuICAgICAgICBuYW1lPzogc3RyaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgUmVzcG9uc2VGb3JtYXQge1xuICAgIHR5cGU/OiBzdHJpbmc7XG4gIH1cblxuICBleHBvcnQgaW50ZXJmYWNlIFRvb2xDaG9pY2Uge1xuICAgIHN0cmluZz86IHN0cmluZztcblxuICAgIHRvb2xDaG9pY2U/OiBUb29sQ2hvaWNlLlRvb2xDaG9pY2U7XG4gIH1cblxuICBleHBvcnQgbmFtZXNwYWNlIFRvb2xDaG9pY2Uge1xuICAgIGV4cG9ydCBpbnRlcmZhY2UgVG9vbENob2ljZSB7XG4gICAgICBmdW5jdGlvbj86IFRvb2xDaG9pY2UuRnVuY3Rpb247XG5cbiAgICAgIHR5cGU/OiBzdHJpbmc7XG4gICAgfVxuXG4gICAgZXhwb3J0IG5hbWVzcGFjZSBUb29sQ2hvaWNlIHtcbiAgICAgIGV4cG9ydCBpbnRlcmZhY2UgRnVuY3Rpb24ge1xuICAgICAgICBuYW1lPzogc3RyaW5nO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGV4cG9ydCBpbnRlcmZhY2UgVG9vbCB7XG4gICAgZnVuY3Rpb24/OiBUb29sLkZ1bmN0aW9uO1xuXG4gICAgdHlwZT86IHN0cmluZztcbiAgfVxuXG4gIGV4cG9ydCBuYW1lc3BhY2UgVG9vbCB7XG4gICAgZXhwb3J0IGludGVyZmFjZSBGdW5jdGlvbiB7XG4gICAgICBkZXNjcmlwdGlvbj86IHN0cmluZztcblxuICAgICAgbmFtZT86IHN0cmluZztcblxuICAgICAgcGFyYW1ldGVycz86IFJlY29yZDxzdHJpbmcsIHVua25vd24+O1xuICAgIH1cbiAgfVxufVxuXG5leHBvcnQgbmFtZXNwYWNlIENvbXBsZXRpb25zIHtcbiAgZXhwb3J0IGltcG9ydCBDaGF0Q29tcGxldGlvbiA9IENvbXBsZXRpb25zQVBJLkNoYXRDb21wbGV0aW9uO1xuICBleHBvcnQgaW1wb3J0IENvbXBsZXRpb25DcmVhdGVQYXJhbXMgPSBDb21wbGV0aW9uc0FQSS5Db21wbGV0aW9uQ3JlYXRlUGFyYW1zO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zTm9uU3RyZWFtaW5nIGV4dGVuZHMgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNCYXNlIHtcbiAgc3RyZWFtPzogZmFsc2U7XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgQ2hhdENvbXBsZXRpb25DcmVhdGVQYXJhbXNTdHJlYW1pbmcgZXh0ZW5kcyBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc0Jhc2Uge1xuICBzdHJlYW06IHRydWU7XG59XG5cbmV4cG9ydCB0eXBlIENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zID1cbiAgfCBDaGF0Q29tcGxldGlvbkNyZWF0ZVBhcmFtc05vblN0cmVhbWluZ1xuICB8IENoYXRDb21wbGV0aW9uQ3JlYXRlUGFyYW1zU3RyZWFtaW5nO1xuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuXG5cbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uL3Jlc291cmNlXCI7XG5pbXBvcnQgKiBhcyBDb21wbGV0aW9uc0FQSSBmcm9tIFwiLi9jb21wbGV0aW9uc1wiO1xuXG5leHBvcnQgY2xhc3MgQ2hhdCBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgY29tcGxldGlvbnM6IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25zID0gbmV3IENvbXBsZXRpb25zQVBJLkNvbXBsZXRpb25zKHRoaXMuX2NsaWVudCk7XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgQ2hhdCB7XG4gIGV4cG9ydCBpbXBvcnQgQ29tcGxldGlvbnMgPSBDb21wbGV0aW9uc0FQSS5Db21wbGV0aW9ucztcbiAgZXhwb3J0IGltcG9ydCBDaGF0Q29tcGxldGlvbiA9IENvbXBsZXRpb25zQVBJLkNoYXRDb21wbGV0aW9uO1xuICBleHBvcnQgaW1wb3J0IENvbXBsZXRpb25DcmVhdGVQYXJhbXMgPSBDb21wbGV0aW9uc0FQSS5Db21wbGV0aW9uQ3JlYXRlUGFyYW1zO1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuXG5cbmltcG9ydCAqIGFzIENvcmUgZnJvbSBcIi4uL2NvcmVcIjtcbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uL3Jlc291cmNlXCI7XG5pbXBvcnQgKiBhcyBNb2RlbHNBUEkgZnJvbSBcIi4vbW9kZWxzXCI7XG5cbmV4cG9ydCBjbGFzcyBNb2RlbHMgZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIC8qKlxuICAgKiBHZXQgYSBzcGVjaWZpYyBtb2RlbFxuICAgKi9cbiAgcmV0cmlldmUobW9kZWw6IHN0cmluZywgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8TW9kZWw+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LmdldChgL29wZW5haS92MS9tb2RlbHMvJHttb2RlbH1gLCBvcHRpb25zKTtcbiAgfVxuXG4gIC8qKlxuICAgKiBnZXQgYWxsIGF2YWlsYWJsZSBtb2RlbHNcbiAgICovXG4gIGxpc3Qob3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMpOiBDb3JlLkFQSVByb21pc2U8TW9kZWxMaXN0PiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5nZXQoJy9vcGVuYWkvdjEvbW9kZWxzJywgb3B0aW9ucyk7XG4gIH1cblxuICAvKipcbiAgICogRGVsZXRlIGEgbW9kZWxcbiAgICovXG4gIGRlbGV0ZShtb2RlbDogc3RyaW5nLCBvcHRpb25zPzogQ29yZS5SZXF1ZXN0T3B0aW9ucyk6IENvcmUuQVBJUHJvbWlzZTx2b2lkPiB7XG4gICAgcmV0dXJuIHRoaXMuX2NsaWVudC5kZWxldGUoYC9vcGVuYWkvdjEvbW9kZWxzLyR7bW9kZWx9YCwge1xuICAgICAgLi4ub3B0aW9ucyxcbiAgICAgIGhlYWRlcnM6IHsgQWNjZXB0OiAnKi8qJywgLi4ub3B0aW9ucz8uaGVhZGVycyB9LFxuICAgIH0pO1xuICB9XG59XG5cbmV4cG9ydCBpbnRlcmZhY2UgTW9kZWwge1xuICBpZD86IHN0cmluZztcblxuICBjcmVhdGVkPzogbnVtYmVyO1xuXG4gIG9iamVjdD86IHN0cmluZztcblxuICBvd25lZF9ieT86IHN0cmluZztcbn1cblxuZXhwb3J0IGludGVyZmFjZSBNb2RlbExpc3Qge1xuICBkYXRhPzogQXJyYXk8TW9kZWw+O1xuXG4gIG9iamVjdD86IHN0cmluZztcbn1cblxuZXhwb3J0IG5hbWVzcGFjZSBNb2RlbHMge1xuICBleHBvcnQgaW1wb3J0IE1vZGVsID0gTW9kZWxzQVBJLk1vZGVsO1xuICBleHBvcnQgaW1wb3J0IE1vZGVsTGlzdCA9IE1vZGVsc0FQSS5Nb2RlbExpc3Q7XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy5cblxuaW1wb3J0ICogYXMgQ29yZSBmcm9tIFwiLi4vLi4vY29yZVwiO1xuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vcmVzb3VyY2VcIjtcbmltcG9ydCAqIGFzIFRyYW5zY3JpcHRpb25zQVBJIGZyb20gXCIuL3RyYW5zY3JpcHRpb25zXCI7XG5pbXBvcnQgeyB0eXBlIFVwbG9hZGFibGUsIG11bHRpcGFydEZvcm1SZXF1ZXN0T3B0aW9ucyB9IGZyb20gXCIuLi8uLi9jb3JlXCI7XG5cbmV4cG9ydCBjbGFzcyBUcmFuc2NyaXB0aW9ucyBleHRlbmRzIEFQSVJlc291cmNlIHtcbiAgLyoqXG4gICAqIFRyYW5zY3JpYmVzIGF1ZGlvIGludG8gdGhlIGlucHV0IGxhbmd1YWdlLlxuICAgKi9cbiAgY3JlYXRlKGJvZHk6IFRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXMsIG9wdGlvbnM/OiBDb3JlLlJlcXVlc3RPcHRpb25zKTogQ29yZS5BUElQcm9taXNlPFRyYW5zY3JpcHRpb24+IHtcbiAgICByZXR1cm4gdGhpcy5fY2xpZW50LnBvc3QoXG4gICAgICAnL29wZW5haS92MS9hdWRpby90cmFuc2NyaXB0aW9ucycsXG4gICAgICBtdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pLFxuICAgICk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZXByZXNlbnRzIGEgdHJhbnNjcmlwdGlvbiByZXNwb25zZSByZXR1cm5lZCBieSBtb2RlbCwgYmFzZWQgb24gdGhlIHByb3ZpZGVkXG4gKiBpbnB1dC5cbiAqL1xuZXhwb3J0IGludGVyZmFjZSBUcmFuc2NyaXB0aW9uIHtcbiAgLyoqXG4gICAqIFRoZSB0cmFuc2NyaWJlZCB0ZXh0LlxuICAgKi9cbiAgdGV4dDogc3RyaW5nO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXMge1xuICAvKipcbiAgICogVGhlIGF1ZGlvIGZpbGUgb2JqZWN0IChub3QgZmlsZSBuYW1lKSB0byB0cmFuc2NyaWJlLCBpbiBvbmUgb2YgdGhlc2UgZm9ybWF0czpcbiAgICogZmxhYywgbXAzLCBtcDQsIG1wZWcsIG1wZ2EsIG00YSwgb2dnLCB3YXYsIG9yIHdlYm0uXG4gICAqL1xuICBmaWxlOiBVcGxvYWRhYmxlO1xuXG4gIC8qKlxuICAgKiBJRCBvZiB0aGUgbW9kZWwgdG8gdXNlLiBPbmx5IGB3aGlzcGVyLWxhcmdlLXYzYCBpcyBjdXJyZW50bHkgYXZhaWxhYmxlLlxuICAgKi9cbiAgbW9kZWw6IChzdHJpbmcgJiB7fSkgfCAnd2hpc3Blci1sYXJnZS12Myc7XG5cbiAgLyoqXG4gICAqIFRoZSBsYW5ndWFnZSBvZiB0aGUgaW5wdXQgYXVkaW8uIFN1cHBseWluZyB0aGUgaW5wdXQgbGFuZ3VhZ2UgaW5cbiAgICogW0lTTy02MzktMV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTGlzdF9vZl9JU09fNjM5LTFfY29kZXMpIGZvcm1hdCB3aWxsXG4gICAqIGltcHJvdmUgYWNjdXJhY3kgYW5kIGxhdGVuY3kuXG4gICAqL1xuICBsYW5ndWFnZT86IHN0cmluZztcblxuICAvKipcbiAgICogQW4gb3B0aW9uYWwgdGV4dCB0byBndWlkZSB0aGUgbW9kZWwncyBzdHlsZSBvciBjb250aW51ZSBhIHByZXZpb3VzIGF1ZGlvXG4gICAqIHNlZ21lbnQuIFRoZSBbcHJvbXB0XSgvZG9jcy9ndWlkZXMvc3BlZWNoLXRvLXRleHQvcHJvbXB0aW5nKSBzaG91bGQgbWF0Y2ggdGhlXG4gICAqIGF1ZGlvIGxhbmd1YWdlLlxuICAgKi9cbiAgcHJvbXB0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IG9mIHRoZSB0cmFuc2NyaXB0IG91dHB1dCwgaW4gb25lIG9mIHRoZXNlIG9wdGlvbnM6IGBqc29uYCwgYHRleHRgLFxuICAgKiBgc3J0YCwgYHZlcmJvc2VfanNvbmAsIG9yIGB2dHRgLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0PzogJ2pzb24nIHwgJ3RleHQnIHwgJ3NydCcgfCAndmVyYm9zZV9qc29uJyB8ICd2dHQnO1xuXG4gIC8qKlxuICAgKiBUaGUgc2FtcGxpbmcgdGVtcGVyYXR1cmUsIGJldHdlZW4gMCBhbmQgMS4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsIG1ha2UgdGhlXG4gICAqIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlIGZvY3VzZWQgYW5kXG4gICAqIGRldGVybWluaXN0aWMuIElmIHNldCB0byAwLCB0aGUgbW9kZWwgd2lsbCB1c2VcbiAgICogW2xvZyBwcm9iYWJpbGl0eV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9nX3Byb2JhYmlsaXR5KSB0b1xuICAgKiBhdXRvbWF0aWNhbGx5IGluY3JlYXNlIHRoZSB0ZW1wZXJhdHVyZSB1bnRpbCBjZXJ0YWluIHRocmVzaG9sZHMgYXJlIGhpdC5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBUaGUgdGltZXN0YW1wIGdyYW51bGFyaXRpZXMgdG8gcG9wdWxhdGUgZm9yIHRoaXMgdHJhbnNjcmlwdGlvbi5cbiAgICogYHJlc3BvbnNlX2Zvcm1hdGAgbXVzdCBiZSBzZXQgYHZlcmJvc2VfanNvbmAgdG8gdXNlIHRpbWVzdGFtcCBncmFudWxhcml0aWVzLlxuICAgKiBFaXRoZXIgb3IgYm90aCBvZiB0aGVzZSBvcHRpb25zIGFyZSBzdXBwb3J0ZWQ6IGB3b3JkYCwgb3IgYHNlZ21lbnRgLiBOb3RlOiBUaGVyZVxuICAgKiBpcyBubyBhZGRpdGlvbmFsIGxhdGVuY3kgZm9yIHNlZ21lbnQgdGltZXN0YW1wcywgYnV0IGdlbmVyYXRpbmcgd29yZCB0aW1lc3RhbXBzXG4gICAqIGluY3VycyBhZGRpdGlvbmFsIGxhdGVuY3kuXG4gICAqL1xuICB0aW1lc3RhbXBfZ3JhbnVsYXJpdGllcz86IEFycmF5PCd3b3JkJyB8ICdzZWdtZW50Jz47XG59XG5cbmV4cG9ydCBuYW1lc3BhY2UgVHJhbnNjcmlwdGlvbnMge1xuICBleHBvcnQgaW1wb3J0IFRyYW5zY3JpcHRpb24gPSBUcmFuc2NyaXB0aW9uc0FQSS5UcmFuc2NyaXB0aW9uO1xuICBleHBvcnQgaW1wb3J0IFRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXMgPSBUcmFuc2NyaXB0aW9uc0FQSS5UcmFuc2NyaXB0aW9uQ3JlYXRlUGFyYW1zO1xufVxuIiwgIi8vIEZpbGUgZ2VuZXJhdGVkIGZyb20gb3VyIE9wZW5BUEkgc3BlYyBieSBTdGFpbmxlc3MuXG5cbmltcG9ydCAqIGFzIENvcmUgZnJvbSBcIi4uLy4uL2NvcmVcIjtcbmltcG9ydCB7IEFQSVJlc291cmNlIH0gZnJvbSBcIi4uLy4uL3Jlc291cmNlXCI7XG5pbXBvcnQgKiBhcyBUcmFuc2xhdGlvbnNBUEkgZnJvbSBcIi4vdHJhbnNsYXRpb25zXCI7XG5pbXBvcnQgKiBhcyBBdWRpb0FQSSBmcm9tIFwiLi9hdWRpb1wiO1xuaW1wb3J0IHsgdHlwZSBVcGxvYWRhYmxlLCBtdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMgfSBmcm9tIFwiLi4vLi4vY29yZVwiO1xuXG5leHBvcnQgY2xhc3MgVHJhbnNsYXRpb25zIGV4dGVuZHMgQVBJUmVzb3VyY2Uge1xuICAvKipcbiAgICogVHJhbnNsYXRlcyBhdWRpbyBpbnRvIEVuZ2xpc2guXG4gICAqL1xuICBjcmVhdGUoXG4gICAgYm9keTogVHJhbnNsYXRpb25DcmVhdGVQYXJhbXMsXG4gICAgb3B0aW9ucz86IENvcmUuUmVxdWVzdE9wdGlvbnMsXG4gICk6IENvcmUuQVBJUHJvbWlzZTxBdWRpb0FQSS5UcmFuc2xhdGlvbj4ge1xuICAgIHJldHVybiB0aGlzLl9jbGllbnQucG9zdChcbiAgICAgICcvb3BlbmFpL3YxL2F1ZGlvL3RyYW5zbGF0aW9ucycsXG4gICAgICBtdWx0aXBhcnRGb3JtUmVxdWVzdE9wdGlvbnMoeyBib2R5LCAuLi5vcHRpb25zIH0pLFxuICAgICk7XG4gIH1cbn1cblxuZXhwb3J0IGludGVyZmFjZSBUcmFuc2xhdGlvbkNyZWF0ZVBhcmFtcyB7XG4gIC8qKlxuICAgKiBUaGUgYXVkaW8gZmlsZSBvYmplY3QgKG5vdCBmaWxlIG5hbWUpIHRyYW5zbGF0ZSwgaW4gb25lIG9mIHRoZXNlIGZvcm1hdHM6IGZsYWMsXG4gICAqIG1wMywgbXA0LCBtcGVnLCBtcGdhLCBtNGEsIG9nZywgd2F2LCBvciB3ZWJtLlxuICAgKi9cbiAgZmlsZTogVXBsb2FkYWJsZTtcblxuICAvKipcbiAgICogSUQgb2YgdGhlIG1vZGVsIHRvIHVzZS4gT25seSBgd2hpc3Blci1sYXJnZS12M2AgaXMgY3VycmVudGx5IGF2YWlsYWJsZS5cbiAgICovXG4gIG1vZGVsOiAoc3RyaW5nICYge30pIHwgJ3doaXNwZXItbGFyZ2UtdjMnO1xuXG4gIC8qKlxuICAgKiBBbiBvcHRpb25hbCB0ZXh0IHRvIGd1aWRlIHRoZSBtb2RlbCdzIHN0eWxlIG9yIGNvbnRpbnVlIGEgcHJldmlvdXMgYXVkaW9cbiAgICogc2VnbWVudC4gVGhlIFtwcm9tcHRdKC9kb2NzL2d1aWRlcy9zcGVlY2gtdG8tdGV4dC9wcm9tcHRpbmcpIHNob3VsZCBiZSBpblxuICAgKiBFbmdsaXNoLlxuICAgKi9cbiAgcHJvbXB0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgZm9ybWF0IG9mIHRoZSB0cmFuc2NyaXB0IG91dHB1dCwgaW4gb25lIG9mIHRoZXNlIG9wdGlvbnM6IGBqc29uYCwgYHRleHRgLFxuICAgKiBgc3J0YCwgYHZlcmJvc2VfanNvbmAsIG9yIGB2dHRgLlxuICAgKi9cbiAgcmVzcG9uc2VfZm9ybWF0Pzogc3RyaW5nO1xuXG4gIC8qKlxuICAgKiBUaGUgc2FtcGxpbmcgdGVtcGVyYXR1cmUsIGJldHdlZW4gMCBhbmQgMS4gSGlnaGVyIHZhbHVlcyBsaWtlIDAuOCB3aWxsIG1ha2UgdGhlXG4gICAqIG91dHB1dCBtb3JlIHJhbmRvbSwgd2hpbGUgbG93ZXIgdmFsdWVzIGxpa2UgMC4yIHdpbGwgbWFrZSBpdCBtb3JlIGZvY3VzZWQgYW5kXG4gICAqIGRldGVybWluaXN0aWMuIElmIHNldCB0byAwLCB0aGUgbW9kZWwgd2lsbCB1c2VcbiAgICogW2xvZyBwcm9iYWJpbGl0eV0oaHR0cHM6Ly9lbi53aWtpcGVkaWEub3JnL3dpa2kvTG9nX3Byb2JhYmlsaXR5KSB0b1xuICAgKiBhdXRvbWF0aWNhbGx5IGluY3JlYXNlIHRoZSB0ZW1wZXJhdHVyZSB1bnRpbCBjZXJ0YWluIHRocmVzaG9sZHMgYXJlIGhpdC5cbiAgICovXG4gIHRlbXBlcmF0dXJlPzogbnVtYmVyO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIFRyYW5zbGF0aW9ucyB7XG4gIGV4cG9ydCBpbXBvcnQgVHJhbnNsYXRpb25DcmVhdGVQYXJhbXMgPSBUcmFuc2xhdGlvbnNBUEkuVHJhbnNsYXRpb25DcmVhdGVQYXJhbXM7XG59XG4iLCAiLy8gRmlsZSBnZW5lcmF0ZWQgZnJvbSBvdXIgT3BlbkFQSSBzcGVjIGJ5IFN0YWlubGVzcy5cblxuaW1wb3J0IHsgQVBJUmVzb3VyY2UgfSBmcm9tIFwiLi4vLi4vcmVzb3VyY2VcIjtcbmltcG9ydCAqIGFzIEF1ZGlvQVBJIGZyb20gXCIuL2F1ZGlvXCI7XG5pbXBvcnQgKiBhcyBUcmFuc2NyaXB0aW9uc0FQSSBmcm9tIFwiLi90cmFuc2NyaXB0aW9uc1wiO1xuaW1wb3J0ICogYXMgVHJhbnNsYXRpb25zQVBJIGZyb20gXCIuL3RyYW5zbGF0aW9uc1wiO1xuXG5leHBvcnQgY2xhc3MgQXVkaW8gZXh0ZW5kcyBBUElSZXNvdXJjZSB7XG4gIHRyYW5zY3JpcHRpb25zOiBUcmFuc2NyaXB0aW9uc0FQSS5UcmFuc2NyaXB0aW9ucyA9IG5ldyBUcmFuc2NyaXB0aW9uc0FQSS5UcmFuc2NyaXB0aW9ucyh0aGlzLl9jbGllbnQpO1xuICB0cmFuc2xhdGlvbnM6IFRyYW5zbGF0aW9uc0FQSS5UcmFuc2xhdGlvbnMgPSBuZXcgVHJhbnNsYXRpb25zQVBJLlRyYW5zbGF0aW9ucyh0aGlzLl9jbGllbnQpO1xufVxuXG5leHBvcnQgaW50ZXJmYWNlIFRyYW5zbGF0aW9uIHtcbiAgdGV4dDogc3RyaW5nO1xufVxuXG5leHBvcnQgbmFtZXNwYWNlIEF1ZGlvIHtcbiAgZXhwb3J0IGltcG9ydCBUcmFuc2xhdGlvbiA9IEF1ZGlvQVBJLlRyYW5zbGF0aW9uO1xuICBleHBvcnQgaW1wb3J0IFRyYW5zY3JpcHRpb25zID0gVHJhbnNjcmlwdGlvbnNBUEkuVHJhbnNjcmlwdGlvbnM7XG4gIGV4cG9ydCBpbXBvcnQgVHJhbnNjcmlwdGlvbiA9IFRyYW5zY3JpcHRpb25zQVBJLlRyYW5zY3JpcHRpb247XG4gIGV4cG9ydCBpbXBvcnQgVHJhbnNjcmlwdGlvbkNyZWF0ZVBhcmFtcyA9IFRyYW5zY3JpcHRpb25zQVBJLlRyYW5zY3JpcHRpb25DcmVhdGVQYXJhbXM7XG4gIGV4cG9ydCBpbXBvcnQgVHJhbnNsYXRpb25zID0gVHJhbnNsYXRpb25zQVBJLlRyYW5zbGF0aW9ucztcbiAgZXhwb3J0IGltcG9ydCBUcmFuc2xhdGlvbkNyZWF0ZVBhcmFtcyA9IFRyYW5zbGF0aW9uc0FQSS5UcmFuc2xhdGlvbkNyZWF0ZVBhcmFtcztcbn1cbiIsICIvLyBGaWxlIGdlbmVyYXRlZCBmcm9tIG91ciBPcGVuQVBJIHNwZWMgYnkgU3RhaW5sZXNzLlxuXG5pbXBvcnQgKiBhcyBDb3JlIGZyb20gJy4vY29yZSc7XG5pbXBvcnQgKiBhcyBFcnJvcnMgZnJvbSAnLi9lcnJvcic7XG5pbXBvcnQgeyB0eXBlIEFnZW50IH0gZnJvbSAnLi9fc2hpbXMvaW5kZXgnO1xuaW1wb3J0ICogYXMgVXBsb2FkcyBmcm9tICcuL3VwbG9hZHMnO1xuaW1wb3J0ICogYXMgQVBJIGZyb20gXCIuL3Jlc291cmNlcy9pbmRleFwiO1xuXG5leHBvcnQgaW50ZXJmYWNlIENsaWVudE9wdGlvbnMge1xuICAvKipcbiAgICogRGVmYXVsdHMgdG8gcHJvY2Vzcy5lbnZbJ0dST1FfQVBJX0tFWSddLlxuICAgKi9cbiAgYXBpS2V5Pzogc3RyaW5nIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBPdmVycmlkZSB0aGUgZGVmYXVsdCBiYXNlIFVSTCBmb3IgdGhlIEFQSSwgZS5nLiwgXCJodHRwczovL2FwaS5leGFtcGxlLmNvbS92Mi9cIlxuICAgKlxuICAgKiBEZWZhdWx0cyB0byBwcm9jZXNzLmVudlsnR1JPUV9CQVNFX1VSTCddLlxuICAgKi9cbiAgYmFzZVVSTD86IHN0cmluZyB8IG51bGwgfCB1bmRlZmluZWQ7XG5cbiAgLyoqXG4gICAqIFRoZSBtYXhpbXVtIGFtb3VudCBvZiB0aW1lIChpbiBtaWxsaXNlY29uZHMpIHRoYXQgdGhlIGNsaWVudCBzaG91bGQgd2FpdCBmb3IgYSByZXNwb25zZVxuICAgKiBmcm9tIHRoZSBzZXJ2ZXIgYmVmb3JlIHRpbWluZyBvdXQgYSBzaW5nbGUgcmVxdWVzdC5cbiAgICpcbiAgICogTm90ZSB0aGF0IHJlcXVlc3QgdGltZW91dHMgYXJlIHJldHJpZWQgYnkgZGVmYXVsdCwgc28gaW4gYSB3b3JzdC1jYXNlIHNjZW5hcmlvIHlvdSBtYXkgd2FpdFxuICAgKiBtdWNoIGxvbmdlciB0aGFuIHRoaXMgdGltZW91dCBiZWZvcmUgdGhlIHByb21pc2Ugc3VjY2VlZHMgb3IgZmFpbHMuXG4gICAqL1xuICB0aW1lb3V0PzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBBbiBIVFRQIGFnZW50IHVzZWQgdG8gbWFuYWdlIEhUVFAoUykgY29ubmVjdGlvbnMuXG4gICAqXG4gICAqIElmIG5vdCBwcm92aWRlZCwgYW4gYWdlbnQgd2lsbCBiZSBjb25zdHJ1Y3RlZCBieSBkZWZhdWx0IGluIHRoZSBOb2RlLmpzIGVudmlyb25tZW50LFxuICAgKiBvdGhlcndpc2Ugbm8gYWdlbnQgaXMgdXNlZC5cbiAgICovXG4gIGh0dHBBZ2VudD86IEFnZW50O1xuXG4gIC8qKlxuICAgKiBTcGVjaWZ5IGEgY3VzdG9tIGBmZXRjaGAgZnVuY3Rpb24gaW1wbGVtZW50YXRpb24uXG4gICAqXG4gICAqIElmIG5vdCBwcm92aWRlZCwgd2UgdXNlIGBub2RlLWZldGNoYCBvbiBOb2RlLmpzIGFuZCBvdGhlcndpc2UgZXhwZWN0IHRoYXQgYGZldGNoYCBpc1xuICAgKiBkZWZpbmVkIGdsb2JhbGx5LlxuICAgKi9cbiAgZmV0Y2g/OiBDb3JlLkZldGNoIHwgdW5kZWZpbmVkO1xuXG4gIC8qKlxuICAgKiBUaGUgbWF4aW11bSBudW1iZXIgb2YgdGltZXMgdGhhdCB0aGUgY2xpZW50IHdpbGwgcmV0cnkgYSByZXF1ZXN0IGluIGNhc2Ugb2YgYVxuICAgKiB0ZW1wb3JhcnkgZmFpbHVyZSwgbGlrZSBhIG5ldHdvcmsgZXJyb3Igb3IgYSA1WFggZXJyb3IgZnJvbSB0aGUgc2VydmVyLlxuICAgKlxuICAgKiBAZGVmYXVsdCAyXG4gICAqL1xuICBtYXhSZXRyaWVzPzogbnVtYmVyO1xuXG4gIC8qKlxuICAgKiBEZWZhdWx0IGhlYWRlcnMgdG8gaW5jbHVkZSB3aXRoIGV2ZXJ5IHJlcXVlc3QgdG8gdGhlIEFQSS5cbiAgICpcbiAgICogVGhlc2UgY2FuIGJlIHJlbW92ZWQgaW4gaW5kaXZpZHVhbCByZXF1ZXN0cyBieSBleHBsaWNpdGx5IHNldHRpbmcgdGhlXG4gICAqIGhlYWRlciB0byBgdW5kZWZpbmVkYCBvciBgbnVsbGAgaW4gcmVxdWVzdCBvcHRpb25zLlxuICAgKi9cbiAgZGVmYXVsdEhlYWRlcnM/OiBDb3JlLkhlYWRlcnM7XG5cbiAgLyoqXG4gICAqIERlZmF1bHQgcXVlcnkgcGFyYW1ldGVycyB0byBpbmNsdWRlIHdpdGggZXZlcnkgcmVxdWVzdCB0byB0aGUgQVBJLlxuICAgKlxuICAgKiBUaGVzZSBjYW4gYmUgcmVtb3ZlZCBpbiBpbmRpdmlkdWFsIHJlcXVlc3RzIGJ5IGV4cGxpY2l0bHkgc2V0dGluZyB0aGVcbiAgICogcGFyYW0gdG8gYHVuZGVmaW5lZGAgaW4gcmVxdWVzdCBvcHRpb25zLlxuICAgKi9cbiAgZGVmYXVsdFF1ZXJ5PzogQ29yZS5EZWZhdWx0UXVlcnk7XG5cbiAgLyoqXG4gICAqIEJ5IGRlZmF1bHQsIGNsaWVudC1zaWRlIHVzZSBvZiB0aGlzIGxpYnJhcnkgaXMgbm90IGFsbG93ZWQsIGFzIGl0IHJpc2tzIGV4cG9zaW5nIHlvdXIgc2VjcmV0IEFQSSBjcmVkZW50aWFscyB0byBhdHRhY2tlcnMuXG4gICAqIE9ubHkgc2V0IHRoaXMgb3B0aW9uIHRvIGB0cnVlYCBpZiB5b3UgdW5kZXJzdGFuZCB0aGUgcmlza3MgYW5kIGhhdmUgYXBwcm9wcmlhdGUgbWl0aWdhdGlvbnMgaW4gcGxhY2UuXG4gICAqL1xuICBkYW5nZXJvdXNseUFsbG93QnJvd3Nlcj86IGJvb2xlYW47XG59XG5cbi8qKiBBUEkgQ2xpZW50IGZvciBpbnRlcmZhY2luZyB3aXRoIHRoZSBHcm9xIEFQSS4gKi9cbmV4cG9ydCBjbGFzcyBHcm9xIGV4dGVuZHMgQ29yZS5BUElDbGllbnQge1xuICBhcGlLZXk6IHN0cmluZztcblxuICBwcml2YXRlIF9vcHRpb25zOiBDbGllbnRPcHRpb25zO1xuXG4gIC8qKlxuICAgKiBBUEkgQ2xpZW50IGZvciBpbnRlcmZhY2luZyB3aXRoIHRoZSBHcm9xIEFQSS5cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmcgfCB1bmRlZmluZWR9IFtvcHRzLmFwaUtleT1wcm9jZXNzLmVudlsnR1JPUV9BUElfS0VZJ10gPz8gdW5kZWZpbmVkXVxuICAgKiBAcGFyYW0ge3N0cmluZ30gW29wdHMuYmFzZVVSTD1wcm9jZXNzLmVudlsnR1JPUV9CQVNFX1VSTCddID8/IGh0dHBzOi8vYXBpLmdyb3EuY29tXSAtIE92ZXJyaWRlIHRoZSBkZWZhdWx0IGJhc2UgVVJMIGZvciB0aGUgQVBJLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMudGltZW91dD0xIG1pbnV0ZV0gLSBUaGUgbWF4aW11bSBhbW91bnQgb2YgdGltZSAoaW4gbWlsbGlzZWNvbmRzKSB0aGUgY2xpZW50IHdpbGwgd2FpdCBmb3IgYSByZXNwb25zZSBiZWZvcmUgdGltaW5nIG91dC5cbiAgICogQHBhcmFtIHtudW1iZXJ9IFtvcHRzLmh0dHBBZ2VudF0gLSBBbiBIVFRQIGFnZW50IHVzZWQgdG8gbWFuYWdlIEhUVFAocykgY29ubmVjdGlvbnMuXG4gICAqIEBwYXJhbSB7Q29yZS5GZXRjaH0gW29wdHMuZmV0Y2hdIC0gU3BlY2lmeSBhIGN1c3RvbSBgZmV0Y2hgIGZ1bmN0aW9uIGltcGxlbWVudGF0aW9uLlxuICAgKiBAcGFyYW0ge251bWJlcn0gW29wdHMubWF4UmV0cmllcz0yXSAtIFRoZSBtYXhpbXVtIG51bWJlciBvZiB0aW1lcyB0aGUgY2xpZW50IHdpbGwgcmV0cnkgYSByZXF1ZXN0LlxuICAgKiBAcGFyYW0ge0NvcmUuSGVhZGVyc30gb3B0cy5kZWZhdWx0SGVhZGVycyAtIERlZmF1bHQgaGVhZGVycyB0byBpbmNsdWRlIHdpdGggZXZlcnkgcmVxdWVzdCB0byB0aGUgQVBJLlxuICAgKiBAcGFyYW0ge0NvcmUuRGVmYXVsdFF1ZXJ5fSBvcHRzLmRlZmF1bHRRdWVyeSAtIERlZmF1bHQgcXVlcnkgcGFyYW1ldGVycyB0byBpbmNsdWRlIHdpdGggZXZlcnkgcmVxdWVzdCB0byB0aGUgQVBJLlxuICAgKiBAcGFyYW0ge2Jvb2xlYW59IFtvcHRzLmRhbmdlcm91c2x5QWxsb3dCcm93c2VyPWZhbHNlXSAtIEJ5IGRlZmF1bHQsIGNsaWVudC1zaWRlIHVzZSBvZiB0aGlzIGxpYnJhcnkgaXMgbm90IGFsbG93ZWQsIGFzIGl0IHJpc2tzIGV4cG9zaW5nIHlvdXIgc2VjcmV0IEFQSSBjcmVkZW50aWFscyB0byBhdHRhY2tlcnMuXG4gICAqL1xuICBjb25zdHJ1Y3Rvcih7XG4gICAgYmFzZVVSTCA9IENvcmUucmVhZEVudignR1JPUV9CQVNFX1VSTCcpLFxuICAgIGFwaUtleSA9IENvcmUucmVhZEVudignR1JPUV9BUElfS0VZJyksXG4gICAgLi4ub3B0c1xuICB9OiBDbGllbnRPcHRpb25zID0ge30pIHtcbiAgICBpZiAoYXBpS2V5ID09PSB1bmRlZmluZWQpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcnMuR3JvcUVycm9yKFxuICAgICAgICBcIlRoZSBHUk9RX0FQSV9LRVkgZW52aXJvbm1lbnQgdmFyaWFibGUgaXMgbWlzc2luZyBvciBlbXB0eTsgZWl0aGVyIHByb3ZpZGUgaXQsIG9yIGluc3RhbnRpYXRlIHRoZSBHcm9xIGNsaWVudCB3aXRoIGFuIGFwaUtleSBvcHRpb24sIGxpa2UgbmV3IEdyb3EoeyBhcGlLZXk6ICdNeSBBUEkgS2V5JyB9KS5cIixcbiAgICAgICk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3B0aW9uczogQ2xpZW50T3B0aW9ucyA9IHtcbiAgICAgIGFwaUtleSxcbiAgICAgIC4uLm9wdHMsXG4gICAgICBiYXNlVVJMOiBiYXNlVVJMIHx8IGBodHRwczovL2FwaS5ncm9xLmNvbWAsXG4gICAgfTtcblxuICAgIGlmICghb3B0aW9ucy5kYW5nZXJvdXNseUFsbG93QnJvd3NlciAmJiBDb3JlLmlzUnVubmluZ0luQnJvd3NlcigpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3JzLkdyb3FFcnJvcihcbiAgICAgICAgJ1RoaXMgaXMgZGlzYWJsZWQgYnkgZGVmYXVsdCwgYXMgaXQgcmlza3MgZXhwb3NpbmcgeW91ciBzZWNyZXQgQVBJIGNyZWRlbnRpYWxzIHRvIGF0dGFja2Vycy5cXG5JZiB5b3UgdW5kZXJzdGFuZCB0aGUgcmlza3MgYW5kIGhhdmUgYXBwcm9wcmlhdGUgbWl0aWdhdGlvbnMgaW4gcGxhY2UsXFxueW91IGNhbiBzZXQgdGhlIGBkYW5nZXJvdXNseUFsbG93QnJvd3NlcmAgb3B0aW9uIHRvIGB0cnVlYCwgZS5nLixcXG5cXG5uZXcgR3JvcSh7IGRhbmdlcm91c2x5QWxsb3dCcm93c2VyOiB0cnVlIH0pJyxcbiAgICAgICk7XG4gICAgfVxuXG4gICAgc3VwZXIoe1xuICAgICAgYmFzZVVSTDogb3B0aW9ucy5iYXNlVVJMISxcbiAgICAgIHRpbWVvdXQ6IG9wdGlvbnMudGltZW91dCA/PyA2MDAwMCAvKiAxIG1pbnV0ZSAqLyxcbiAgICAgIGh0dHBBZ2VudDogb3B0aW9ucy5odHRwQWdlbnQsXG4gICAgICBtYXhSZXRyaWVzOiBvcHRpb25zLm1heFJldHJpZXMsXG4gICAgICBmZXRjaDogb3B0aW9ucy5mZXRjaCxcbiAgICB9KTtcbiAgICB0aGlzLl9vcHRpb25zID0gb3B0aW9ucztcblxuICAgIHRoaXMuYXBpS2V5ID0gYXBpS2V5O1xuICB9XG5cbiAgY2hhdDogQVBJLkNoYXQgPSBuZXcgQVBJLkNoYXQodGhpcyk7XG4gIGF1ZGlvOiBBUEkuQXVkaW8gPSBuZXcgQVBJLkF1ZGlvKHRoaXMpO1xuICBtb2RlbHM6IEFQSS5Nb2RlbHMgPSBuZXcgQVBJLk1vZGVscyh0aGlzKTtcblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgZGVmYXVsdFF1ZXJ5KCk6IENvcmUuRGVmYXVsdFF1ZXJ5IHwgdW5kZWZpbmVkIHtcbiAgICByZXR1cm4gdGhpcy5fb3B0aW9ucy5kZWZhdWx0UXVlcnk7XG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgZGVmYXVsdEhlYWRlcnMob3B0czogQ29yZS5GaW5hbFJlcXVlc3RPcHRpb25zKTogQ29yZS5IZWFkZXJzIHtcbiAgICByZXR1cm4ge1xuICAgICAgLi4uc3VwZXIuZGVmYXVsdEhlYWRlcnMob3B0cyksXG4gICAgICAuLi50aGlzLl9vcHRpb25zLmRlZmF1bHRIZWFkZXJzLFxuICAgIH07XG4gIH1cblxuICBwcm90ZWN0ZWQgb3ZlcnJpZGUgYXV0aEhlYWRlcnMob3B0czogQ29yZS5GaW5hbFJlcXVlc3RPcHRpb25zKTogQ29yZS5IZWFkZXJzIHtcbiAgICByZXR1cm4geyBBdXRob3JpemF0aW9uOiBgQmVhcmVyICR7dGhpcy5hcGlLZXl9YCB9O1xuICB9XG5cbiAgc3RhdGljIEdyb3EgPSB0aGlzO1xuXG4gIHN0YXRpYyBHcm9xRXJyb3IgPSBFcnJvcnMuR3JvcUVycm9yO1xuICBzdGF0aWMgQVBJRXJyb3IgPSBFcnJvcnMuQVBJRXJyb3I7XG4gIHN0YXRpYyBBUElDb25uZWN0aW9uRXJyb3IgPSBFcnJvcnMuQVBJQ29ubmVjdGlvbkVycm9yO1xuICBzdGF0aWMgQVBJQ29ubmVjdGlvblRpbWVvdXRFcnJvciA9IEVycm9ycy5BUElDb25uZWN0aW9uVGltZW91dEVycm9yO1xuICBzdGF0aWMgQVBJVXNlckFib3J0RXJyb3IgPSBFcnJvcnMuQVBJVXNlckFib3J0RXJyb3I7XG4gIHN0YXRpYyBOb3RGb3VuZEVycm9yID0gRXJyb3JzLk5vdEZvdW5kRXJyb3I7XG4gIHN0YXRpYyBDb25mbGljdEVycm9yID0gRXJyb3JzLkNvbmZsaWN0RXJyb3I7XG4gIHN0YXRpYyBSYXRlTGltaXRFcnJvciA9IEVycm9ycy5SYXRlTGltaXRFcnJvcjtcbiAgc3RhdGljIEJhZFJlcXVlc3RFcnJvciA9IEVycm9ycy5CYWRSZXF1ZXN0RXJyb3I7XG4gIHN0YXRpYyBBdXRoZW50aWNhdGlvbkVycm9yID0gRXJyb3JzLkF1dGhlbnRpY2F0aW9uRXJyb3I7XG4gIHN0YXRpYyBJbnRlcm5hbFNlcnZlckVycm9yID0gRXJyb3JzLkludGVybmFsU2VydmVyRXJyb3I7XG4gIHN0YXRpYyBQZXJtaXNzaW9uRGVuaWVkRXJyb3IgPSBFcnJvcnMuUGVybWlzc2lvbkRlbmllZEVycm9yO1xuICBzdGF0aWMgVW5wcm9jZXNzYWJsZUVudGl0eUVycm9yID0gRXJyb3JzLlVucHJvY2Vzc2FibGVFbnRpdHlFcnJvcjtcbn1cblxuZXhwb3J0IGNvbnN0IHtcbiAgR3JvcUVycm9yLFxuICBBUElFcnJvcixcbiAgQVBJQ29ubmVjdGlvbkVycm9yLFxuICBBUElDb25uZWN0aW9uVGltZW91dEVycm9yLFxuICBBUElVc2VyQWJvcnRFcnJvcixcbiAgTm90Rm91bmRFcnJvcixcbiAgQ29uZmxpY3RFcnJvcixcbiAgUmF0ZUxpbWl0RXJyb3IsXG4gIEJhZFJlcXVlc3RFcnJvcixcbiAgQXV0aGVudGljYXRpb25FcnJvcixcbiAgSW50ZXJuYWxTZXJ2ZXJFcnJvcixcbiAgUGVybWlzc2lvbkRlbmllZEVycm9yLFxuICBVbnByb2Nlc3NhYmxlRW50aXR5RXJyb3IsXG59ID0gRXJyb3JzO1xuXG5leHBvcnQgaW1wb3J0IHRvRmlsZSA9IFVwbG9hZHMudG9GaWxlO1xuZXhwb3J0IGltcG9ydCBmaWxlRnJvbVBhdGggPSBVcGxvYWRzLmZpbGVGcm9tUGF0aDtcblxuZXhwb3J0IG5hbWVzcGFjZSBHcm9xIHtcbiAgLy8gSGVscGVyIGZ1bmN0aW9uc1xuICBleHBvcnQgaW1wb3J0IHRvRmlsZSA9IFVwbG9hZHMudG9GaWxlO1xuICBleHBvcnQgaW1wb3J0IGZpbGVGcm9tUGF0aCA9IFVwbG9hZHMuZmlsZUZyb21QYXRoO1xuXG4gIGV4cG9ydCBpbXBvcnQgUmVxdWVzdE9wdGlvbnMgPSBDb3JlLlJlcXVlc3RPcHRpb25zO1xuXG4gIGV4cG9ydCBpbXBvcnQgQ2hhdCA9IEFQSS5DaGF0O1xuXG4gIGV4cG9ydCBpbXBvcnQgQXVkaW8gPSBBUEkuQXVkaW87XG4gIGV4cG9ydCBpbXBvcnQgVHJhbnNsYXRpb24gPSBBUEkuVHJhbnNsYXRpb247XG5cbiAgZXhwb3J0IGltcG9ydCBNb2RlbHMgPSBBUEkuTW9kZWxzO1xuICBleHBvcnQgaW1wb3J0IE1vZGVsID0gQVBJLk1vZGVsO1xuICBleHBvcnQgaW1wb3J0IE1vZGVsTGlzdCA9IEFQSS5Nb2RlbExpc3Q7XG59XG5cbmV4cG9ydCBkZWZhdWx0IEdyb3E7XG4iLCAiZnVuY3Rpb24gYXJvdW5kKG9iaiwgZmFjdG9yaWVzKSB7XG4gIGNvbnN0IHJlbW92ZXJzID0gT2JqZWN0LmtleXMoZmFjdG9yaWVzKS5tYXAoKGtleSkgPT4gYXJvdW5kMShvYmosIGtleSwgZmFjdG9yaWVzW2tleV0pKTtcbiAgcmV0dXJuIHJlbW92ZXJzLmxlbmd0aCA9PT0gMSA/IHJlbW92ZXJzWzBdIDogZnVuY3Rpb24oKSB7XG4gICAgcmVtb3ZlcnMuZm9yRWFjaCgocikgPT4gcigpKTtcbiAgfTtcbn1cbmZ1bmN0aW9uIGFyb3VuZDEob2JqLCBtZXRob2QsIGNyZWF0ZVdyYXBwZXIpIHtcbiAgY29uc3QgaW5oZXJpdGVkID0gb2JqW21ldGhvZF0sIGhhZE93biA9IG9iai5oYXNPd25Qcm9wZXJ0eShtZXRob2QpLCBvcmlnaW5hbCA9IGhhZE93biA/IGluaGVyaXRlZCA6IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBPYmplY3QuZ2V0UHJvdG90eXBlT2Yob2JqKVttZXRob2RdLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gIH07XG4gIGxldCBjdXJyZW50ID0gY3JlYXRlV3JhcHBlcihvcmlnaW5hbCk7XG4gIGlmIChpbmhlcml0ZWQpXG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKGN1cnJlbnQsIGluaGVyaXRlZCk7XG4gIE9iamVjdC5zZXRQcm90b3R5cGVPZih3cmFwcGVyLCBjdXJyZW50KTtcbiAgb2JqW21ldGhvZF0gPSB3cmFwcGVyO1xuICByZXR1cm4gcmVtb3ZlO1xuICBmdW5jdGlvbiB3cmFwcGVyKC4uLmFyZ3MpIHtcbiAgICBpZiAoY3VycmVudCA9PT0gb3JpZ2luYWwgJiYgb2JqW21ldGhvZF0gPT09IHdyYXBwZXIpXG4gICAgICByZW1vdmUoKTtcbiAgICByZXR1cm4gY3VycmVudC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmUoKSB7XG4gICAgaWYgKG9ialttZXRob2RdID09PSB3cmFwcGVyKSB7XG4gICAgICBpZiAoaGFkT3duKVxuICAgICAgICBvYmpbbWV0aG9kXSA9IG9yaWdpbmFsO1xuICAgICAgZWxzZVxuICAgICAgICBkZWxldGUgb2JqW21ldGhvZF07XG4gICAgfVxuICAgIGlmIChjdXJyZW50ID09PSBvcmlnaW5hbClcbiAgICAgIHJldHVybjtcbiAgICBjdXJyZW50ID0gb3JpZ2luYWw7XG4gICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKHdyYXBwZXIsIGluaGVyaXRlZCB8fCBGdW5jdGlvbik7XG4gIH1cbn1cbmZ1bmN0aW9uIGRlZHVwZShrZXksIG9sZEZuLCBuZXdGbikge1xuICBjaGVja1trZXldID0ga2V5O1xuICByZXR1cm4gY2hlY2s7XG4gIGZ1bmN0aW9uIGNoZWNrKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gKG9sZEZuW2tleV0gPT09IGtleSA/IG9sZEZuIDogbmV3Rm4pLmFwcGx5KHRoaXMsIGFyZ3MpO1xuICB9XG59XG5mdW5jdGlvbiBhZnRlcihwcm9taXNlLCBjYikge1xuICByZXR1cm4gcHJvbWlzZS50aGVuKGNiLCBjYik7XG59XG5mdW5jdGlvbiBzZXJpYWxpemUoYXN5bmNGdW5jdGlvbikge1xuICBsZXQgbGFzdFJ1biA9IFByb21pc2UucmVzb2x2ZSgpO1xuICBmdW5jdGlvbiB3cmFwcGVyKC4uLmFyZ3MpIHtcbiAgICByZXR1cm4gbGFzdFJ1biA9IG5ldyBQcm9taXNlKChyZXMsIHJlaikgPT4ge1xuICAgICAgYWZ0ZXIobGFzdFJ1biwgKCkgPT4ge1xuICAgICAgICBhc3luY0Z1bmN0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpLnRoZW4ocmVzLCByZWopO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgd3JhcHBlci5hZnRlciA9IGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBsYXN0UnVuID0gbmV3IFByb21pc2UoKHJlcywgcmVqKSA9PiB7XG4gICAgICBhZnRlcihsYXN0UnVuLCByZXMpO1xuICAgIH0pO1xuICB9O1xuICByZXR1cm4gd3JhcHBlcjtcbn1cblxuZXhwb3J0IHsgYWZ0ZXIsIGFyb3VuZCwgZGVkdXBlLCBzZXJpYWxpemUgfTtcbiJdLAogICJtYXBwaW5ncyI6ICI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQTtBQUFBLDhDQUFBQSxTQUFBO0FBQUEsSUFBQUEsUUFBQTtBQUFBLE1BQ0UsTUFBUTtBQUFBLE1BQ1IsU0FBVztBQUFBLE1BQ1gsYUFBZTtB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QUVBLFdBQVc7QUFBQSxFQUFDO0FBQUEsRUFFWixNQUFNLGVBQWU7QUFDakIsU0FBSyxXQUFXLE9BQU8sT0FBTyxDQUFDLEdBQUcsa0JBQWtCLE1BQU0sS0FBSyxTQUFTLENBQUM7QUFBQSxFQUM3RTtBQUFBLEVBRUEsTUFBTSxlQUFlO0FBQ2pCLFVBQU0sS0FBSyxTQUFTLEtBQUssUUFBUTtBQUFBLEVBQ3JDO0FBQ0o7IiwKICAibmFtZXMiOiBbIm1vZHVsZSIsICJtb2R1bGUiLCAiZGVidWciLCAicGF0aCIsICJjb25maWciLCAiZmV0Y2giLCAiUmVxdWVzdCIsICJSZXNwb25zZSIsICJIZWFkZXJzIiwgIkZvcm1EYXRhIiwgIkJsb2IiLCAiRmlsZSIsICJSZWFkYWJsZVN0cmVhbSIsICJSZWFkYWJsZVN0cmVhbSIsICJfYSIsICJfYSIsICJGaWxlIiwgIkZvcm1EYXRhIiwgImZldGNoIiwgIm9wdHMiLCAiX2EiLCAicmV0cnlNZXNzYWdlIiwgIl9hIiwgIl9hIiwgIkNvbXBsZXRpb25zIiwgIkNoYXQiLCAiTW9kZWxzIiwgIlRyYW5zY3JpcHRpb25zIiwgIlRyYW5zbGF0aW9ucyIsICJBdWRpbyIsICJfYSIsICJHcm9xRXJyb3IiLCAiQVBJRXJyb3IiLCAiQVBJQ29ubmVjdGlvbkVycm9yIiwgIkFQSUNvbm5lY3Rpb25UaW1lb3V0RXJyb3IiLCAiQVBJVXNlckFib3J0RXJyb3IiLCAiTm90Rm91bmRFcnJvciIsICJDb25mbGljdEVycm9yIiwgIlJhdGVMaW1pdEVycm9yIiwgIkJhZFJlcXVlc3RFcnJvciIsICJBdXRoZW50aWNhdGlvbkVycm9yIiwgIkludGVybmFsU2VydmVyRXJyb3IiLCAiUGVybWlzc2lvbkRlbmllZEVycm9yIiwgIlVucHJvY2Vzc2FibGVFbnRpdHlFcnJvciIsICJHcm9xIiwgIl9hIiwgImRhdGEiLCAibm9kZSIsICJjb250ZW50Il0KfQo=
